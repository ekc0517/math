<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVD ê¸°í•˜í•™ì  ì˜ë¯¸ ì‹œë®¬ë ˆì´í„°</title>
    
    <!-- ë¼ì´ë¸ŒëŸ¬ë¦¬ CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            min-height: 100vh;
            color: #333;
        }

        #controls-container {
            width: 350px;
            background: white;
            padding: 30px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
            overflow-y: auto;
        }

        h1 {
            color: #667eea;
            margin-bottom: 25px;
            font-size: 24px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h2 {
            color: #555;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .matrix-input {
            margin-bottom: 25px;
        }

        .matrix-label {
            font-weight: bold;
            margin-bottom: 10px;
            color: #555;
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            max-width: 200px;
        }

        .matrix-grid input {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            text-align: center;
            transition: border-color 0.3s;
        }

        .matrix-grid input:focus {
            outline: none;
            border-color: #667eea;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 25px;
        }

        button {
            padding: 12px 20px;
            font-size: 15px;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #transform-btn {
            background: #667eea;
            color: white;
        }

        #transform-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        #decompose-btn {
            background: #764ba2;
            color: white;
        }

        #decompose-btn:hover {
            background: #633d8a;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(118, 75, 162, 0.3);
        }

        #reset-btn {
            background: #e74c3c;
            color: white;
        }

        #reset-btn:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        #status-text {
            padding: 15px;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            border-radius: 4px;
            margin-bottom: 20px;
            font-weight: 500;
            min-height: 50px;
        }

        #matrix-display {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
            max-height: 400px;
            overflow-y: auto;
        }

        .matrix-block {
            margin-bottom: 15px;
        }

        .matrix-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }

        .preset-btn {
            padding: 8px;
            font-size: 12px;
            background: #ecf0f1;
            color: #555;
        }

        .preset-btn:hover {
            background: #bdc3c7;
        }
    </style>
</head>
<body>
    <div id="controls-container">
        <h1>ğŸ” SVD ì‹œë®¬ë ˆì´í„°</h1>
        
        <div class="matrix-input">
            <div class="matrix-label">í–‰ë ¬ A (2Ã—2) ì…ë ¥:</div>
            <div class="matrix-grid">
                <input type="number" id="m00" value="2" step="0.1">
                <input type="number" id="m01" value="1" step="0.1">
                <input type="number" id="m10" value="1" step="0.1">
                <input type="number" id="m11" value="2" step="0.1">
            </div>
        </div>

        <div class="preset-buttons">
            <button class="preset-btn" onclick="setPreset(2, 0, 0, 1)">ìŠ¤ì¼€ì¼</button>
            <button class="preset-btn" onclick="setPreset(0, -1, 1, 0)">íšŒì „ 90Â°</button>
            <button class="preset-btn" onclick="setPreset(3, 1, 1, 3)">ëŒ€ì¹­</button>
            <button class="preset-btn" onclick="setPreset(2, 1, 0, 1)">ì „ë‹¨</button>
        </div>

        <div class="button-group">
            <button id="transform-btn">ğŸ¯ ì „ì²´ ë³€í™˜</button>
            <button id="decompose-btn">ğŸ”¬ SVD ë¶„í•´ ë³€í™˜</button>
            <button id="reset-btn">â†º ë¦¬ì…‹</button>
        </div>

        <div id="status-text">ëŒ€ê¸° ì¤‘... ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì‹œì‘í•˜ì„¸ìš”.</div>

        <h2>ğŸ“Š SVD ë¶„í•´ ê²°ê³¼</h2>
        <div id="matrix-display">
            í–‰ë ¬ì„ ì…ë ¥í•˜ê³  ë³€í™˜ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.
        </div>
    </div>

    <div id="canvas-container"></div>

    <script>
        // ========== ì „ì—­ ë³€ìˆ˜ ==========
        let gridPoints = [];
        let circlePoints = [];
        
        let isAnimating = false;
        let animationProgress = 0;
        let animationStage = 0;
        let animationMode = 'none'; // 'direct' or 'decompose'
        let animationSpeed = 0.015;
        
        let matrixA, matrixU, matrixSigma, matrixVT;
        let transformedByV = [];
        let transformedBySigmaV = [];
        
        const GRID_SIZE = 10;
        const GRID_STEP = 1;
        const CIRCLE_POINTS = 100;
        const SCALE = 40; // í”½ì…€ per unit

        // ========== p5.js Setup ==========
        function setup() {
            const canvas = createCanvas(800, 800);
            canvas.parent('canvas-container');
            
            // ì´ˆê¸° ê²©ì ë° ì› ìƒì„±
            initializePoints();
            
            // ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            document.getElementById('transform-btn').addEventListener('click', startDirectAnimation);
            document.getElementById('decompose-btn').addEventListener('click', startDecomposeAnimation);
            document.getElementById('reset-btn').addEventListener('click', resetAnimation);
            
            // ì…ë ¥ í•„ë“œ ë³€ê²½ ì‹œ SVD ì¬ê³„ì‚°
            ['m00', 'm01', 'm10', 'm11'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    if (!isAnimating) {
                        calculateSVD();
                    }
                });
            });
            
            // ì´ˆê¸° SVD ê³„ì‚°
            calculateSVD();
        }

        // ========== p5.js Draw Loop ==========
        function draw() {
            background(255);
            
            // ì¢Œí‘œê³„ ë³€í™˜ (ì¤‘ì•™ ì›ì , Yì¶• ë°˜ì „)
            push();
            translate(width / 2, height / 2);
            scale(1, -1);
            
            // ì¶• ê·¸ë¦¬ê¸°
            drawAxes();
            
            // ì• ë‹ˆë©”ì´ì…˜ ì—…ë°ì´íŠ¸
            if (isAnimating) {
                updateAnimation();
            }
            
            // í˜„ì¬ ìƒíƒœ ê·¸ë¦¬ê¸°
            drawCurrentState();
            
            pop();
        }

        // ========== ì´ˆê¸°í™” í•¨ìˆ˜ ==========
        function initializePoints() {
            gridPoints = [];
            circlePoints = [];
            
            // ê²©ìì  ìƒì„± (ìˆ˜ì§ì„ ê³¼ ìˆ˜í‰ì„ )
            for (let i = -GRID_SIZE; i <= GRID_SIZE; i += GRID_STEP) {
                // ìˆ˜ì§ì„ 
                let verticalLine = [];
                for (let j = -GRID_SIZE; j <= GRID_SIZE; j += GRID_STEP * 0.2) {
                    verticalLine.push(createVector(i, j));
                }
                gridPoints.push(verticalLine);
                
                // ìˆ˜í‰ì„ 
                let horizontalLine = [];
                for (let j = -GRID_SIZE; j <= GRID_SIZE; j += GRID_STEP * 0.2) {
                    horizontalLine.push(createVector(j, i));
                }
                gridPoints.push(horizontalLine);
            }
            
            // ë‹¨ìœ„ ì› ìƒì„±
            for (let i = 0; i < CIRCLE_POINTS; i++) {
                let angle = (i / CIRCLE_POINTS) * TWO_PI;
                circlePoints.push(createVector(cos(angle), sin(angle)));
            }
        }

        // ========== SVD ê³„ì‚° ==========
        function calculateSVD() {
            try {
                const m00 = parseFloat(document.getElementById('m00').value) || 0;
                const m01 = parseFloat(document.getElementById('m01').value) || 0;
                const m10 = parseFloat(document.getElementById('m10').value) || 0;
                const m11 = parseFloat(document.getElementById('m11').value) || 0;
                
                matrixA = math.matrix([[m00, m01], [m10, m11]]);
                
                const svd = math.svd(matrixA);
                matrixU = svd.U;
                matrixVT = math.transpose(svd.V);
                
                // Sigmaë¥¼ ëŒ€ê° í–‰ë ¬ë¡œ ë³€í™˜
                const s = svd.q;
                matrixSigma = math.matrix([
                    [s[0], 0],
                    [0, s[1]]
                ]);
                
                updateMatrixDisplay();
            } catch (error) {
                document.getElementById('matrix-display').innerHTML = 
                    `<span style="color: red;">ì˜¤ë¥˜: ${error.message}</span>`;
            }
        }

        // ========== í–‰ë ¬ í‘œì‹œ ì—…ë°ì´íŠ¸ ==========
        function updateMatrixDisplay() {
            const formatMatrix = (mat, name) => {
                const arr = mat.toArray();
                return `<div class="matrix-block">
                    <div class="matrix-title">${name}:</div>
                    [${arr[0][0].toFixed(3)}, ${arr[0][1].toFixed(3)}]<br>
                    [${arr[1][0].toFixed(3)}, ${arr[1][1].toFixed(3)}]
                </div>`;
            };
            
            let html = '';
            html += formatMatrix(matrixA, 'A (ì›ë³¸ í–‰ë ¬)');
            html += formatMatrix(matrixU, 'U (ì¢Œì¸¡ íšŒì „)');
            html += formatMatrix(matrixSigma, 'Î£ (ìŠ¤ì¼€ì¼)');
            html += formatMatrix(matrixVT, 'Váµ€ (ìš°ì¸¡ íšŒì „)');
            html += `<div class="matrix-block">
                <div class="matrix-title">ê²€ì¦:</div>
                A = U Ã— Î£ Ã— Váµ€
            </div>`;
            
            document.getElementById('matrix-display').innerHTML = html;
        }

        // ========== ë³€í™˜ ì ìš© í•¨ìˆ˜ ==========
        function applyTransform(point, matrix) {
            const result = math.multiply(matrix, [point.x, point.y]);
            return createVector(result[0], result[1]);
        }

        function transformPoints(points, matrix) {
            return points.map(line => {
                if (Array.isArray(line)) {
                    return line.map(p => applyTransform(p, matrix));
                } else {
                    return applyTransform(line, matrix);
                }
            });
        }

        // ========== ì• ë‹ˆë©”ì´ì…˜ ì œì–´ ==========
        function startDirectAnimation() {
            calculateSVD();
            isAnimating = true;
            animationMode = 'direct';
            animationProgress = 0;
            animationStage = 0;
            updateStatusText('ì „ì²´ ë³€í™˜ ì§„í–‰ ì¤‘...');
            disableButtons(true);
        }

        function startDecomposeAnimation() {
            calculateSVD();
            
            // ì¤‘ê°„ ë³€í™˜ ê²°ê³¼ ë¯¸ë¦¬ ê³„ì‚°
            transformedByV = {
                grid: transformPoints(gridPoints, matrixVT),
                circle: circlePoints.map(p => applyTransform(p, matrixVT))
            };
            
            const sigmaV = math.multiply(matrixSigma, matrixVT);
            transformedBySigmaV = {
                grid: transformPoints(gridPoints, sigmaV),
                circle: circlePoints.map(p => applyTransform(p, sigmaV))
            };
            
            isAnimating = true;
            animationMode = 'decompose';
            animationProgress = 0;
            animationStage = 1;
            updateStatusText('1/3 ë‹¨ê³„: Váµ€ íšŒì „ ì ìš© ì¤‘...');
            disableButtons(true);
        }

        function resetAnimation() {
            isAnimating = false;
            animationMode = 'none';
            animationProgress = 0;
            animationStage = 0;
            updateStatusText('ë¦¬ì…‹ ì™„ë£Œ. ëŒ€ê¸° ì¤‘...');
            disableButtons(false);
        }

        function updateAnimation() {
            animationProgress += animationSpeed;
            
            if (animationProgress >= 1) {
                if (animationMode === 'decompose' && animationStage < 3) {
                    animationStage++;
                    animationProgress = 0;
                    
                    if (animationStage === 2) {
                        updateStatusText('2/3 ë‹¨ê³„: Î£ ìŠ¤ì¼€ì¼ ì ìš© ì¤‘...');
                    } else if (animationStage === 3) {
                        updateStatusText('3/3 ë‹¨ê³„: U íšŒì „ ì ìš© ì¤‘...');
                    }
                } else {
                    isAnimating = false;
                    animationProgress = 1;
                    updateStatusText('ë³€í™˜ ì™„ë£Œ!');
                    disableButtons(false);
                }
            }
        }

        // ========== ê·¸ë¦¬ê¸° í•¨ìˆ˜ ==========
        function drawCurrentState() {
            let currentGrid, currentCircle;
            
            if (!isAnimating) {
                // ì •ì§€ ìƒíƒœ: ì›ë³¸ ê·¸ë¦¬ê¸°
                currentGrid = gridPoints;
                currentCircle = circlePoints;
            } else if (animationMode === 'direct') {
                // ì§ì ‘ ë³€í™˜
                currentGrid = interpolateLines(gridPoints, 
                    transformPoints(gridPoints, matrixA), animationProgress);
                currentCircle = interpolatePoints(circlePoints,
                    circlePoints.map(p => applyTransform(p, matrixA)), animationProgress);
            } else if (animationMode === 'decompose') {
                // SVD ë¶„í•´ ë³€í™˜
                if (animationStage === 1) {
                    // Váµ€ ì ìš©
                    currentGrid = interpolateLines(gridPoints, transformedByV.grid, animationProgress);
                    currentCircle = interpolatePoints(circlePoints, transformedByV.circle, animationProgress);
                } else if (animationStage === 2) {
                    // Î£ ì ìš© (Váµ€ ì´í›„)
                    currentGrid = interpolateLines(transformedByV.grid, transformedBySigmaV.grid, animationProgress);
                    currentCircle = interpolatePoints(transformedByV.circle, transformedBySigmaV.circle, animationProgress);
                } else if (animationStage === 3) {
                    // U ì ìš© (Î£ Ã— Váµ€ ì´í›„)
                    const finalGrid = transformPoints(gridPoints, matrixA);
                    const finalCircle = circlePoints.map(p => applyTransform(p, matrixA));
                    currentGrid = interpolateLines(transformedBySigmaV.grid, finalGrid, animationProgress);
                    currentCircle = interpolatePoints(transformedBySigmaV.circle, finalCircle, animationProgress);
                }
            }
            
            // ê²©ì ê·¸ë¦¬ê¸°
            stroke(200, 200, 255, 150);
            strokeWeight(1);
            drawGrid(currentGrid);
            
            // ì› ê·¸ë¦¬ê¸°
            stroke(100, 100, 255);
            strokeWeight(2);
            noFill();
            drawCircle(currentCircle);
            
            // ì›ì  í‘œì‹œ
            fill(255, 0, 0);
            noStroke();
            circle(0, 0, 8);
        }

        function drawGrid(lines) {
            lines.forEach(line => {
                beginShape();
                line.forEach(p => {
                    vertex(p.x * SCALE, p.y * SCALE);
                });
                endShape();
            });
        }

        function drawCircle(points) {
            beginShape();
            points.forEach(p => {
                vertex(p.x * SCALE, p.y * SCALE);
            });
            endShape(CLOSE);
        }

        function drawAxes() {
            stroke(0, 150);
            strokeWeight(1);
            
            // Xì¶•
            line(-width/2, 0, width/2, 0);
            // Yì¶•
            line(0, -height/2, 0, height/2);
            
            // ëˆˆê¸ˆ
            fill(0);
            noStroke();
            textAlign(CENTER, CENTER);
            textSize(10);
            scale(1, -1); // í…ìŠ¤íŠ¸ë¥¼ ìœ„í•´ Yì¶• ë‹¤ì‹œ ë°˜ì „
            
            for (let i = -10; i <= 10; i += 2) {
                if (i !== 0) {
                    text(i, i * SCALE, 15);
                    text(i, -15, i * SCALE);
                }
            }
        }

        // ========== ë³´ê°„ í•¨ìˆ˜ ==========
        function interpolatePoints(start, end, t) {
            return start.map((p, i) => {
                return p5.Vector.lerp(p, end[i], t);
            });
        }

        function interpolateLines(startLines, endLines, t) {
            return startLines.map((line, i) => {
                return line.map((p, j) => {
                    return p5.Vector.lerp(p, endLines[i][j], t);
                });
            });
        }

        // ========== UI í—¬í¼ í•¨ìˆ˜ ==========
        function updateStatusText(text) {
            document.getElementById('status-text').textContent = text;
        }

        function disableButtons(disabled) {
            document.getElementById('transform-btn').disabled = disabled;
            document.getElementById('decompose-btn').disabled = disabled;
        }

        function setPreset(a, b, c, d) {
            document.getElementById('m00').value = a;
            document.getElementById('m01').value = b;
            document.getElementById('m10').value = c;
            document.getElementById('m11').value = d;
            calculateSVD();
        }
    </script>
</body>
</html>
