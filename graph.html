<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Graph Surface Embeddings Simulator</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  background: #f5f5f5;
  color: #333;
}

#app {
  display: grid;
  grid-template-columns: 300px 1fr 350px;
  gap: 10px;
  padding: 10px;
  height: 100vh;
}

.panel {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  padding: 20px;
  overflow-y: auto;
}

h2 {
  font-size: 18px;
  margin-bottom: 15px;
  color: #2c3e50;
  border-bottom: 2px solid #3498db;
  padding-bottom: 8px;
}

h3 {
  font-size: 14px;
  margin: 15px 0 8px 0;
  color: #34495e;
}

select, button, input, textarea {
  width: 100%;
  padding: 8px;
  margin: 5px 0;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 13px;
}

button {
  background: #3498db;
  color: white;
  cursor: pointer;
  font-weight: bold;
  transition: background 0.3s;
}

button:hover {
  background: #2980b9;
}

button:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
}

.info-box {
  background: #ecf0f1;
  padding: 10px;
  border-radius: 4px;
  margin: 10px 0;
  font-size: 12px;
}

.warning {
  background: #fff3cd;
  border-left: 4px solid #ffc107;
}

.success {
  background: #d4edda;
  border-left: 4px solid #28a745;
}

.error {
  background: #f8d7da;
  border-left: 4px solid #dc3545;
}

#mainCanvas {
  width: 100%;
  height: 600px;
  border: 2px solid #34495e;
  border-radius: 8px;
  background: white;
  display: block;
}

.tabs {
  display: flex;
  gap: 5px;
  margin-bottom: 10px;
}

.tab {
  flex: 1;
  padding: 10px 5px;
  background: #ecf0f1;
  border: none;
  border-radius: 4px 4px 0 0;
  cursor: pointer;
  font-size: 12px;
  font-weight: bold;
}

.tab.active {
  background: #3498db;
  color: white;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.surface-tabs {
  display: flex;
  gap: 5px;
  margin-bottom: 10px;
  flex-wrap: wrap;
}

.surface-tab {
  padding: 8px 12px;
  background: #ecf0f1;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
}

.surface-tab.active {
  background: #e74c3c;
  color: white;
}

.checkbox-group {
  margin: 10px 0;
}

.checkbox-group label {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  cursor: pointer;
}

.checkbox-group input[type="checkbox"] {
  width: auto;
}

.edge-list {
  max-height: 150px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 5px;
  border-radius: 4px;
  font-size: 11px;
}

.edge-item {
  padding: 3px;
  margin: 2px 0;
  background: #f8f9fa;
  border-radius: 2px;
  cursor: pointer;
}

.edge-item:hover {
  background: #e9ecef;
}

.edge-item.twisted {
  background: #ffebee;
  border-left: 3px solid #e74c3c;
}

code {
  background: #f4f4f4;
  padding: 2px 4px;
  border-radius: 2px;
  font-size: 11px;
}

.result-strong {
  font-size: 16px;
  font-weight: bold;
  padding: 10px;
  border-radius: 4px;
  text-align: center;
  margin: 10px 0;
}

.result-strong.yes {
  background: #d4edda;
  color: #155724;
}

.result-strong.no {
  background: #f8d7da;
  color: #721c24;
}

textarea {
  font-family: monospace;
  font-size: 11px;
  min-height: 80px;
}

.help-text {
  font-size: 11px;
  color: #6c757d;
  font-style: italic;
  margin: 5px 0;
}

ul {
  margin-left: 20px;
  font-size: 12px;
}

ul li {
  margin: 5px 0;
}
</style>
</head>
<body>

<div id="app">
  <!-- Left Panel: Graph Input -->
  <div class="panel">
    <h2>1. 그래프 선택/편집</h2>
    
    <h3>예제 그래프</h3>
    <select id="exampleGraphs">
      <option value="">-- 선택하세요 --</option>
      <option value="cube">Cube (8 vertices)</option>
      <option value="tetrahedron">Truncated Tetrahedron (12v)</option>
      <option value="octahedron">Octahedron (6v)</option>
      <option value="prism">Triangular Prism (6v)</option>
      <option value="k4">K4 (4v)</option>
    </select>
    <button id="loadExample">예제 불러오기</button>
    
    <h3>편집 모드</h3>
    <div class="checkbox-group">
      <label>
        <input type="checkbox" id="editMode">
        편집 모드 활성화
      </label>
    </div>
    <div class="help-text">
      편집 모드: 클릭으로 정점 추가, 드래그로 이동, Shift+클릭으로 간선 추가
    </div>
    
    <div class="info-box">
      <strong>현재 그래프:</strong><br>
      정점: <span id="vertexCount">0</span><br>
      간선: <span id="edgeCount">0</span><br>
      <span id="graphProperties"></span>
    </div>
    
    <h3>그래프 데이터</h3>
    <button id="exportGraph">내보내기 (JSON)</button>
    <textarea id="graphData" placeholder="JSON 형식 그래프 데이터"></textarea>
    <button id="importGraph">불러오기 (JSON)</button>
    
    <button id="clearGraph">그래프 초기화</button>
  </div>
  
  <!-- Center Panel: Embedding Visualization -->
  <div class="panel">
    <h2>2. 표면 위 임베딩 시뮬레이션</h2>
    
    <div class="surface-tabs">
      <button class="surface-tab active" data-surface="sphere">Sphere</button>
      <button class="surface-tab" data-surface="projective">Projective Plane</button>
      <button class="surface-tab" data-surface="torus">Torus</button>
      <button class="surface-tab" data-surface="klein">Klein Bottle</button>
    </div>
    
    <div class="checkbox-group">
      <label>
        <input type="checkbox" id="showFaces">
        Face 경계 표시
      </label>
      <label>
        <input type="checkbox" id="showDual">
        Dual Graph 표시
      </label>
      <label>
        <input type="checkbox" id="showLabels">
        레이블 표시
      </label>
    </div>
    
    <svg id="mainCanvas"></svg>
    
    <div class="info-box">
      <strong>현재 임베딩 정보</strong><br>
      표면: <span id="currentSurface">Sphere</span><br>
      Twisted edges: <span id="twistedCount">0</span><br>
      <div id="rotationInfo" style="font-size:10px; max-height:100px; overflow-y:auto;"></div>
    </div>
  </div>
  
  <!-- Right Panel: Theory & Results -->
  <div class="panel">
    <h2>3. 이론 & 결과</h2>
    
    <div class="tabs">
      <button class="tab active" data-tab="enami">Enami</button>
      <button class="tab" data-tab="weiss">W-N</button>
      <button class="tab" data-tab="juvan">J-M</button>
      <button class="tab" data-tab="hubard">Hubard</button>
    </div>
    
    <!-- Enami Tab -->
    <div class="tab-content active" id="enami-content">
      <h3>Enami (2019) - Re-embeddings</h3>
      <div class="help-text">
        3-connected 3-regular planar graphs의 non-negative Euler characteristic 표면 re-embedding
      </div>
      
      <button id="computeDual">Dual Graph 계산</button>
      <div id="dualInfo" class="info-box"></div>
      
      <h3>Twisted Subgraph H<sub>T</sub></h3>
      <div id="htInfo" class="info-box"></div>
      
      <h3>Admissible Sets</h3>
      <button id="enumerateEmbeddings">모든 Re-embedding 열거</button>
      <div id="embeddingsList" class="edge-list"></div>
    </div>
    
    <!-- Weiß-Niemeyer Tab -->
    <div class="tab-content" id="weiss-content">
      <h3>Weiß-Niemeyer (2024) - Strong Embeddings</h3>
      <div class="help-text">
        Strong embedding: 모든 face가 cycle인 2-cell embedding
      </div>
      
      <button id="checkStrong">Strong Embedding 판정</button>
      
      <div id="strongResult"></div>
      
      <div id="strongExplanation" class="info-box" style="font-size:11px;">
      </div>
    </div>
    
    <!-- Juvan-Mohar Tab -->
    <div class="tab-content" id="juvan-content">
      <h3>Juvan-Mohar (1997) - Torus Embedding</h3>
      <div class="help-text">
        토러스 임베딩 가능성 판정 알고리즘
      </div>
      
      <button id="tryTorusEmbed">토러스 임베딩 시도</button>
      
      <div id="torusResult" class="info-box"></div>
      
      <h3>알고리즘 개요</h3>
      <ul style="font-size:11px;">
        <li>3-연결 분해</li>
        <li>Projective planar 판정</li>
        <li>Face-width 검사</li>
        <li>Rotation system 구성</li>
      </ul>
    </div>
    
    <!-- Hubard et al. Tab -->
    <div class="tab-content" id="hubard-content">
      <h3>Hubard et al. (2016) - Shortest Path</h3>
      <div class="help-text">
        표면 위 그래프의 shortest path embedding
      </div>
      
      <div class="checkbox-group">
        <label>
          <input type="checkbox" id="shortestPathMode">
          Shortest Path 모드
        </label>
      </div>
      
      <button id="checkShortestPath">Shortest Path 판정</button>
      
      <div id="shortestPathResult" class="info-box"></div>
      
      <h3>Minimal Triangulations</h3>
      <button id="loadMinimalTorus">Torus Minimal (7v)</button>
      <button id="loadMinimalKlein">Klein Minimal Kc1</button>
      
      <div class="info-box" style="font-size:10px;">
        <strong>Theorem 2:</strong> Klein bottle의 unit square flat metric에서는 universal shortest path metric이 존재하지 않음
      </div>
    </div>
  </div>
</div>

<script>
'use strict';

// ============================================================================
// Graph Class - Basic graph data structure
// ============================================================================
class Graph {
  constructor() {
    this.vertices = []; // {id, x, y}
    this.edges = []; // {id, u, v}
    this.nextVertexId = 0;
    this.nextEdgeId = 0;
  }
  
  addVertex(x, y) {
    const v = {id: this.nextVertexId++, x, y};
    this.vertices.push(v);
    return v;
  }
  
  addEdge(u, v) {
    // Check if edge already exists
    if (this.hasEdge(u, v)) return null;
    // No self-loops
    if (u === v) return null;
    
    const e = {id: this.nextEdgeId++, u, v};
    this.edges.push(e);
    return e;
  }
  
  hasEdge(u, v) {
    return this.edges.some(e => 
      (e.u === u && e.v === v) || (e.u === v && e.v === u)
    );
  }
  
  removeVertex(id) {
    this.vertices = this.vertices.filter(v => v.id !== id);
    this.edges = this.edges.filter(e => e.u !== id && e.v !== id);
  }
  
  removeEdge(id) {
    this.edges = this.edges.filter(e => e.id !== id);
  }
  
  getVertex(id) {
    return this.vertices.find(v => v.id === id);
  }
  
  getEdge(id) {
    return this.edges.find(e => e.id === id);
  }
  
  getNeighbors(vid) {
    const neighbors = [];
    for (const e of this.edges) {
      if (e.u === vid) neighbors.push(e.v);
      else if (e.v === vid) neighbors.push(e.u);
    }
    return neighbors;
  }
  
  getDegree(vid) {
    return this.getNeighbors(vid).length;
  }
  
  // Check if graph is 3-regular
  is3Regular() {
    return this.vertices.every(v => this.getDegree(v.id) === 3);
  }
  
  // Simple connectivity check using DFS
  isConnected() {
    if (this.vertices.length === 0) return true;
    const visited = new Set();
    const stack = [this.vertices[0].id];
    
    while (stack.length > 0) {
      const vid = stack.pop();
      if (visited.has(vid)) continue;
      visited.add(vid);
      
      for (const nid of this.getNeighbors(vid)) {
        if (!visited.has(nid)) stack.push(nid);
      }
    }
    
    return visited.size === this.vertices.length;
  }
  
  // Check 3-connectivity (simplified - uses vertex connectivity)
  // For educational purposes only - not exact for all cases
  is3Connected() {
    if (this.vertices.length < 4) return false;
    if (!this.isConnected()) return false;
    
    // Check if removing any single vertex keeps graph connected
    for (const v of this.vertices) {
      const tempGraph = this.clone();
      tempGraph.removeVertex(v.id);
      if (!tempGraph.isConnected()) return false;
    }
    
    // Check if removing any pair of vertices keeps graph connected
    for (let i = 0; i < this.vertices.length; i++) {
      for (let j = i + 1; j < this.vertices.length; j++) {
        const tempGraph = this.clone();
        tempGraph.removeVertex(this.vertices[i].id);
        tempGraph.removeVertex(this.vertices[j].id);
        if (!tempGraph.isConnected()) return false;
      }
    }
    
    return true;
  }
  
  clone() {
    const g = new Graph();
    g.vertices = this.vertices.map(v => ({...v}));
    g.edges = this.edges.map(e => ({...e}));
    g.nextVertexId = this.nextVertexId;
    g.nextEdgeId = this.nextEdgeId;
    return g;
  }
  
  toJSON() {
    return {
      vertices: this.vertices,
      edges: this.edges,
      nextVertexId: this.nextVertexId,
      nextEdgeId: this.nextEdgeId
    };
  }
  
  fromJSON(data) {
    this.vertices = data.vertices || [];
    this.edges = data.edges || [];
    this.nextVertexId = data.nextVertexId || 0;
    this.nextEdgeId = data.nextEdgeId || 0;
  }
}

// ============================================================================
// Embedding Class - Represents a graph embedding on a surface
// Enami (2019), Weiß-Niemeyer (2024)
// ============================================================================
class Embedding {
  constructor(graph) {
    this.graph = graph;
    this.rotation = new Map(); // vertex id -> ordered array of neighbor ids
    this.twistedEdges = new Set(); // edge ids
    this.surface = 'sphere'; // sphere, projective, torus, klein
    this.faces = []; // computed facial cycles
  }
  
  // Compute rotation system from vertex positions (planar case)
  computePlanarRotation() {
    this.rotation.clear();
    
    for (const v of this.graph.vertices) {
      const neighbors = this.graph.getNeighbors(v.id);
      
      // Sort neighbors by angle
      const angles = neighbors.map(nid => {
        const n = this.graph.getVertex(nid);
        return {
          id: nid,
          angle: Math.atan2(n.y - v.y, n.x - v.x)
        };
      });
      
      angles.sort((a, b) => a.angle - b.angle);
      this.rotation.set(v.id, angles.map(a => a.id));
    }
  }
  
  toggleTwistedEdge(edgeId) {
    if (this.twistedEdges.has(edgeId)) {
      this.twistedEdges.delete(edgeId);
    } else {
      this.twistedEdges.add(edgeId);
    }
  }
  
  // Compute faces using rotation system
  // Reference: Enami (2019) - face computation for re-embedding
  computeFaces() {
    this.faces = [];
    const usedDarts = new Set(); // dart = (v, w) directed edge
    
    const dartKey = (v, w) => `${v}->${w}`;
    
    for (const e of this.graph.edges) {
      // Try both directions
      for (const [start, next] of [[e.u, e.v], [e.v, e.u]]) {
        const dk = dartKey(start, next);
        if (usedDarts.has(dk)) continue;
        
        const face = [];
        let current = start;
        let prev = next;
        
        // Walk around face
        do {
          face.push(current);
          usedDarts.add(dartKey(current, prev));
          
          const rotation = this.rotation.get(prev) || [];
          const idx = rotation.indexOf(current);
          if (idx === -1) break;
          
          // Next vertex in rotation (counterclockwise)
          const nextIdx = (idx + 1) % rotation.length;
          const nextVertex = rotation[nextIdx];
          
          current = prev;
          prev = nextVertex;
          
          if (face.length > this.graph.vertices.length * 2) break; // Safety
        } while (current !== start || prev !== next);
        
        if (face.length >= 3) {
          this.faces.push(face);
        }
      }
    }
    
    return this.faces;
  }
  
  // Get rotation info as string
  getRotationString() {
    let str = '';
    for (const [vid, neighbors] of this.rotation.entries()) {
      str += `v${vid}: [${neighbors.map(n => `v${n}`).join(', ')}]\n`;
    }
    return str;
  }
}

// ============================================================================
// Dual Graph Computation
// Enami (2019) - Theorem 1, 2, 3 use dual graph patterns
// ============================================================================
class DualGraph {
  constructor(embedding) {
    this.embedding = embedding;
    this.dualVertices = []; // one per face
    this.dualEdges = [];
  }
  
  compute() {
    this.dualVertices = [];
    this.dualEdges = [];
    
    const faces = this.embedding.computeFaces();
    
    // Create dual vertex for each face
    for (let i = 0; i < faces.length; i++) {
      this.dualVertices.push({id: i, face: faces[i]});
    }
    
    // Create dual edges for adjacent faces
    // Two faces are adjacent if they share an edge
    const edgeFaceMap = new Map(); // edge -> [face indices]
    
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      for (let j = 0; j < face.length; j++) {
        const u = face[j];
        const v = face[(j + 1) % face.length];
        const edgeKey = u < v ? `${u}-${v}` : `${v}-${u}`;
        
        if (!edgeFaceMap.has(edgeKey)) {
          edgeFaceMap.set(edgeKey, []);
        }
        edgeFaceMap.get(edgeKey).push(i);
      }
    }
    
    // Create dual edges
    const addedPairs = new Set();
    for (const [edgeKey, faceIndices] of edgeFaceMap.entries()) {
      if (faceIndices.length === 2) {
        const [f1, f2] = faceIndices;
        const pairKey = f1 < f2 ? `${f1}-${f2}` : `${f2}-${f1}`;
        if (!addedPairs.has(pairKey)) {
          addedPairs.add(pairKey);
          
          // Find original edge id
          const [u, v] = edgeKey.split('-').map(Number);
          const originalEdge = this.embedding.graph.edges.find(e =>
            (e.u === u && e.v === v) || (e.u === v && e.v === u)
          );
          
          this.dualEdges.push({
            u: f1,
            v: f2,
            originalEdgeId: originalEdge ? originalEdge.id : null
          });
        }
      }
    }
    
    return this;
  }
  
  // Get subgraph induced by twisted edges
  // Enami (2019) - H_T is the subgraph of dual graph induced by twisted edges
  getTwistedSubgraph() {
    const twistedDualEdges = this.dualEdges.filter(de =>
      this.embedding.twistedEdges.has(de.originalEdgeId)
    );
    
    // Get vertices involved
    const vertexSet = new Set();
    for (const e of twistedDualEdges) {
      vertexSet.add(e.u);
      vertexSet.add(e.v);
    }
    
    return {
      vertices: Array.from(vertexSet),
      edges: twistedDualEdges
    };
  }
  
  // Pattern recognition for H_T
  // Enami (2019) - Theorem 1, 2, 3 enumerate specific patterns
  recognizePattern(subgraph) {
    const n = subgraph.vertices.length;
    const m = subgraph.edges.length;
    
    if (m === 0) return 'empty';
    if (m === 1) return 'K2';
    if (n === 4 && m === 6) return 'K4';
    if (n === 6 && m === 9) return 'K2,2,2';
    
    // Check for complete bipartite-like patterns
    // This is simplified - full pattern matching would need isomorphism checking
    
    if (m === 2 && n === 3) return 'K1,2';
    if (m === 3 && n === 3) return 'triangle';
    
    // Degree sequence analysis
    const degrees = new Map();
    for (const v of subgraph.vertices) {
      degrees.set(v, 0);
    }
    for (const e of subgraph.edges) {
      degrees.set(e.u, degrees.get(e.u) + 1);
      degrees.set(e.v, degrees.get(e.v) + 1);
    }
    
    const degSeq = Array.from(degrees.values()).sort((a, b) => b - a);
    
    // Try to match K_{2,2m}, K_{2,2m-1}, K_{1,1,2m-1}, K_{1,1,2m}
    if (degSeq.length >= 3) {
      const [d1, d2, d3] = degSeq;
      
      // K_{2,2m}: two vertices of degree 2m, 2m vertices of degree 2
      if (degSeq.filter(d => d === d1).length === 2 && d1 === n - 2) {
        const m_val = d1 / 2;
        if (m_val === Math.floor(m_val)) {
          return `K2,${d1}`;
        }
      }
      
      // K_{1,1,k}
      if (degSeq.filter(d => d === d1).length === 2 && d1 === n - 2) {
        return `K1,1,${n-2}`;
      }
    }
    
    // Special cases A1-A6 (Klein bottle, Weiß-Niemeyer Table 2)
    // Simplified detection
    if (n === 5 && m === 6) return 'A3';
    if (n === 5 && m === 5) return 'A1';
    
    return `unknown(${n}v,${m}e)`;
  }
  
  // Determine which surface this twisted subgraph corresponds to
  // Enami (2019) - Theorems 1, 2, 3
  determineSurface(pattern) {
    // Projective plane: K2, K4
    if (pattern === 'K2' || pattern === 'K4') {
      return {surface: 'projective', theorem: 'Enami Thm 1'};
    }
    
    // Torus: K_{2,2,2}, K_{2,2m} (m >= 2), K_{1,1,2m-1}
    if (pattern === 'K2,2,2') {
      return {surface: 'torus', theorem: 'Enami Thm 2'};
    }
    if (pattern.startsWith('K2,')) {
      const m = parseInt(pattern.split(',')[1]);
      if (m >= 4 && m % 2 === 0) {
        return {surface: 'torus', theorem: 'Enami Thm 2'};
      }
    }
    if (pattern.startsWith('K1,1,')) {
      const k = parseInt(pattern.split(',')[2]);
      if (k % 2 === 1 && k >= 3) {
        return {surface: 'torus', theorem: 'Enami Thm 2'};
      }
    }
    
    // Klein bottle: K_{2,2m-1}, K_{1,1,2m}, A1-A6
    if (pattern.startsWith('K2,')) {
      const m = parseInt(pattern.split(',')[1]);
      if (m >= 3 && m % 2 === 1) {
        return {surface: 'klein', theorem: 'Enami Thm 3'};
      }
    }
    if (pattern.startsWith('K1,1,')) {
      const k = parseInt(pattern.split(',')[2]);
      if (k % 2 === 0 && k >= 2) {
        return {surface: 'klein', theorem: 'Enami Thm 3'};
      }
    }
    if (pattern.startsWith('A')) {
      return {surface: 'klein', theorem: 'Enami Thm 3'};
    }
    
    return {surface: 'unknown', theorem: 'N/A'};
  }
}

// ============================================================================
// Strong Embedding Checker
// Weiß-Niemeyer (2024) - Theorem 1, Lemmas 16-19
// ============================================================================
class StrongEmbeddingChecker {
  constructor(embedding, dualGraph) {
    this.embedding = embedding;
    this.dualGraph = dualGraph;
  }
  
  // Check if embedding is strong (all faces are cycles)
  isStrong() {
    const faces = this.embedding.computeFaces();
    
    // For strong embedding, all faces must be cycles
    // In our representation, we check if face boundary forms a simple cycle
    for (const face of faces) {
      if (face.length < 3) return false;
      
      // Check if all consecutive vertices in face are connected
      for (let i = 0; i < face.length; i++) {
        const u = face[i];
        const v = face[(i + 1) % face.length];
        if (!this.embedding.graph.hasEdge(u, v)) {
          return false;
        }
      }
    }
    
    return true;
  }
  
  // Determine if twisted subgraph gives strong embedding
  // Weiß-Niemeyer (2024) - Lemmas 16, 17, 18, 19
  checkStrongByCriteria(pattern, surface) {
    const criteria = {
      isStrong: false,
      reason: '',
      lemma: ''
    };
    
    // Projective plane - Lemma 16
    if (surface === 'projective') {
      if (pattern === 'K4') {
        criteria.isStrong = true;
        criteria.reason = 'H_T ≅ K4 on projective plane';
        criteria.lemma = 'Weiß-Niemeyer Lemma 16';
      } else if (pattern === 'K2') {
        criteria.isStrong = false;
        criteria.reason = 'H_T ≅ K2 gives non-cycle faces';
        criteria.lemma = 'Weiß-Niemeyer Lemma 16';
      }
    }
    
    // Torus - Lemma 17
    if (surface === 'torus') {
      if (pattern === 'K2,2,2') {
        criteria.isStrong = true;
        criteria.reason = 'H_T ≅ K_{2,2,2} always strong';
        criteria.lemma = 'Weiß-Niemeyer Lemma 17';
      } else if (pattern.startsWith('K2,')) {
        // K_{2,2m}: strong iff the two size-2 part vertices are non-adjacent
        criteria.isStrong = true; // Simplified - would need actual check
        criteria.reason = 'H_T ≅ K_{2,2m}, assuming non-adjacent condition';
        criteria.lemma = 'Weiß-Niemeyer Lemma 17';
      } else if (pattern.startsWith('K1,1,')) {
        criteria.isStrong = false;
        criteria.reason = 'H_T ≅ K_{1,1,2m-1} not strong';
        criteria.lemma = 'Weiß-Niemeyer Lemma 17';
      }
    }
    
    // Klein bottle - Lemmas 18, 19
    if (surface === 'klein') {
      if (pattern.startsWith('K2,')) {
        criteria.isStrong = true;
        criteria.reason = 'H_T ≅ K_{2,2m-1}, assuming non-adjacent condition';
        criteria.lemma = 'Weiß-Niemeyer Lemma 18';
      } else if (pattern === 'A3' || pattern === 'A5' || pattern === 'A6') {
        criteria.isStrong = true;
        criteria.reason = `H_T ≅ ${pattern} gives strong embedding`;
        criteria.lemma = 'Weiß-Niemeyer Lemma 19';
      } else if (pattern === 'A1' || pattern === 'A2' || pattern === 'A4') {
        criteria.isStrong = false;
        criteria.reason = `H_T ≅ ${pattern} not strong`;
        criteria.lemma = 'Weiß-Niemeyer Lemma 19';
      } else if (pattern.startsWith('K1,1,')) {
        criteria.isStrong = false;
        criteria.reason = 'H_T ≅ K_{1,1,2m} not strong';
        criteria.lemma = 'Weiß-Niemeyer Lemma 18';
      }
    }
    
    return criteria;
  }
}

// ============================================================================
// Example Graphs Generator
// ============================================================================
class ExampleGraphs {
  static createCube() {
    const g = new Graph();
    const r = 150;
    const center = 250;
    
    // 8 vertices of cube in circular layout
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * 2 * Math.PI;
      g.addVertex(
        center + r * Math.cos(angle),
        center + r * Math.sin(angle)
      );
    }
    
    // Edges of cube (3-regular)
    const edges = [
      [0,1],[1,2],[2,3],[3,0], // outer square
      [4,5],[5,6],[6,7],[7,4], // inner square
      [0,4],[1,5],[2,6],[3,7]  // connecting edges
    ];
    
    for (const [u, v] of edges) {
      g.addEdge(u, v);
    }
    
    return g;
  }
  
  static createOctahedron() {
    const g = new Graph();
    const r = 120;
    const center = 250;
    
    // 6 vertices
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * 2 * Math.PI;
      g.addVertex(
        center + r * Math.cos(angle),
        center + r * Math.sin(angle)
      );
    }
    
    // Octahedron edges (3-regular, 12 edges)
    const edges = [
      [0,1],[1,2],[2,3],[3,4],[4,5],[5,0],
      [0,2],[2,4],[4,0],
      [1,3],[3,5],[5,1]
    ];
    
    for (const [u, v] of edges) {
      g.addEdge(u, v);
    }
    
    return g;
  }
  
  static createTriangularPrism() {
    const g = new Graph();
    const r = 100;
    const center = 250;
    
    // 6 vertices (two triangles)
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * 2 * Math.PI;
      g.addVertex(
        center + r * Math.cos(angle),
        center + r * Math.sin(angle)
      );
    }
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * 2 * Math.PI;
      g.addVertex(
        center + (r * 1.8) * Math.cos(angle),
        center + (r * 1.8) * Math.sin(angle)
      );
    }
    
    // Edges
    const edges = [
      [0,1],[1,2],[2,0], // first triangle
      [3,4],[4,5],[5,3], // second triangle
      [0,3],[1,4],[2,5]  // connecting edges
    ];
    
    for (const [u, v] of edges) {
      g.addEdge(u, v);
    }
    
    return g;
  }
  
  static createK4() {
    const g = new Graph();
    const r = 100;
    const center = 250;
    
    // 4 vertices
    for (let i = 0; i < 4; i++) {
      const angle = (i / 4) * 2 * Math.PI;
      g.addVertex(
        center + r * Math.cos(angle),
        center + r * Math.sin(angle)
      );
    }
    
    // All edges (complete graph)
    for (let i = 0; i < 4; i++) {
      for (let j = i + 1; j < 4; j++) {
        g.addEdge(i, j);
      }
    }
    
    return g;
  }
  
  static createTruncatedTetrahedron() {
    const g = new Graph();
    const r = 150;
    const center = 250;
    
    // 12 vertices in circular layout
    for (let i = 0; i < 12; i++) {
      const angle = (i / 12) * 2 * Math.PI;
      g.addVertex(
        center + r * Math.cos(angle),
        center + r * Math.sin(angle)
      );
    }
    
    // Truncated tetrahedron edges (3-regular, 18 edges)
    // Simplified layout
    const edges = [
      [0,1],[1,2],[3,4],[4,5],[6,7],[7,8],[9,10],[10,11],
      [0,11],[2,3],[5,6],[8,9],
      [0,4],[1,7],[2,10],[3,5],[6,11],[8,9]
    ];
    
    for (const [u, v] of edges) {
      g.addEdge(u, v);
    }
    
    return g;
  }
  
  // Hubard et al. (2016) - Minimal triangulation examples
  static createTorusMinimal() {
    // 7 vertices minimal triangulation of torus
    const g = new Graph();
    const r = 120;
    const center = 250;
    
    for (let i = 0; i < 7; i++) {
      const angle = (i / 7) * 2 * Math.PI;
      g.addVertex(
        center + r * Math.cos(angle),
        center + r * Math.sin(angle)
      );
    }
    
    // Complete graph K7 (simplified - actual minimal triangulation has specific structure)
    for (let i = 0; i < 7; i++) {
      for (let j = i + 1; j < 7; j++) {
        g.addEdge(i, j);
      }
    }
    
    return g;
  }
  
  static createKleinMinimal() {
    // Klein bottle minimal triangulation Kc1
    // Hubard et al. (2016) Theorem 2 - no shortest path embedding on unit square
    const g = new Graph();
    const r = 100;
    const center = 250;
    
    for (let i = 0; i < 6; i++) {
      const angle = (i / 6) * 2 * Math.PI;
      g.addVertex(
        center + r * Math.cos(angle),
        center + r * Math.sin(angle)
      );
    }
    
    // Specific Klein bottle triangulation
    const edges = [
      [0,1],[1,2],[2,3],[3,4],[4,5],[5,0],
      [0,2],[2,4],[4,0],
      [1,3],[3,5],[5,1]
    ];
    
    for (const [u, v] of edges) {
      g.addEdge(u, v);
    }
    
    return g;
  }
}

// ============================================================================
// Visualization & Rendering
// ============================================================================
class Renderer {
  constructor(svgElement) {
    this.svg = svgElement;
    this.width = 800;
    this.height = 600;
    this.svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);
    
    this.graph = null;
    this.embedding = null;
    this.showFaces = false;
    this.showDual = false;
    this.showLabels = true;
    this.surface = 'sphere';
    
    this.selectedVertex = null;
    this.firstSelectedVertex = null; // For edge creation
    
    this.onVertexClick = null;
    this.onEdgeClick = null;
  }
  
  setGraph(graph, embedding) {
    this.graph = graph;
    this.embedding = embedding;
  }
  
  setSurface(surface) {
    this.surface = surface;
  }
  
  clear() {
    this.svg.innerHTML = '';
  }
  
  render() {
    this.clear();
    if (!this.graph) return;
    
    // Draw surface background
    this.drawSurface();
    
    // Draw faces if enabled
    if (this.showFaces && this.embedding) {
      this.drawFaces();
    }
    
    // Draw dual graph if enabled
    if (this.showDual && this.embedding) {
      this.drawDualGraph();
    }
    
    // Draw edges
    this.drawEdges();
    
    // Draw vertices
    this.drawVertices();
  }
  
  drawSurface() {
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.setAttribute('id', 'surface-background');
    
    if (this.surface === 'sphere') {
      // Simple rectangle
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', 50);
      rect.setAttribute('y', 50);
      rect.setAttribute('width', this.width - 100);
      rect.setAttribute('height', this.height - 100);
      rect.setAttribute('fill', '#f9f9f9');
      rect.setAttribute('stroke', '#ccc');
      rect.setAttribute('stroke-width', 2);
      g.appendChild(rect);
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', 60);
      text.setAttribute('y', 70);
      text.setAttribute('font-size', 12);
      text.setAttribute('fill', '#999');
      text.textContent = 'Sphere (Planar)';
      g.appendChild(text);
    }
    else if (this.surface === 'torus') {
      // Fundamental polygon: square with identified edges
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', 100);
      rect.setAttribute('y', 100);
      rect.setAttribute('width', 400);
      rect.setAttribute('height', 400);
      rect.setAttribute('fill', '#fff9e6');
      rect.setAttribute('stroke', '#666');
      rect.setAttribute('stroke-width', 3);
      g.appendChild(rect);
      
      // Arrows showing identification
      this.drawArrow(g, 100, 250, 80, 250, '#e74c3c'); // left
      this.drawArrow(g, 500, 250, 520, 250, '#e74c3c'); // right
      this.drawArrow(g, 300, 100, 300, 80, '#3498db'); // top
      this.drawArrow(g, 300, 500, 300, 520, '#3498db'); // bottom
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', 110);
      text.setAttribute('y', 120);
      text.setAttribute('font-size', 12);
      text.setAttribute('fill', '#666');
      text.textContent = 'Torus (opposite edges identified)';
      g.appendChild(text);
    }
    else if (this.surface === 'klein') {
      // Klein bottle: rectangle with one pair reversed
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', 100);
      rect.setAttribute('y', 100);
      rect.setAttribute('width', 400);
      rect.setAttribute('height', 400);
      rect.setAttribute('fill', '#ffe6f0');
      rect.setAttribute('stroke', '#666');
      rect.setAttribute('stroke-width', 3);
      g.appendChild(rect);
      
      // Arrows (one pair reversed)
      this.drawArrow(g, 100, 250, 80, 250, '#e74c3c');
      this.drawArrow(g, 520, 250, 500, 250, '#e74c3c'); // reversed
      this.drawArrow(g, 300, 100, 300, 80, '#3498db');
      this.drawArrow(g, 300, 500, 300, 520, '#3498db');
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', 110);
      text.setAttribute('y', 120);
      text.setAttribute('font-size', 12);
      text.setAttribute('fill', '#666');
      text.textContent = 'Klein Bottle (one pair reversed)';
      g.appendChild(text);
    }
    else if (this.surface === 'projective') {
      // Projective plane: disk with antipodal points identified
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', 300);
      circle.setAttribute('cy', 300);
      circle.setAttribute('r', 200);
      circle.setAttribute('fill', '#e6f3ff');
      circle.setAttribute('stroke', '#666');
      circle.setAttribute('stroke-width', 3);
      circle.setAttribute('stroke-dasharray', '5,5');
      g.appendChild(circle);
      
      const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      text.setAttribute('x', 200);
      text.setAttribute('y', 120);
      text.setAttribute('font-size', 12);
      text.setAttribute('fill', '#666');
      text.textContent = 'Projective Plane (antipodal identification)';
      g.appendChild(text);
    }
    
    this.svg.appendChild(g);
  }
  
  drawArrow(parent, x1, y1, x2, y2, color) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('stroke', color);
    line.setAttribute('stroke-width', 2);
    line.setAttribute('marker-end', 'url(#arrowhead)');
    parent.appendChild(line);
    
    // Define arrowhead marker if not exists
    if (!this.svg.querySelector('#arrowhead')) {
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', 10);
      marker.setAttribute('markerHeight', 10);
      marker.setAttribute('refX', 5);
      marker.setAttribute('refY', 3);
      marker.setAttribute('orient', 'auto');
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 6 3, 0 6');
      polygon.setAttribute('fill', color);
      marker.appendChild(polygon);
      defs.appendChild(marker);
      this.svg.appendChild(defs);
    }
  }
  
  drawFaces() {
    if (!this.embedding) return;
    const faces = this.embedding.computeFaces();
    
    const colors = ['#ffcdd2', '#f8bbd0', '#e1bee7', '#c5cae9', '#bbdefb', '#b2dfdb', '#c8e6c9', '#fff9c4'];
    
    for (let i = 0; i < faces.length; i++) {
      const face = faces[i];
      if (face.length < 3) continue;
      
      const points = face.map(vid => {
        const v = this.graph.getVertex(vid);
        return `${v.x},${v.y}`;
      }).join(' ');
      
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', points);
      polygon.setAttribute('fill', colors[i % colors.length]);
      polygon.setAttribute('fill-opacity', 0.3);
      polygon.setAttribute('stroke', '#666');
      polygon.setAttribute('stroke-width', 1);
      polygon.setAttribute('stroke-dasharray', '2,2');
      
      this.svg.appendChild(polygon);
    }
  }
  
  drawDualGraph() {
    const dual = new DualGraph(this.embedding);
    dual.compute();
    
    // Compute center of each face for dual vertex position
    const dualPositions = [];
    for (const dv of dual.dualVertices) {
      let cx = 0, cy = 0;
      for (const vid of dv.face) {
        const v = this.graph.getVertex(vid);
        cx += v.x;
        cy += v.y;
      }
      cx /= dv.face.length;
      cy /= dv.face.length;
      dualPositions.push({x: cx, y: cy});
    }
    
    // Draw dual edges
    for (const de of dual.dualEdges) {
      const p1 = dualPositions[de.u];
      const p2 = dualPositions[de.v];
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', p1.x);
      line.setAttribute('y1', p1.y);
      line.setAttribute('x2', p2.x);
      line.setAttribute('y2', p2.y);
      line.setAttribute('stroke', '#9c27b0');
      line.setAttribute('stroke-width', 2);
      line.setAttribute('stroke-dasharray', '3,3');
      line.setAttribute('opacity', 0.6);
      
      this.svg.appendChild(line);
    }
    
    // Draw dual vertices
    for (const pos of dualPositions) {
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', pos.x);
      circle.setAttribute('cy', pos.y);
      circle.setAttribute('r', 5);
      circle.setAttribute('fill', '#9c27b0');
      circle.setAttribute('stroke', 'white');
      circle.setAttribute('stroke-width', 2);
      
      this.svg.appendChild(circle);
    }
  }
  
  drawEdges() {
    for (const e of this.graph.edges) {
      const u = this.graph.getVertex(e.u);
      const v = this.graph.getVertex(e.v);
      
      const isTwisted = this.embedding && this.embedding.twistedEdges.has(e.id);
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', u.x);
      line.setAttribute('y1', u.y);
      line.setAttribute('x2', v.x);
      line.setAttribute('y2', v.y);
      line.setAttribute('stroke', isTwisted ? '#e74c3c' : '#2c3e50');
      line.setAttribute('stroke-width', isTwisted ? 3 : 2);
      line.setAttribute('data-edge-id', e.id);
      line.style.cursor = 'pointer';
      
      line.addEventListener('click', () => {
        if (this.onEdgeClick) {
          this.onEdgeClick(e.id);
        }
      });
      
      this.svg.appendChild(line);
    }
  }
  
  drawVertices() {
    for (const v of this.graph.vertices) {
      const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      circle.setAttribute('cx', v.x);
      circle.setAttribute('cy', v.y);
      circle.setAttribute('r', 8);
      circle.setAttribute('fill', '#3498db');
      circle.setAttribute('stroke', '#2c3e50');
      circle.setAttribute('stroke-width', 2);
      circle.setAttribute('data-vertex-id', v.id);
      circle.style.cursor = 'pointer';
      
      circle.addEventListener('click', (e) => {
        e.stopPropagation();
        if (this.onVertexClick) {
          this.onVertexClick(v.id);
        }
      });
      
      this.svg.appendChild(circle);
      
      if (this.showLabels) {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', v.x);
        text.setAttribute('y', v.y - 12);
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('font-size', 11);
        text.setAttribute('fill', '#2c3e50');
        text.setAttribute('font-weight', 'bold');
        text.textContent = `v${v.id}`;
        
        this.svg.appendChild(text);
      }
    }
  }
}

// ============================================================================
// Main Application Controller
// ============================================================================
class App {
  constructor() {
    this.graph = new Graph();
    this.embedding = new Embedding(this.graph);
    this.renderer = new Renderer(document.getElementById('mainCanvas'));
    this.editMode = false;
    
    this.initUI();
    this.loadExampleGraph('cube');
  }
  
  initUI() {
    // Example graphs
    document.getElementById('loadExample').addEventListener('click', () => {
      const selected = document.getElementById('exampleGraphs').value;
      if (selected) {
        this.loadExampleGraph(selected);
      }
    });
    
    // Edit mode
    document.getElementById('editMode').addEventListener('change', (e) => {
      this.editMode = e.target.checked;
    });
    
    // Clear graph
    document.getElementById('clearGraph').addEventListener('click', () => {
      this.graph = new Graph();
      this.embedding = new Embedding(this.graph);
      this.updateView();
    });
    
    // Export/Import
    document.getElementById('exportGraph').addEventListener('click', () => {
      document.getElementById('graphData').value = JSON.stringify(this.graph.toJSON(), null, 2);
    });
    
    document.getElementById('importGraph').addEventListener('click', () => {
      try {
        const data = JSON.parse(document.getElementById('graphData').value);
        this.graph.fromJSON(data);
        this.embedding = new Embedding(this.graph);
        this.embedding.computePlanarRotation();
        this.updateView();
      } catch (e) {
        alert('Invalid JSON: ' + e.message);
      }
    });
    
    // Surface tabs
    document.querySelectorAll('.surface-tab').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.surface-tab').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const surface = btn.dataset.surface;
        this.embedding.surface = surface;
        this.renderer.setSurface(surface);
        this.updateView();
      });
    });
    
    // Theory tabs
    document.querySelectorAll('.tab').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        const tab = btn.dataset.tab;
        document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
        document.getElementById(tab + '-content').classList.add('active');
      });
    });
    
    // Visualization options
    document.getElementById('showFaces').addEventListener('change', (e) => {
      this.renderer.showFaces = e.target.checked;
      this.updateView();
    });
    
    document.getElementById('showDual').addEventListener('change', (e) => {
      this.renderer.showDual = e.target.checked;
      this.updateView();
    });
    
    document.getElementById('showLabels').addEventListener('change', (e) => {
      this.renderer.showLabels = e.target.checked;
      this.updateView();
    });
    
    // Enami module
    document.getElementById('computeDual').addEventListener('click', () => {
      this.computeDualInfo();
    });
    
    document.getElementById('enumerateEmbeddings').addEventListener('click', () => {
      this.enumerateReEmbeddings();
    });
    
    // Weiß-Niemeyer module
    document.getElementById('checkStrong').addEventListener('click', () => {
      this.checkStrongEmbedding();
    });
    
    // Juvan-Mohar module
    document.getElementById('tryTorusEmbed').addEventListener('click', () => {
      this.tryTorusEmbedding();
    });
    
    // Hubard module
    document.getElementById('checkShortestPath').addEventListener('click', () => {
      this.checkShortestPath();
    });
    
    document.getElementById('loadMinimalTorus').addEventListener('click', () => {
      this.loadExampleGraph('torus-minimal');
    });
    
    document.getElementById('loadMinimalKlein').addEventListener('click', () => {
      this.loadExampleGraph('klein-minimal');
    });
    
    // Renderer callbacks
    this.renderer.onEdgeClick = (edgeId) => {
      this.embedding.toggleTwistedEdge(edgeId);
      this.updateView();
    };
    
    this.renderer.onVertexClick = (vertexId) => {
      if (this.editMode) {
        // Handle edge creation with Shift+click
        // For simplicity, just highlight for now
      }
    };
  }
  
  loadExampleGraph(name) {
    switch(name) {
      case 'cube':
        this.graph = ExampleGraphs.createCube();
        break;
      case 'octahedron':
        this.graph = ExampleGraphs.createOctahedron();
        break;
      case 'prism':
        this.graph = ExampleGraphs.createTriangularPrism();
        break;
      case 'k4':
        this.graph = ExampleGraphs.createK4();
        break;
      case 'tetrahedron':
        this.graph = ExampleGraphs.createTruncatedTetrahedron();
        break;
      case 'torus-minimal':
        this.graph = ExampleGraphs.createTorusMinimal();
        break;
      case 'klein-minimal':
        this.graph = ExampleGraphs.createKleinMinimal();
        break;
    }
    
    this.embedding = new Embedding(this.graph);
    this.embedding.computePlanarRotation();
    this.updateView();
  }
  
  updateView() {
    // Update stats
    document.getElementById('vertexCount').textContent = this.graph.vertices.length;
    document.getElementById('edgeCount').textContent = this.graph.edges.length;
    
    // Update properties
    const props = [];
    if (this.graph.isConnected()) props.push('Connected');
    if (this.graph.is3Regular()) props.push('3-Regular');
    if (this.graph.vertices.length >= 4 && this.graph.is3Connected()) props.push('3-Connected');
    
    document.getElementById('graphProperties').innerHTML = props.length > 0 
      ? '<br>' + props.join(', ') 
      : '<br><span style="color:#e74c3c;">Check failed</span>';
    
    // Update embedding info
    document.getElementById('currentSurface').textContent = this.embedding.surface;
    document.getElementById('twistedCount').textContent = this.embedding.twistedEdges.size;
    document.getElementById('rotationInfo').textContent = this.embedding.getRotationString();
    
    // Render
    this.renderer.setGraph(this.graph, this.embedding);
    this.renderer.render();
  }
  
  computeDualInfo() {
    if (!this.graph.is3Regular() || !this.graph.is3Connected()) {
      document.getElementById('dualInfo').innerHTML = 
        '<div class="error">Graph must be 3-connected and 3-regular</div>';
      return;
    }
    
    const dual = new DualGraph(this.embedding);
    dual.compute();
    
    const ht = dual.getTwistedSubgraph();
    const pattern = dual.recognizePattern(ht);
    const surfaceInfo = dual.determineSurface(pattern);
    
    let html = `<strong>Dual Graph:</strong><br>`;
    html += `Vertices (faces): ${dual.dualVertices.length}<br>`;
    html += `Edges: ${dual.dualEdges.length}<br><br>`;
    
    html += `<strong>H<sub>T</sub> (Twisted Subgraph):</strong><br>`;
    html += `Pattern: <code>${pattern}</code><br>`;
    html += `Vertices: ${ht.vertices.length}<br>`;
    html += `Edges: ${ht.edges.length}<br>`;
    html += `Predicted surface: <strong>${surfaceInfo.surface}</strong><br>`;
    html += `Reference: ${surfaceInfo.theorem}`;
    
    document.getElementById('dualInfo').innerHTML = html;
    document.getElementById('htInfo').innerHTML = html;
  }
  
  enumerateReEmbeddings() {
    if (this.graph.edges.length > 15) {
      document.getElementById('embeddingsList').innerHTML = 
        '<div class="error">Graph too large for enumeration (max 15 edges)</div>';
      return;
    }
    
    const dual = new DualGraph(this.embedding);
    dual.compute();
    
    const results = [];
    const numEdges = this.graph.edges.length;
    
    // Try all subsets of edges (simplified - only small subsets)
    for (let mask = 0; mask < Math.min(1 << numEdges, 256); mask++) {
      const twistedSet = new Set();
      for (let i = 0; i < numEdges; i++) {
        if (mask & (1 << i)) {
          twistedSet.add(this.graph.edges[i].id);
        }
      }
      
      // Temporarily set twisted edges
      const oldTwisted = this.embedding.twistedEdges;
      this.embedding.twistedEdges = twistedSet;
      
      const dual2 = new DualGraph(this.embedding);
      dual2.compute();
      const ht = dual2.getTwistedSubgraph();
      const pattern = dual2.recognizePattern(ht);
      const surfaceInfo = dual2.determineSurface(pattern);
      
      if (surfaceInfo.surface !== 'unknown') {
        results.push({
          twistedSet: new Set(twistedSet),
          pattern,
          surface: surfaceInfo.surface,
          theorem: surfaceInfo.theorem
        });
      }
      
      this.embedding.twistedEdges = oldTwisted;
    }
    
    // Display results
    let html = '';
    for (const r of results.slice(0, 20)) { // Limit to 20
      const edgeList = Array.from(r.twistedSet).join(', ') || 'none';
      html += `<div class="edge-item" data-twisted="${edgeList}">`;
      html += `T = {${edgeList}}<br>`;
      html += `${r.pattern} → ${r.surface}<br>`;
      html += `<small>${r.theorem}</small>`;
      html += `</div>`;
    }
    
    if (results.length > 20) {
      html += `<div class="info-box">... and ${results.length - 20} more</div>`;
    }
    
    document.getElementById('embeddingsList').innerHTML = html;
    
    // Add click handlers
    document.querySelectorAll('#embeddingsList .edge-item').forEach(item => {
      item.addEventListener('click', () => {
        const twisted = item.dataset.twisted;
        this.embedding.twistedEdges.clear();
        if (twisted !== 'none') {
          twisted.split(', ').forEach(id => {
            this.embedding.twistedEdges.add(parseInt(id));
          });
        }
        this.updateView();
      });
    });
  }
  
  checkStrongEmbedding() {
    const dual = new DualGraph(this.embedding);
    dual.compute();
    const ht = dual.getTwistedSubgraph();
    const pattern = dual.recognizePattern(ht);
    const surfaceInfo = dual.determineSurface(pattern);
    
    const checker = new StrongEmbeddingChecker(this.embedding, dual);
    const criteria = checker.checkStrongByCriteria(pattern, surfaceInfo.surface);
    
    // Also check actual face structure
    const actualStrong = checker.isStrong();
    
    let html = '';
    html += `<div class="result-strong ${criteria.isStrong ? 'yes' : 'no'}">`;
    html += criteria.isStrong ? 'STRONG EMBEDDING' : 'NOT STRONG';
    html += `</div>`;
    
    document.getElementById('strongResult').innerHTML = html;
    
    let explanation = `<strong>H<sub>T</sub> Pattern:</strong> ${pattern}<br>`;
    explanation += `<strong>Surface:</strong> ${surfaceInfo.surface}<br>`;
    explanation += `<strong>Theoretical Prediction:</strong> ${criteria.isStrong ? 'Strong' : 'Not strong'}<br>`;
    explanation += `<strong>Reason:</strong> ${criteria.reason}<br>`;
    explanation += `<strong>Reference:</strong> ${criteria.lemma}<br><br>`;
    explanation += `<strong>Actual Face Check:</strong> ${actualStrong ? 'All faces are cycles' : 'Some faces not cycles'}`;
    
    document.getElementById('strongExplanation').innerHTML = explanation;
  }
  
  tryTorusEmbedding() {
    // Juvan-Mohar (1997) - simplified educational version
    // Check basic necessary conditions for torus embedding
    
    let html = '<strong>Torus Embedding Analysis</strong><br><br>';
    
    const n = this.graph.vertices.length;
    const m = this.graph.edges.length;
    
    html += `Vertices: ${n}, Edges: ${m}<br>`;
    html += `Euler characteristic: χ = ${n - m + this.embedding.computeFaces().length}<br><br>`;
    
    // For torus: χ = 0, so n - m + f = 0
    // For triangulation: 3f = 2m, so f = 2m/3
    // Thus: n - m + 2m/3 = 0 → n = m/3
    
    if (!this.graph.isConnected()) {
      html += '<div class="error">Graph is not connected</div>';
    } else if (m > 3 * n) {
      html += '<div class="error">Too many edges for torus (m > 3n)</div>';
    } else {
      html += '<div class="success">Basic conditions satisfied</div>';
      html += '<br>A complete implementation would:<br>';
      html += '<ul>';
      html += '<li>Decompose into 3-connected components</li>';
      html += '<li>Check projective planarity</li>';
      html += '<li>Compute face-width</li>';
      html += '<li>Construct rotation system</li>';
      html += '</ul>';
      html += '<br><small>Reference: Juvan & Mohar (1997) Section 3-4</small>';
    }
    
    document.getElementById('torusResult').innerHTML = html;
  }
  
  checkShortestPath() {
    // Hubard et al. (2016) - simplified shortest path check
    // Check if current embedding could be a shortest path embedding
    
    let html = '<strong>Shortest Path Embedding Check</strong><br><br>';
    
    html += `Current surface: ${this.embedding.surface}<br>`;
    html += `Vertices: ${this.graph.vertices.length}, Edges: ${this.graph.edges.length}<br><br>`;
    
    if (this.embedding.surface === 'klein') {
      html += '<div class="warning">';
      html += '<strong>Theorem 2 (Hubard et al.):</strong><br>';
      html += 'On Klein bottle with unit square flat metric, ';
      html += 'there is NO universal shortest path metric.<br>';
      html += 'Example: Kc1 minimal triangulation';
      html += '</div>';
    } else if (this.embedding.surface === 'torus') {
      html += '<div class="success">';
      html += 'Torus with flat metric supports shortest path embeddings.<br>';
      html += 'Minimal triangulation with 7 vertices can be embedded as shortest paths.';
      html += '</div>';
    } else if (this.embedding.surface === 'sphere') {
      html += '<div class="success">';
      html += 'Sphere: convex polyhedra are shortest path embeddings.';
      html += '</div>';
    } else {
      html += '<div class="info-box">';
      html += 'Projective plane analysis requires specific metric choice.';
      html += '</div>';
    }
    
    html += '<br><small>Reference: Hubard et al. (2016) Theorems 1-4</small>';
    
    document.getElementById('shortestPathResult').innerHTML = html;
  }
}

// ============================================================================
// Initialize Application
// ============================================================================
document.addEventListener('DOMContentLoaded', () => {
  window.app = new App();
});

</script>

</body>
</html>
