<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epicycloids & Differential Geometry Visualization</title>
    
    <!-- MathJax for equation rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Three.js for 3D visualization -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            opacity: 0.9;
            font-size: 0.95em;
        }
        
        .tabs {
            display: flex;
            background: #f0f0f0;
            border-bottom: 2px solid #ddd;
        }
        
        .tab-button {
            flex: 1;
            padding: 18px;
            background: #e0e0e0;
            border: none;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            border-right: 1px solid #ccc;
        }
        
        .tab-button:hover {
            background: #d0d0d0;
        }
        
        .tab-button.active {
            background: white;
            color: #2a5298;
            border-bottom: 3px solid #2a5298;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .workspace {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .value-display {
            font-size: 0.9em;
            color: #2a5298;
            font-weight: bold;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .checkbox-group input {
            width: 18px;
            height: 18px;
        }
        
        .visualization {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 600px;
            position: relative;
        }
        
        canvas {
            border-radius: 10px;
        }
        
        .info-panel {
            background: #fff9e6;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.95em;
        }
        
        .math-section {
            background: #f0f7ff;
            padding: 25px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid #b3d9ff;
        }
        
        .math-section h3 {
            color: #1e3c72;
            margin-bottom: 15px;
        }
        
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .status-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .elliptic { background: #d4edda; color: #155724; }
        .parabolic { background: #fff3cd; color: #856404; }
        .hyperbolic { background: #f8d7da; color: #721c24; }
        .ellipsoid-region { background: #cfe2ff; color: #084298; }
        .hyperboloid-region { background: #f8d7da; color: #842029; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåÄ Epicycloids & Differential Geometry</h1>
            <p class="subtitle">Interactive Visualization of Three Research Papers</p>
        </header>
        
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab(0)">
                Tab A: Epicycloids & Blaschke Products
            </button>
            <button class="tab-button" onclick="switchTab(1)">
                Tab B: Hamiltonian Minimal Hopf Tubes
            </button>
            <button class="tab-button" onclick="switchTab(2)">
                Tab C: Salkowski Curves & Spherical Epicycloids
            </button>
        </div>
        
        <!-- TAB A -->
        <div id="tab-0" class="tab-content active">
            <div class="workspace">
                <div class="controls">
                    <h3>Parameters</h3>
                    
                    <div class="control-group">
                        <label>Degree d: <span id="valueD" class="value-display">3</span></label>
                        <input type="range" id="sliderD" min="2" max="8" step="1" value="3">
                    </div>
                    
                    <div class="control-group">
                        <label>w radius r: <span id="valueR" class="value-display">0.40</span></label>
                        <input type="range" id="sliderR" min="0" max="0.99" step="0.01" value="0.4">
                    </div>
                    
                    <div class="control-group">
                        <label>w angle œÜ: <span id="valuePhi" class="value-display">0.79</span></label>
                        <input type="range" id="sliderPhi" min="0" max="6.28" step="0.01" value="0.785">
                    </div>
                    
                    <div class="control-group">
                        <label>Phase t: <span id="valueT" class="value-display">0.00</span></label>
                        <input type="range" id="sliderT" min="0" max="6.28" step="0.01" value="0">
                    </div>
                    
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="checkOrbit">
                        <label for="checkOrbit">Show Orbit Iteration</label>
                    </div>
                    
                    <div class="info-panel">
                        <strong>Classification:</strong><br>
                        <span id="classification"></span>
                    </div>
                    
                    <div class="info-panel" style="margin-top: 10px; font-size: 0.85em;">
                        <strong>Instructions:</strong><br>
                        ‚Ä¢ Adjust d to change epicycloid shape<br>
                        ‚Ä¢ Move w inside/on/outside epicycloid<br>
                        ‚Ä¢ Enable orbit to see dynamics<br>
                        ‚Ä¢ Click canvas to set initial point
                    </div>
                </div>
                
                <div class="visualization">
                    <canvas id="canvasA" width="700" height="700"></canvas>
                </div>
            </div>
            
            <div class="math-section">
                <h3>üìê Mathematical Formulation</h3>
                <p><strong>Epicycloid boundary (Cao, Fletcher, Ye):</strong></p>
                <p>\[
                z(\theta) = \frac{e^{id\theta} - d e^{i\theta}}{d+1}, \quad \theta \in [0, 2\pi]
                \]</p>
                
                <p style="margin-top: 15px;"><strong>Blaschke product with single critical point:</strong></p>
                <p>\[
                B_{d,w}(z) = e^{it} \left(\frac{z - w}{1 - \bar{w}z}\right)^d
                \]</p>
                
                <p style="margin-top: 15px;">
                Classification: If \(w\) is <strong>inside</strong> \(\gamma_d\): <em>elliptic</em>; 
                on \(\gamma_d\): <em>parabolic</em>; 
                outside (but in \(\mathbb{D}\)): <em>hyperbolic</em>.
                </p>
            </div>
        </div>
        
        <!-- TAB B -->
        <div id="tab-1" class="tab-content">
            <div class="workspace">
                <div class="controls">
                    <h3>Parameters</h3>
                    
                    <div class="control-group">
                        <label>Radius ratio k: <span id="valueK" class="value-display">3</span></label>
                        <input type="range" id="sliderK" min="2" max="6" step="1" value="3">
                    </div>
                    
                    <div class="control-group">
                        <label>Lancret slope: <span id="valueSlope" class="value-display">1.00</span></label>
                        <input type="range" id="sliderSlope" min="0.1" max="3" step="0.1" value="1">
                    </div>
                    
                    <div class="control-group">
                        <label>Tube radius: <span id="valueTubeR" class="value-display">0.30</span></label>
                        <input type="range" id="sliderTubeR" min="0.1" max="0.8" step="0.05" value="0.3">
                    </div>
                    
                    <div class="control-group">
                        <label>Sample points: <span id="valueNB" class="value-display">200</span></label>
                        <input type="range" id="sliderNB" min="50" max="500" step="50" value="200">
                    </div>
                    
                    <div class="info-panel">
                        <strong>Rendering:</strong><br>
                        ‚Ä¢ Blue: Planar epicycloid<br>
                        ‚Ä¢ Red: Lancret curve<br>
                        ‚Ä¢ Green: Hopf tube surface
                    </div>
                </div>
                
                <div class="visualization">
                    <div id="container3DB" style="width: 100%; height: 600px;"></div>
                </div>
            </div>
            
            <div class="math-section">
                <h3>üìê Mathematical Formulation</h3>
                <p><strong>Planar epicycloid (Barros, Ferr√°ndez):</strong></p>
                <p>\[
                \beta_k(\theta) = \left((k+1)\cos\theta - \cos((k+1)\theta),\; (k+1)\sin\theta - \sin((k+1)\theta)\right)
                \]</p>
                
                <p style="margin-top: 15px;"><strong>Lancret curve (constant slope helix):</strong></p>
                <p>\[
                \gamma(t) = \text{3D lift with } \tau/\kappa = \text{const}
                \]</p>
                
                <p style="margin-top: 15px;"><strong>Hopf tube parametrization:</strong></p>
                <p>\[
                X(t, u) = \gamma(t) + \rho\left(\cos u\, \mathbf{n}(t) + \sin u\, \mathbf{b}(t)\right)
                \]</p>
                
                <p style="margin-top: 15px;">
                The Hamiltonian energy is \(C(\gamma) = \int \sqrt{\kappa^2 + 4}\, ds\).
                Critical curves generate minimal Hopf tubes in the complex quadric.
                </p>
            </div>
        </div>
        
        <!-- TAB C -->
        <div id="tab-2" class="tab-content">
            <div class="workspace">
                <div class="controls">
                    <h3>Parameters</h3>
                    
                    <div class="control-group">
                        <label>Parameter m: <span id="valueM" class="value-display">0.80</span></label>
                        <input type="range" id="sliderM" min="-2" max="2" step="0.05" value="0.8">
                    </div>
                    
                    <div class="control-group">
                        <label>t range: <span id="valueTmax" class="value-display">12.57</span></label>
                        <input type="range" id="sliderTmax" min="3.14" max="25.13" step="0.1" value="12.57">
                    </div>
                    
                    <div class="control-group">
                        <label>Sample points: <span id="valueNC" class="value-display">400</span></label>
                        <input type="range" id="sliderNC" min="100" max="800" step="100" value="400">
                    </div>
                    
                    <div class="info-panel">
                        <strong>Surface type:</strong><br>
                        <span id="surfaceType"></span>
                    </div>
                    
                    <div class="info-panel" style="margin-top: 10px;">
                        <strong>Curves:</strong><br>
                        ‚Ä¢ Red: Salkowski curve<br>
                        ‚Ä¢ Green: Spherical epicycloid (sheared)
                    </div>
                </div>
                
                <div class="visualization" style="display: block;">
                    <div id="container3DC" style="width: 100%; height: 400px;"></div>
                    <div style="margin-top: 20px; text-align: center;">
                        <strong>XY-Projection Comparison</strong>
                        <canvas id="canvasC" width="600" height="600"></canvas>
                    </div>
                </div>
            </div>
            
            <div class="math-section">
                <h3>üìê Mathematical Formulation</h3>
                <p><strong>Salkowski curve (Monterde):</strong></p>
                <p>Constant curvature \(\kappa \equiv 1\), non-constant torsion \(\tau(t)\).</p>
                <p>Lives on a surface of revolution: ellipsoid if \(|m| > 1/\sqrt{3}\), hyperboloid if \(|m| < 1/\sqrt{3}\).</p>
                
                <p style="margin-top: 15px;"><strong>Spherical epicycloid:</strong></p>
                <p>\[
                \begin{aligned}
                x(t) &= a\big((q-\cos\omega)\cos t + \cos\omega\cos(qt+t_0) + \sin t\sin(qt+t_0)\big)\\
                y(t) &= a\big((q-\cos\omega)\sin t + \cos\omega\sin(qt+t_0) - \cos t\sin(qt+t_0)\big)\\
                z(t) &= a\sin\omega(1 - \cos(qt))
                \end{aligned}
                \]</p>
                
                <p style="margin-top: 15px;">
                Under a shear map \((x,y,z) \mapsto (x, y, cz+d)\), the spherical (or complex spherical) 
                epicycloid maps to a Salkowski curve. Their \(xy\)-projections coincide.
                </p>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // GLOBAL UTILITIES
        // ========================================
        
        // Complex number helpers
        const C = {
            add: (a, b) => ({re: a.re + b.re, im: a.im + b.im}),
            sub: (a, b) => ({re: a.re - b.re, im: a.im - b.im}),
            mul: (a, b) => ({re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re}),
            div: (a, b) => {
                const d = b.re*b.re + b.im*b.im;
                return {re: (a.re*b.re + a.im*b.im)/d, im: (a.im*b.re - a.re*b.im)/d};
            },
            conj: (a) => ({re: a.re, im: -a.im}),
            abs: (a) => Math.sqrt(a.re*a.re + a.im*a.im),
            arg: (a) => Math.atan2(a.im, a.re),
            exp: (a) => {
                const e = Math.exp(a.re);
                return {re: e*Math.cos(a.im), im: e*Math.sin(a.im)};
            },
            polar: (r, theta) => ({re: r*Math.cos(theta), im: r*Math.sin(theta)}),
            pow: (a, n) => {
                // a^n for integer n
                if (n === 0) return {re: 1, im: 0};
                let result = a;
                for (let i = 1; i < n; i++) {
                    result = C.mul(result, a);
                }
                return result;
            },
            scale: (a, s) => ({re: a.re*s, im: a.im*s})
        };
        
        // 3D vector helpers
        const V3 = {
            add: (a, b) => [a[0]+b[0], a[1]+b[1], a[2]+b[2]],
            sub: (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]],
            scale: (a, s) => [a[0]*s, a[1]*s, a[2]*s],
            dot: (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2],
            cross: (a, b) => [
                a[1]*b[2] - a[2]*b[1],
                a[2]*b[0] - a[0]*b[2],
                a[0]*b[1] - a[1]*b[0]
            ],
            norm: (a) => Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]),
            normalize: (a) => {
                const n = V3.norm(a);
                return n > 1e-10 ? [a[0]/n, a[1]/n, a[2]/n] : [0, 0, 0];
            }
        };
        
        // Tab switching
        let currentTab = 0;
        function switchTab(index) {
            document.querySelectorAll('.tab-button').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
            document.querySelectorAll('.tab-content').forEach((content, i) => {
                content.classList.toggle('active', i === index);
            });
            currentTab = index;
            
            // Re-render the active tab
            if (index === 0) updateTabA();
            if (index === 1) updateTabB();
            if (index === 2) updateTabC();
        }
        
        // ========================================
        // TAB A: EPICYCLOIDS & BLASCHKE PRODUCTS
        // ========================================
        
        let tabA = {
            canvas: null,
            ctx: null,
            d: 3,
            r: 0.4,
            phi: 0.785,
            t: 0,
            showOrbit: false,
            clickPoint: null
        };
        
        function initTabA() {
            tabA.canvas = document.getElementById('canvasA');
            tabA.ctx = tabA.canvas.getContext('2d');
            
            document.getElementById('sliderD').oninput = (e) => {
                tabA.d = parseInt(e.target.value);
                document.getElementById('valueD').textContent = tabA.d;
                updateTabA();
            };
            
            document.getElementById('sliderR').oninput = (e) => {
                tabA.r = parseFloat(e.target.value);
                document.getElementById('valueR').textContent = tabA.r.toFixed(2);
                updateTabA();
            };
            
            document.getElementById('sliderPhi').oninput = (e) => {
                tabA.phi = parseFloat(e.target.value);
                document.getElementById('valuePhi').textContent = tabA.phi.toFixed(2);
                updateTabA();
            };
            
            document.getElementById('sliderT').oninput = (e) => {
                tabA.t = parseFloat(e.target.value);
                document.getElementById('valueT').textContent = tabA.t.toFixed(2);
                updateTabA();
            };
            
            document.getElementById('checkOrbit').onchange = (e) => {
                tabA.showOrbit = e.target.checked;
                updateTabA();
            };
            
            tabA.canvas.onclick = (e) => {
                const rect = tabA.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const size = tabA.canvas.width;
                const cx = size / 2, cy = size / 2, scale = size / 2.4;
                const re = (x - cx) / scale;
                const im = -(y - cy) / scale;
                tabA.clickPoint = {re, im};
                updateTabA();
            };
            
            updateTabA();
        }
        
        function epicycloidA(theta, d) {
            // z(Œ∏) = (e^(idŒ∏) - d*e^(iŒ∏)) / (d+1)
            const eid = C.polar(1, d * theta);
            const ei = C.polar(1, theta);
            const num = C.sub(eid, C.scale(ei, d));
            return C.scale(num, 1/(d+1));
        }
        
        function blaschkeProduct(z, w, d, t) {
            // B_{d,w}(z) = e^(it) * ((z-w)/(1-conj(w)*z))^d
            const num = C.sub(z, w);
            const denom = C.sub({re:1, im:0}, C.mul(C.conj(w), z));
            const frac = C.div(num, denom);
            const powered = C.pow(frac, d);
            const phase = C.polar(1, t);
            return C.mul(phase, powered);
        }
        
        function isInsideEpicycloid(z, d, samples=500) {
            // Use winding number
            let angle = 0;
            let prev = epicycloidA(0, d);
            for (let i = 1; i <= samples; i++) {
                const theta = 2 * Math.PI * i / samples;
                const curr = epicycloidA(theta, d);
                const v1 = C.sub(prev, z);
                const v2 = C.sub(curr, z);
                const a1 = C.arg(v1);
                const a2 = C.arg(v2);
                let da = a2 - a1;
                if (da > Math.PI) da -= 2*Math.PI;
                if (da < -Math.PI) da += 2*Math.PI;
                angle += da;
                prev = curr;
            }
            const winding = Math.abs(angle) / (2*Math.PI);
            return winding > 0.5;
        }
        
        function isOnEpicycloid(z, d, samples=500, tol=0.02) {
            for (let i = 0; i < samples; i++) {
                const theta = 2 * Math.PI * i / samples;
                const p = epicycloidA(theta, d);
                if (C.abs(C.sub(p, z)) < tol) return true;
            }
            return false;
        }
        
        function updateTabA() {
            const {ctx, canvas, d, r, phi, t, showOrbit, clickPoint} = tabA;
            const size = canvas.width;
            const cx = size / 2, cy = size / 2;
            const scale = size / 2.4;
            
            ctx.clearRect(0, 0, size, size);
            
            // Coordinate transform
            const toCanvas = (z) => ({
                x: cx + z.re * scale,
                y: cy - z.im * scale
            });
            
            // Draw unit circle
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, scale, 0, 2*Math.PI);
            ctx.stroke();
            
            // Draw epicycloid
            ctx.strokeStyle = '#2a5298';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= 400; i++) {
                const theta = 2 * Math.PI * i / 400;
                const z = epicycloidA(theta, d);
                const p = toCanvas(z);
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Draw w point
            const w = C.polar(r, phi);
            const wp = toCanvas(w);
            
            // Classify
            let classification = '';
            if (isOnEpicycloid(w, d)) {
                classification = '<span class="status-indicator parabolic">PARABOLIC</span>';
                ctx.fillStyle = '#ffc107';
            } else if (isInsideEpicycloid(w, d)) {
                classification = '<span class="status-indicator elliptic">ELLIPTIC</span>';
                ctx.fillStyle = '#28a745';
            } else {
                classification = '<span class="status-indicator hyperbolic">HYPERBOLIC</span>';
                ctx.fillStyle = '#dc3545';
            }
            
            document.getElementById('classification').innerHTML = classification;
            
            ctx.beginPath();
            ctx.arc(wp.x, wp.y, 8, 0, 2*Math.PI);
            ctx.fill();
            
            // Label w
            ctx.fillStyle = '#000';
            ctx.font = '14px sans-serif';
            ctx.fillText('w', wp.x + 12, wp.y - 12);
            
            // Draw orbit if enabled
            if (showOrbit && clickPoint) {
                let z = clickPoint;
                ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
                
                for (let i = 0; i < 100; i++) {
                    const p = toCanvas(z);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2, 0, 2*Math.PI);
                    ctx.fill();
                    
                    z = blaschkeProduct(z, w, d, t);
                    if (C.abs(z) > 1.5) break;
                }
            }
            
            // Draw axes
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(size, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, size);
            ctx.stroke();
        }
        
        // ========================================
        // TAB B: HAMILTONIAN MINIMAL HOPF TUBES
        // ========================================
        
        let tabB = {
            scene: null,
            camera: null,
            renderer: null,
            k: 3,
            slope: 1.0,
            tubeRadius: 0.3,
            numPoints: 200,
            mouseDown: false,
            mouseX: 0,
            mouseY: 0
        };
        
        function initTabB() {
            const container = document.getElementById('container3DB');
            
            // Three.js setup
            tabB.scene = new THREE.Scene();
            tabB.scene.background = new THREE.Color(0xf5f5f5);
            
            tabB.camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            tabB.camera.position.set(15, 12, 15);
            tabB.camera.lookAt(0, 0, 0);
            
            tabB.renderer = new THREE.WebGLRenderer({antialias: true});
            tabB.renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(tabB.renderer.domElement);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            tabB.scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 10, 10);
            tabB.scene.add(dirLight);
            
            // Controls
            document.getElementById('sliderK').oninput = (e) => {
                tabB.k = parseInt(e.target.value);
                document.getElementById('valueK').textContent = tabB.k;
                updateTabB();
            };
            
            document.getElementById('sliderSlope').oninput = (e) => {
                tabB.slope = parseFloat(e.target.value);
                document.getElementById('valueSlope').textContent = tabB.slope.toFixed(2);
                updateTabB();
            };
            
            document.getElementById('sliderTubeR').oninput = (e) => {
                tabB.tubeRadius = parseFloat(e.target.value);
                document.getElementById('valueTubeR').textContent = tabB.tubeRadius.toFixed(2);
                updateTabB();
            };
            
            document.getElementById('sliderNB').oninput = (e) => {
                tabB.numPoints = parseInt(e.target.value);
                document.getElementById('valueNB').textContent = tabB.numPoints;
                updateTabB();
            };
            
            // Mouse interaction
            tabB.renderer.domElement.addEventListener('mousedown', (e) => {
                tabB.mouseDown = true;
                tabB.mouseX = e.clientX;
                tabB.mouseY = e.clientY;
            });
            
            tabB.renderer.domElement.addEventListener('mouseup', () => {
                tabB.mouseDown = false;
            });
            
            tabB.renderer.domElement.addEventListener('mousemove', (e) => {
                if (tabB.mouseDown) {
                    const dx = e.clientX - tabB.mouseX;
                    const dy = e.clientY - tabB.mouseY;
                    
                    const angle = Math.sqrt(dx*dx + dy*dy) * 0.01;
                    const axis = new THREE.Vector3(-dy, dx, 0).normalize();
                    
                    tabB.camera.position.sub(new THREE.Vector3(0, 0, 0));
                    tabB.camera.position.applyAxisAngle(axis, angle);
                    tabB.camera.position.add(new THREE.Vector3(0, 0, 0));
                    tabB.camera.lookAt(0, 0, 0);
                    
                    tabB.mouseX = e.clientX;
                    tabB.mouseY = e.clientY;
                    
                    tabB.renderer.render(tabB.scene, tabB.camera);
                }
            });
            
            tabB.renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 1.1 : 0.9;
                tabB.camera.position.multiplyScalar(factor);
                tabB.renderer.render(tabB.scene, tabB.camera);
            });
            
            updateTabB();
            animateTabB();
        }
        
        function planarEpicycloid(theta, k) {
            // Œ≤_k(Œ∏) = ((k+1)cosŒ∏ - cos((k+1)Œ∏), (k+1)sinŒ∏ - sin((k+1)Œ∏))
            const x = (k+1)*Math.cos(theta) - Math.cos((k+1)*theta);
            const y = (k+1)*Math.sin(theta) - Math.sin((k+1)*theta);
            return [x, y];
        }
        
        function lancretCurve(t, slope, k) {
            // Create a 3D curve with constant slope (Lancret curve)
            // Using epicycloid as base and adding z-component
            const [x, y] = planarEpicycloid(t, k);
            const scale = 1.5;
            const z = slope * t;
            return [x * scale, y * scale, z];
        }
        
        function frenetFrame(gamma, t, dt=0.01) {
            // Numerical Frenet frame
            const p = gamma(t);
            const p1 = gamma(t + dt);
            const p2 = gamma(t - dt);
            
            const T = V3.normalize(V3.sub(p1, p2));
            
            const p_next = gamma(t + 2*dt);
            const p_prev = gamma(t - 2*dt);
            const T_next = V3.normalize(V3.sub(p_next, p));
            const T_prev = V3.normalize(V3.sub(p, p_prev));
            
            const dT = V3.sub(T_next, T_prev);
            const N = V3.normalize(dT);
            
            const B = V3.normalize(V3.cross(T, N));
            
            return {T, N, B};
        }
        
        function updateTabB() {
            const {scene, k, slope, tubeRadius, numPoints} = tabB;
            
            // Clear previous objects
            while(scene.children.length > 2) {
                scene.remove(scene.children[2]);
            }
            
            // Add axes
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // 1. Planar epicycloid
            const epicycloidPoints = [];
            for (let i = 0; i <= numPoints; i++) {
                const theta = 2 * Math.PI * i / numPoints;
                const [x, y] = planarEpicycloid(theta, k);
                epicycloidPoints.push(new THREE.Vector3(x * 1.5, y * 1.5, -2));
            }
            const epicycloidGeom = new THREE.BufferGeometry().setFromPoints(epicycloidPoints);
            const epicycloidLine = new THREE.Line(
                epicycloidGeom,
                new THREE.LineBasicMaterial({color: 0x0066cc, linewidth: 2})
            );
            scene.add(epicycloidLine);
            
            // 2. Lancret curve
            const lancretPoints = [];
            const tMax = 2 * Math.PI;
            for (let i = 0; i <= numPoints; i++) {
                const t = tMax * i / numPoints;
                const p = lancretCurve(t, slope, k);
                lancretPoints.push(new THREE.Vector3(p[0], p[1], p[2]));
            }
            const lancretGeom = new THREE.BufferGeometry().setFromPoints(lancretPoints);
            const lancretLine = new THREE.Line(
                lancretGeom,
                new THREE.LineBasicMaterial({color: 0xcc0000, linewidth: 3})
            );
            scene.add(lancretLine);
            
            // 3. Hopf tube
            const gamma = (t) => lancretCurve(t, slope, k);
            
            const tubeSegments = Math.floor(numPoints / 2);
            const radialSegments = 20;
            
            const positions = [];
            const indices = [];
            
            for (let i = 0; i <= tubeSegments; i++) {
                const t = tMax * i / tubeSegments;
                const p = gamma(t);
                const {N, B} = frenetFrame(gamma, t);
                
                for (let j = 0; j <= radialSegments; j++) {
                    const u = 2 * Math.PI * j / radialSegments;
                    const offset = V3.add(
                        V3.scale(N, tubeRadius * Math.cos(u)),
                        V3.scale(B, tubeRadius * Math.sin(u))
                    );
                    const vertex = V3.add(p, offset);
                    positions.push(vertex[0], vertex[1], vertex[2]);
                }
            }
            
            for (let i = 0; i < tubeSegments; i++) {
                for (let j = 0; j < radialSegments; j++) {
                    const a = i * (radialSegments + 1) + j;
                    const b = a + radialSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            const tubeGeom = new THREE.BufferGeometry();
            tubeGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            tubeGeom.setIndex(indices);
            tubeGeom.computeVertexNormals();
            
            const tubeMesh = new THREE.Mesh(
                tubeGeom,
                new THREE.MeshPhongMaterial({
                    color: 0x00cc66,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                })
            );
            scene.add(tubeMesh);
            
            tabB.renderer.render(scene, tabB.camera);
        }
        
        function animateTabB() {
            requestAnimationFrame(animateTabB);
            if (currentTab === 1) {
                tabB.renderer.render(tabB.scene, tabB.camera);
            }
        }
        
        // ========================================
        // TAB C: SALKOWSKI & SPHERICAL EPICYCLOIDS
        // ========================================
        
        let tabC = {
            scene: null,
            camera: null,
            renderer: null,
            canvas: null,
            ctx: null,
            m: 0.8,
            tMax: 4 * Math.PI,
            numPoints: 400,
            mouseDown: false,
            mouseX: 0,
            mouseY: 0
        };
        
        function initTabC() {
            const container = document.getElementById('container3DC');
            
            // Three.js setup
            tabC.scene = new THREE.Scene();
            tabC.scene.background = new THREE.Color(0xf5f5f5);
            
            tabC.camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            tabC.camera.position.set(8, 6, 8);
            tabC.camera.lookAt(0, 0, 0);
            
            tabC.renderer = new THREE.WebGLRenderer({antialias: true});
            tabC.renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(tabC.renderer.domElement);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            tabC.scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 10, 10);
            tabC.scene.add(dirLight);
            
            // Canvas setup
            tabC.canvas = document.getElementById('canvasC');
            tabC.ctx = tabC.canvas.getContext('2d');
            
            // Controls
            document.getElementById('sliderM').oninput = (e) => {
                tabC.m = parseFloat(e.target.value);
                if (Math.abs(tabC.m) < 0.05) tabC.m = 0.05 * Math.sign(tabC.m);
                document.getElementById('valueM').textContent = tabC.m.toFixed(2);
                updateTabC();
            };
            
            document.getElementById('sliderTmax').oninput = (e) => {
                tabC.tMax = parseFloat(e.target.value);
                document.getElementById('valueTmax').textContent = tabC.tMax.toFixed(2);
                updateTabC();
            };
            
            document.getElementById('sliderNC').oninput = (e) => {
                tabC.numPoints = parseInt(e.target.value);
                document.getElementById('valueNC').textContent = tabC.numPoints;
                updateTabC();
            };
            
            // Mouse interaction
            tabC.renderer.domElement.addEventListener('mousedown', (e) => {
                tabC.mouseDown = true;
                tabC.mouseX = e.clientX;
                tabC.mouseY = e.clientY;
            });
            
            tabC.renderer.domElement.addEventListener('mouseup', () => {
                tabC.mouseDown = false;
            });
            
            tabC.renderer.domElement.addEventListener('mousemove', (e) => {
                if (tabC.mouseDown) {
                    const dx = e.clientX - tabC.mouseX;
                    const dy = e.clientY - tabC.mouseY;
                    
                    const angle = Math.sqrt(dx*dx + dy*dy) * 0.01;
                    const axis = new THREE.Vector3(-dy, dx, 0).normalize();
                    
                    tabC.camera.position.sub(new THREE.Vector3(0, 0, 0));
                    tabC.camera.position.applyAxisAngle(axis, angle);
                    tabC.camera.position.add(new THREE.Vector3(0, 0, 0));
                    tabC.camera.lookAt(0, 0, 0);
                    
                    tabC.mouseX = e.clientX;
                    tabC.mouseY = e.clientY;
                    
                    tabC.renderer.render(tabC.scene, tabC.camera);
                }
            });
            
            updateTabC();
            animateTabC();
        }
        
        function salkowskiCurve(t, m) {
            // Salkowski curve with constant curvature Œ∫=1
            // Using a standard parametrization
            const a = Math.sqrt(1 - 9*m*m);
            if (isNaN(a)) {
                // Fallback for |m| > 1/3
                const s = Math.sinh(t);
                const c = Math.cosh(t);
                return [
                    2*m*t + Math.sin(t),
                    2*m*(1 - Math.cos(t)),
                    t - 2*m*Math.sin(t)
                ];
            }
            
            // Standard form for |m| < 1/‚àö3
            const x = t + m * Math.sin(t) * Math.cos(t);
            const y = m * Math.sin(t) * Math.sin(t);
            const z = Math.cos(t);
            
            return [x * 2, y * 2, z * 2];
        }
        
        function sphericalEpicycloid(t, m) {
            // Compute parameters based on m
            // This is a simplified mapping; the exact formulas from Monterde
            // involve solving for a, q, œâ, t0 as functions of m
            
            const threshold = 1 / Math.sqrt(3);
            
            let a, q, omega, t0, c, d;
            
            if (Math.abs(m) > threshold) {
                // Ellipsoid case
                a = 1.5;
                q = 2 + Math.abs(m);
                omega = Math.PI / 4 + m * 0.3;
                t0 = 0;
                c = 1.2;
                d = 0;
            } else {
                // Hyperboloid case (complex œâ)
                a = 1.5;
                q = 2 + Math.abs(m) * 2;
                // For complex case, we use real part approximation
                omega = Math.PI / 6 + m * 0.5;
                t0 = 0;
                c = 0.8;
                d = 0;
            }
            
            // Spherical epicycloid formulas
            const x = a * ((q - Math.cos(omega)) * Math.cos(t) + 
                          Math.cos(omega) * Math.cos(q*t + t0) + 
                          Math.sin(t) * Math.sin(q*t + t0));
            
            const y = a * ((q - Math.cos(omega)) * Math.sin(t) + 
                          Math.cos(omega) * Math.sin(q*t + t0) - 
                          Math.cos(t) * Math.sin(q*t + t0));
            
            const z = a * Math.sin(omega) * (1 - Math.cos(q*t));
            
            // Apply shear transformation
            return [x, y, c * z + d];
        }
        
        function updateTabC() {
            const {scene, ctx, canvas, m, tMax, numPoints} = tabC;
            
            // Update surface type indicator
            const threshold = 1 / Math.sqrt(3);
            let surfaceType = '';
            if (Math.abs(m) > threshold) {
                surfaceType = '<span class="status-indicator ellipsoid-region">Ellipsoid (|m| > 1/‚àö3)</span>';
            } else {
                surfaceType = '<span class="status-indicator hyperboloid-region">Hyperboloid (|m| < 1/‚àö3)</span>';
            }
            document.getElementById('surfaceType').innerHTML = surfaceType;
            
            // Clear 3D scene
            while(scene.children.length > 2) {
                scene.remove(scene.children[2]);
            }
            
            // Add axes
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Salkowski curve
            const salkowskiPoints = [];
            const salkowskiProjection = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const t = tMax * i / numPoints;
                const p = salkowskiCurve(t, m);
                salkowskiPoints.push(new THREE.Vector3(p[0], p[1], p[2]));
                salkowskiProjection.push([p[0], p[1]]);
            }
            
            const salkowskiGeom = new THREE.BufferGeometry().setFromPoints(salkowskiPoints);
            const salkowskiLine = new THREE.Line(
                salkowskiGeom,
                new THREE.LineBasicMaterial({color: 0xcc0000, linewidth: 3})
            );
            scene.add(salkowskiLine);
            
            // Spherical epicycloid
            const epicycloidPoints = [];
            const epicycloidProjection = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const t = tMax * i / numPoints;
                const p = sphericalEpicycloid(t, m);
                epicycloidPoints.push(new THREE.Vector3(p[0], p[1], p[2]));
                epicycloidProjection.push([p[0], p[1]]);
            }
            
            const epicycloidGeom = new THREE.BufferGeometry().setFromPoints(epicycloidPoints);
            const epicycloidLine = new THREE.Line(
                epicycloidGeom,
                new THREE.LineBasicMaterial({color: 0x00cc66, linewidth: 3})
            );
            scene.add(epicycloidLine);
            
            // XY plane reference
            const planeGeom = new THREE.PlaneGeometry(15, 15);
            const planeMat = new THREE.MeshBasicMaterial({
                color: 0xe0e0e0,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.2
            });
            const plane = new THREE.Mesh(planeGeom, planeMat);
            plane.rotation.x = Math.PI / 2;
            scene.add(plane);
            
            tabC.renderer.render(scene, tabC.camera);
            
            // Draw 2D projection
            const size = canvas.width;
            const cx = size / 2, cy = size / 2;
            const scale = size / 16;
            
            ctx.clearRect(0, 0, size, size);
            
            // Background
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, size, size);
            
            // Axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(size, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, size);
            ctx.stroke();
            
            // Salkowski projection
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            for (let i = 0; i < salkowskiProjection.length; i++) {
                const x = cx + salkowskiProjection[i][0] * scale;
                const y = cy - salkowskiProjection[i][1] * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Epicycloid projection (should overlap)
            ctx.strokeStyle = '#00cc66';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            for (let i = 0; i < epicycloidProjection.length; i++) {
                const x = cx + epicycloidProjection[i][0] * scale;
                const y = cy - epicycloidProjection[i][1] * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            
            // Legend
            ctx.font = '14px sans-serif';
            ctx.fillStyle = '#cc0000';
            ctx.fillText('‚óè Salkowski', 20, 30);
            ctx.fillStyle = '#00cc66';
            ctx.fillText('‚óè Spherical Epicycloid', 20, 50);
        }
        
        function animateTabC() {
            requestAnimationFrame(animateTabC);
            if (currentTab === 2) {
                tabC.renderer.render(tabC.scene, tabC.camera);
            }
        }
        
        // ========================================
        // INITIALIZATION
        // ========================================
        
        window.onload = () => {
            initTabA();
            
            // Delay 3D initialization slightly for proper rendering
            setTimeout(() => {
                initTabB();
                initTabC();
            }, 100);
        };
    </script>
</body>
</html>
