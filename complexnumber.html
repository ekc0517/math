<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ & ë¯¸ë¶„ê¸°í•˜ ì‹œê°í™”</title>
    
    <!-- MathJax for equation rendering -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <!-- Three.js for 3D visualization -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            opacity: 0.9;
            font-size: 0.95em;
        }
        
        .tabs {
            display: flex;
            background: #f0f0f0;
            border-bottom: 2px solid #ddd;
        }
        
        .tab-button {
            flex: 1;
            padding: 18px;
            background: #e0e0e0;
            border: none;
            cursor: pointer;
            font-size: 0.95em;
            font-weight: 600;
            transition: all 0.3s;
            border-right: 1px solid #ccc;
        }
        
        .tab-button:hover {
            background: #d0d0d0;
        }
        
        .tab-button.active {
            background: white;
            color: #2a5298;
            border-bottom: 3px solid #2a5298;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .workspace {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .controls {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .value-display {
            font-size: 0.9em;
            color: #2a5298;
            font-weight: bold;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .checkbox-group input {
            width: 18px;
            height: 18px;
        }
        
        .visualization {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 600px;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            border-radius: 10px;
        }
        
        .info-panel {
            background: #fff9e6;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin-top: 10px;
            border-radius: 5px;
            font-size: 0.95em;
        }
        
        .math-section {
            background: #f0f7ff;
            padding: 25px;
            border-radius: 10px;
            margin-top: 20px;
            border: 1px solid #b3d9ff;
        }
        
        .math-section h3 {
            color: #1e3c72;
            margin-bottom: 15px;
        }
        
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .status-indicator {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .elliptic { background: #d4edda; color: #155724; }
        .parabolic { background: #fff3cd; color: #856404; }
        .hyperbolic { background: #f8d7da; color: #721c24; }
        .ellipsoid-region { background: #cfe2ff; color: #084298; }
        .hyperboloid-region { background: #f8d7da; color: #842029; }
        
        /* Tab C specific styles */
        .workspace-c {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }
        
        .top-section {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 30px;
        }
        
        .viz-3d {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            height: 500px;
            position: relative;
            overflow: hidden;
        }
        
        .viz-2d {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .viz-2d h4 {
            margin-bottom: 15px;
            color: #1e3c72;
        }
        
        /* Tab D specific styles */
        .dual-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .view-panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .view-panel h4 {
            margin-bottom: 15px;
            color: #1e3c72;
            font-size: 1.1em;
        }
        
        .play-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
        }
        
        .play-button {
            background: #2a5298;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .play-button:hover {
            background: #1e3c72;
        }
        
        .play-button.playing {
            background: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸŒ€ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ & ë¯¸ë¶„ê¸°í•˜</h1>
            <p class="subtitle">ì„¸ í¸ì˜ ì—°êµ¬ ë…¼ë¬¸ì— ëŒ€í•œ ì¸í„°ë™í‹°ë¸Œ ì‹œê°í™”</p>
        </header>
        
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab(0)">
                íƒ­ A: ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ & ë¸”ë¼ìŠˆì¼€ ê³±
            </button>
            <button class="tab-button" onclick="switchTab(1)">
                íƒ­ B: í•´ë°€í„´ ê·¹ì†Œ í˜¸í”„ íŠœë¸Œ
            </button>
            <button class="tab-button" onclick="switchTab(2)">
                íƒ­ C: ì‚´ì½”í”„ìŠ¤í‚¤ ê³¡ì„  & êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ
            </button>
            <button class="tab-button" onclick="switchTab(3)">
                íƒ­ D: í‰ë©´â†’êµ¬ë©´ ë§¤ê°œí™” í™•ì¥
            </button>
        </div>
        
        <!-- TAB A -->
        <div id="tab-0" class="tab-content active">
            <div class="workspace">
                <div class="controls">
                    <h3>ë§¤ê°œë³€ìˆ˜</h3>
                    
                    <div class="control-group">
                        <label>ì°¨ìˆ˜ d: <span id="valueD" class="value-display">3</span></label>
                        <input type="range" id="sliderD" min="2" max="8" step="1" value="3">
                    </div>
                    
                    <div class="control-group">
                        <label>w ë°˜ì§€ë¦„ r: <span id="valueR" class="value-display">0.40</span></label>
                        <input type="range" id="sliderR" min="0" max="0.99" step="0.01" value="0.4">
                    </div>
                    
                    <div class="control-group">
                        <label>w ê°ë„ Ï†: <span id="valuePhi" class="value-display">0.79</span></label>
                        <input type="range" id="sliderPhi" min="0" max="6.28" step="0.01" value="0.785">
                    </div>
                    
                    <div class="control-group">
                        <label>ìœ„ìƒ t: <span id="valueT" class="value-display">0.00</span></label>
                        <input type="range" id="sliderT" min="0" max="6.28" step="0.01" value="0">
                    </div>
                    
                    <div class="control-group checkbox-group">
                        <input type="checkbox" id="checkOrbit">
                        <label for="checkOrbit">ê¶¤ë„ ë°˜ë³µ í‘œì‹œ</label>
                    </div>
                    
                    <div class="info-panel">
                        <strong>ë¶„ë¥˜:</strong><br>
                        <span id="classification"></span>
                    </div>
                    
                    <div class="info-panel" style="margin-top: 10px; font-size: 0.85em;">
                        <strong>ì‚¬ìš©ë²•:</strong><br>
                        â€¢ dë¥¼ ì¡°ì ˆí•˜ì—¬ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ ëª¨ì–‘ ë³€ê²½<br>
                        â€¢ wë¥¼ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ ì•ˆ/ìœ„/ë°–ìœ¼ë¡œ ì´ë™<br>
                        â€¢ ê¶¤ë„ í‘œì‹œë¥¼ í™œì„±í™”í•˜ì—¬ ì—­í•™ í™•ì¸<br>
                        â€¢ ìº”ë²„ìŠ¤ í´ë¦­ìœ¼ë¡œ ì´ˆê¸°ì  ì„¤ì •
                    </div>
                </div>
                
                <div class="visualization">
                    <canvas id="canvasA" width="700" height="700"></canvas>
                </div>
            </div>
            
            <div class="math-section">
                <h3>ğŸ“ ìˆ˜í•™ì  ì •ì‹í™”</h3>
                <p><strong>ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ ê²½ê³„ (Cao, Fletcher, Ye):</strong></p>
                <p>\[
                z(\theta) = \frac{e^{id\theta} - d e^{i\theta}}{d+1}, \quad \theta \in [0, 2\pi]
                \]</p>
                
                <p style="margin-top: 15px;"><strong>ë‹¨ì¼ ì„ê³„ì ì„ ê°–ëŠ” ë¸”ë¼ìŠˆì¼€ ê³±:</strong></p>
                <p>\[
                B_{d,w}(z) = e^{it} \left(\frac{z - w}{1 - \bar{w}z}\right)^d
                \]</p>
                
                <p style="margin-top: 15px;">
                <strong>ë¶„ë¥˜:</strong> \(w\)ê°€ \(\gamma_d\) <strong>ë‚´ë¶€</strong>ì— ìˆìœ¼ë©´: <em>íƒ€ì›í˜•(elliptic)</em>; 
                \(\gamma_d\) <strong>ìœ„</strong>ì— ìˆìœ¼ë©´: <em>í¬ë¬¼í˜•(parabolic)</em>; 
                <strong>ì™¸ë¶€</strong>(\(\mathbb{D}\) ë‚´)ì— ìˆìœ¼ë©´: <em>ìŒê³¡í˜•(hyperbolic)</em>.
                </p>
            </div>
        </div>
        
        <!-- TAB B -->
        <div id="tab-1" class="tab-content">
            <div class="workspace">
                <div class="controls">
                    <h3>ë§¤ê°œë³€ìˆ˜</h3>
                    
                    <div class="control-group">
                        <label>ë°˜ì§€ë¦„ ë¹„ k: <span id="valueK" class="value-display">3</span></label>
                        <input type="range" id="sliderK" min="2" max="6" step="1" value="3">
                    </div>
                    
                    <div class="control-group">
                        <label>ë‘í¬ë ˆ ê¸°ìš¸ê¸°: <span id="valueSlope" class="value-display">1.00</span></label>
                        <input type="range" id="sliderSlope" min="0.1" max="3" step="0.1" value="1">
                    </div>
                    
                    <div class="control-group">
                        <label>íŠœë¸Œ ë°˜ì§€ë¦„: <span id="valueTubeR" class="value-display">0.30</span></label>
                        <input type="range" id="sliderTubeR" min="0.1" max="0.8" step="0.05" value="0.3">
                    </div>
                    
                    <div class="control-group">
                        <label>ìƒ˜í”Œ ì  ê°œìˆ˜: <span id="valueNB" class="value-display">200</span></label>
                        <input type="range" id="sliderNB" min="50" max="500" step="50" value="200">
                    </div>
                    
                    <div class="info-panel">
                        <strong>ë Œë”ë§:</strong><br>
                        â€¢ íŒŒë€ìƒ‰: í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ<br>
                        â€¢ ë¹¨ê°„ìƒ‰: ë‘í¬ë ˆ ê³¡ì„ <br>
                        â€¢ ì´ˆë¡ìƒ‰: í˜¸í”„ íŠœë¸Œ ê³¡ë©´
                    </div>
                </div>
                
                <div class="visualization">
                    <div id="container3DB" style="width: 100%; height: 100%;"></div>
                </div>
            </div>
            
            <div class="math-section">
                <h3>ğŸ“ ìˆ˜í•™ì  ì •ì‹í™”</h3>
                <p><strong>í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ (Barros, FerrÃ¡ndez):</strong></p>
                <p>\[
                \beta_k(\theta) = \left((k+1)\cos\theta - \cos((k+1)\theta),\; (k+1)\sin\theta - \sin((k+1)\theta)\right)
                \]</p>
                
                <p style="margin-top: 15px;"><strong>ë‘í¬ë ˆ ê³¡ì„  (ì¼ì • ê¸°ìš¸ê¸° ë‚˜ì„ ):</strong></p>
                <p>\[
                \gamma(t) = \text{3ì°¨ì› í™•ì¥, } \tau/\kappa = \text{ìƒìˆ˜}
                \]</p>
                
                <p style="margin-top: 15px;"><strong>í˜¸í”„ íŠœë¸Œ ë§¤ê°œë³€ìˆ˜í™”:</strong></p>
                <p>\[
                X(t, u) = \gamma(t) + \rho\left(\cos u\, \mathbf{n}(t) + \sin u\, \mathbf{b}(t)\right)
                \]</p>
                
                <p style="margin-top: 15px;">
                í•´ë°€í„´ ì—ë„ˆì§€ëŠ” \(C(\gamma) = \int \sqrt{\kappa^2 + 4}\, ds\)ì…ë‹ˆë‹¤.
                ì„ê³„ ê³¡ì„ ì€ ë³µì†Œ ì´ì°¨ê³¡ë©´ì—ì„œ ê·¹ì†Œ í˜¸í”„ íŠœë¸Œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
                </p>
            </div>
        </div>
        
        <!-- TAB C -->
        <div id="tab-2" class="tab-content">
            <div class="workspace-c">
                <div class="top-section">
                    <div class="controls">
                        <h3>ë§¤ê°œë³€ìˆ˜</h3>
                        
                        <div class="control-group">
                            <label>íŒŒë¼ë¯¸í„° m: <span id="valueM" class="value-display">0.80</span></label>
                            <input type="range" id="sliderM" min="-2" max="2" step="0.05" value="0.8">
                        </div>
                        
                        <div class="control-group">
                            <label>t ë²”ìœ„: <span id="valueTmax" class="value-display">12.57</span></label>
                            <input type="range" id="sliderTmax" min="3.14" max="25.13" step="0.1" value="12.57">
                        </div>
                        
                        <div class="control-group">
                            <label>ìƒ˜í”Œ ì  ê°œìˆ˜: <span id="valueNC" class="value-display">400</span></label>
                            <input type="range" id="sliderNC" min="100" max="800" step="100" value="400">
                        </div>
                        
                        <div class="info-panel">
                            <strong>ê³¡ë©´ ìœ í˜•:</strong><br>
                            <span id="surfaceType"></span>
                        </div>
                        
                        <div class="info-panel" style="margin-top: 10px;">
                            <strong>ê³¡ì„ :</strong><br>
                            â€¢ ë¹¨ê°„ìƒ‰: ì‚´ì½”í”„ìŠ¤í‚¤ ê³¡ì„ <br>
                            â€¢ ì´ˆë¡ìƒ‰: êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ (ì „ë‹¨)
                        </div>
                    </div>
                    
                    <div class="viz-3d">
                        <div id="container3DC" style="width: 100%; height: 100%;"></div>
                    </div>
                </div>
                
                <div class="viz-2d">
                    <h4>XY-í‰ë©´ ì‚¬ì˜ ë¹„êµ</h4>
                    <canvas id="canvasC" width="800" height="800"></canvas>
                </div>
            </div>
            
            <div class="math-section">
                <h3>ğŸ“ ìˆ˜í•™ì  ì •ì‹í™”</h3>
                <p><strong>ì‚´ì½”í”„ìŠ¤í‚¤ ê³¡ì„  (Monterde):</strong></p>
                <p>ì¼ì •í•œ ê³¡ë¥  \(\kappa \equiv 1\), ë¹„ìƒìˆ˜ ë¹„í‹€ë¦¼ \(\tau(t)\).</p>
                <p>íšŒì „ ê³¡ë©´ ìœ„ì— ì¡´ì¬: \(|m| > 1/\sqrt{3}\)ì´ë©´ íƒ€ì›ì²´, \(|m| < 1/\sqrt{3}\)ì´ë©´ ìŒê³¡ë©´.</p>
                
                <p style="margin-top: 15px;"><strong>êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ:</strong></p>
                <p>\[
                \begin{aligned}
                x(t) &= a\big((q-\cos\omega)\cos t + \cos\omega\cos(qt+t_0) + \sin t\sin(qt+t_0)\big)\\
                y(t) &= a\big((q-\cos\omega)\sin t + \cos\omega\sin(qt+t_0) - \cos t\sin(qt+t_0)\big)\\
                z(t) &= a\sin\omega(1 - \cos(qt))
                \end{aligned}
                \]</p>
                
                <p style="margin-top: 15px;">
                ì „ë‹¨ ë³€í™˜ \((x,y,z) \mapsto (x, y, cz+d)\) í•˜ì—ì„œ, êµ¬ë©´(ë˜ëŠ” ë³µì†Œ êµ¬ë©´) 
                ì—í”¼ì‚¬ì´í´ë¡œì´ë“œëŠ” ì‚´ì½”í”„ìŠ¤í‚¤ ê³¡ì„ ìœ¼ë¡œ ë§¤í•‘ë©ë‹ˆë‹¤. ë‘ ê³¡ì„ ì˜ \(xy\)-ì‚¬ì˜ì€ ì¼ì¹˜í•©ë‹ˆë‹¤.
                </p>
            </div>
        </div>
        
        <!-- TAB D -->
        <div id="tab-3" class="tab-content">
            <div class="workspace">
                <div class="controls">
                    <h3>ë§¤ê°œë³€ìˆ˜</h3>
                    
                    <div class="control-group">
                        <label>ë°˜ì§€ë¦„ ë¹„ìœ¨ q: <span id="valueQ" class="value-display">3.00</span></label>
                        <input type="range" id="sliderQ" min="1.5" max="6" step="0.1" value="3">
                    </div>
                    
                    <div class="control-group">
                        <label>ê°ë„ Ï‰ (deg): <span id="valueOmega" class="value-display">45</span></label>
                        <input type="range" id="sliderOmega" min="0" max="90" step="5" value="45">
                    </div>
                    
                    <div class="control-group">
                        <label>ì´ˆê¸° ìœ„ìƒ tâ‚€: <span id="valueT0" class="value-display">0.00</span></label>
                        <input type="range" id="sliderT0" min="0" max="6.28" step="0.1" value="0">
                    </div>
                    
                    <div class="control-group">
                        <label>êµ¬ ë°˜ì§€ë¦„ a: <span id="valueA" class="value-display">1.00</span></label>
                        <input type="range" id="sliderA" min="0.5" max="2" step="0.1" value="1">
                    </div>
                    
                    <div class="control-group">
                        <label>ì• ë‹ˆë©”ì´ì…˜ t: <span id="valueTanim" class="value-display">0.00</span></label>
                        <input type="range" id="sliderTanim" min="0" max="12.56" step="0.01" value="0">
                    </div>
                    
                    <div class="control-group">
                        <label>ì• ë‹ˆë©”ì´ì…˜ ì†ë„: <span id="valueSpeed" class="value-display">1.0x</span></label>
                        <input type="range" id="sliderSpeed" min="0.1" max="3" step="0.1" value="1">
                    </div>
                    
                    <div class="play-controls">
                        <button id="playButton" class="play-button">â–¶ ì¬ìƒ</button>
                    </div>
                    
                    <div class="info-panel" style="margin-top: 15px;">
                        <strong>ì‹œê°í™”:</strong><br>
                        â€¢ ì™¼ìª½: í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ<br>
                        â€¢ ì˜¤ë¥¸ìª½: êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ<br>
                        â€¢ íŒŒë€ìƒ‰ ì›: ê³ ì •ì›<br>
                        â€¢ ë¹¨ê°„ìƒ‰ ì›: íšŒì „ì›<br>
                        â€¢ ì´ˆë¡ìƒ‰: ìƒì„±ë˜ëŠ” ê¶¤ì 
                    </div>
                    
                    <div class="info-panel" style="margin-top: 10px; font-size: 0.85em;">
                        <strong>ì‚¬ìš©ë²•:</strong><br>
                        â€¢ q: í° ì›/ì‘ì€ ì›ì˜ ë°˜ì§€ë¦„ ë¹„<br>
                        â€¢ Ï‰: êµ¬ë©´ì—ì„œì˜ ì ‘ì´‰ ê°ë„<br>
                        â€¢ ì¬ìƒ ë²„íŠ¼ìœ¼ë¡œ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                    </div>
                </div>
                
                <div class="visualization">
                    <div class="dual-view">
                        <div class="view-panel">
                            <h4>í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ</h4>
                            <canvas id="canvasD2D" width="500" height="500"></canvas>
                        </div>
                        <div class="view-panel">
                            <h4>êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ</h4>
                            <div id="container3DD" style="width: 500px; height: 500px;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="math-section">
                <h3>ğŸ“ ìˆ˜í•™ì  ì •ì‹í™”: í‰ë©´ì—ì„œ êµ¬ë©´ìœ¼ë¡œì˜ í™•ì¥</h3>
                
                <p><strong>1. í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ (ê³ ì „):</strong></p>
                <p>ë°˜ì§€ë¦„ \(R\)ì¸ ê³ ì •ì› ìœ„ë¥¼ ë°˜ì§€ë¦„ \(r\)ì¸ ì›ì´ êµ¬ë¥¼ ë•Œ:</p>
                <p>\[
                \begin{aligned}
                x(t) &= (R+r)\cos t - r\cos\left(\frac{R+r}{r}t\right)\\
                y(t) &= (R+r)\sin t - r\sin\left(\frac{R+r}{r}t\right)
                \end{aligned}
                \]</p>
                <p>ì—¬ê¸°ì„œ \(q = \frac{R+r}{r}\)ì€ ë°˜ì§€ë¦„ ë¹„ìœ¨ì…ë‹ˆë‹¤.</p>
                
                <p style="margin-top: 20px;"><strong>2. êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ (Monterde 2024):</strong></p>
                <p>ë°˜ì§€ë¦„ \(a\)ì¸ êµ¬ ìœ„ì—ì„œ ì •ì˜ëœ í™•ì¥:</p>
                <p>\[
                \begin{aligned}
                x(t) &= a\left[(q-\cos\omega)\cos t + \cos\omega\cos(qt+t_0) + \sin t\sin(qt+t_0)\right]\\
                y(t) &= a\left[(q-\cos\omega)\sin t + \cos\omega\sin(qt+t_0) - \cos t\sin(qt+t_0)\right]\\
                z(t) &= a\sin\omega(1 - \cos(qt))
                \end{aligned}
                \]</p>
                
                <p style="margin-top: 15px;"><strong>ë§¤ê°œë³€ìˆ˜:</strong></p>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li>\(q\): ë°˜ì§€ë¦„ ë¹„ìœ¨ (í‰ë©´ì˜ ê²½ìš°ì™€ ë™ì¼)</li>
                    <li>\(\omega\): ë‘ ì› ì‚¬ì´ì˜ ê°ë„ (êµ¬ë©´ ê³ ìœ ì˜ ë§¤ê°œë³€ìˆ˜)</li>
                    <li>\(t_0\): ì´ˆê¸° ìœ„ìƒê°</li>
                    <li>\(a\): êµ¬ì˜ ë°˜ì§€ë¦„</li>
                </ul>
                
                <p style="margin-top: 15px;"><strong>ì£¼ìš” ì„±ì§ˆ:</strong></p>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li>\(\omega = 0\)ì¼ ë•Œ, í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œë¡œ í‡´í™” (\(z \equiv 0\))</li>
                    <li>ê³¡ì„ ì€ í•­ìƒ ë°˜ì§€ë¦„ \(a\)ì¸ êµ¬ ìœ„ì— ì¡´ì¬</li>
                    <li>Hopf fibrationê³¼ ìì—°ìŠ¤ëŸ½ê²Œ ì—°ê²°ë¨</li>
                    <li>íŠ¹ì • ì¡°ê±´ì—ì„œ Salkowski ê³¡ì„ ê³¼ ê´€ê³„</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // ì „ì—­ ìœ í‹¸ë¦¬í‹°
        // ========================================
        
        // ë³µì†Œìˆ˜ í—¬í¼ í•¨ìˆ˜
        const C = {
            add: (a, b) => ({re: a.re + b.re, im: a.im + b.im}),
            sub: (a, b) => ({re: a.re - b.re, im: a.im - b.im}),
            mul: (a, b) => ({re: a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re}),
            div: (a, b) => {
                const d = b.re*b.re + b.im*b.im;
                return {re: (a.re*b.re + a.im*b.im)/d, im: (a.im*b.re - a.re*b.im)/d};
            },
            conj: (a) => ({re: a.re, im: -a.im}),
            abs: (a) => Math.sqrt(a.re*a.re + a.im*a.im),
            arg: (a) => Math.atan2(a.im, a.re),
            exp: (a) => {
                const e = Math.exp(a.re);
                return {re: e*Math.cos(a.im), im: e*Math.sin(a.im)};
            },
            polar: (r, theta) => ({re: r*Math.cos(theta), im: r*Math.sin(theta)}),
            pow: (a, n) => {
                if (n === 0) return {re: 1, im: 0};
                let result = a;
                for (let i = 1; i < n; i++) {
                    result = C.mul(result, a);
                }
                return result;
            },
            scale: (a, s) => ({re: a.re*s, im: a.im*s})
        };
        
        // 3D ë²¡í„° í—¬í¼ í•¨ìˆ˜
        const V3 = {
            add: (a, b) => [a[0]+b[0], a[1]+b[1], a[2]+b[2]],
            sub: (a, b) => [a[0]-b[0], a[1]-b[1], a[2]-b[2]],
            scale: (a, s) => [a[0]*s, a[1]*s, a[2]*s],
            dot: (a, b) => a[0]*b[0] + a[1]*b[1] + a[2]*b[2],
            cross: (a, b) => [
                a[1]*b[2] - a[2]*b[1],
                a[2]*b[0] - a[0]*b[2],
                a[0]*b[1] - a[1]*b[0]
            ],
            norm: (a) => Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]),
            normalize: (a) => {
                const n = V3.norm(a);
                return n > 1e-10 ? [a[0]/n, a[1]/n, a[2]/n] : [0, 0, 0];
            }
        };
        
        // íƒ­ ì „í™˜
        let currentTab = 0;
        function switchTab(index) {
            document.querySelectorAll('.tab-button').forEach((btn, i) => {
                btn.classList.toggle('active', i === index);
            });
            document.querySelectorAll('.tab-content').forEach((content, i) => {
                content.classList.toggle('active', i === index);
            });
            currentTab = index;
            
            // í™œì„± íƒ­ ì¬ë Œë”ë§
            if (index === 0) updateTabA();
            if (index === 1) {
                setTimeout(() => {
                    updateTabB();
                }, 100);
            }
            if (index === 2) {
                setTimeout(() => {
                    updateTabC();
                }, 100);
            }
            if (index === 3) {
                setTimeout(() => {
                    updateTabD();
                }, 100);
            }
        }
        
        // ========================================
        // íƒ­ A: ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ & ë¸”ë¼ìŠˆì¼€ ê³±
        // ========================================
        
        let tabA = {
            canvas: null,
            ctx: null,
            d: 3,
            r: 0.4,
            phi: 0.785,
            t: 0,
            showOrbit: false,
            clickPoint: null
        };
        
        function initTabA() {
            tabA.canvas = document.getElementById('canvasA');
            tabA.ctx = tabA.canvas.getContext('2d');
            
            document.getElementById('sliderD').oninput = (e) => {
                tabA.d = parseInt(e.target.value);
                document.getElementById('valueD').textContent = tabA.d;
                updateTabA();
            };
            
            document.getElementById('sliderR').oninput = (e) => {
                tabA.r = parseFloat(e.target.value);
                document.getElementById('valueR').textContent = tabA.r.toFixed(2);
                updateTabA();
            };
            
            document.getElementById('sliderPhi').oninput = (e) => {
                tabA.phi = parseFloat(e.target.value);
                document.getElementById('valuePhi').textContent = tabA.phi.toFixed(2);
                updateTabA();
            };
            
            document.getElementById('sliderT').oninput = (e) => {
                tabA.t = parseFloat(e.target.value);
                document.getElementById('valueT').textContent = tabA.t.toFixed(2);
                updateTabA();
            };
            
            document.getElementById('checkOrbit').onchange = (e) => {
                tabA.showOrbit = e.target.checked;
                updateTabA();
            };
            
            tabA.canvas.onclick = (e) => {
                const rect = tabA.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const size = tabA.canvas.width;
                const cx = size / 2, cy = size / 2, scale = size / 2.4;
                const re = (x - cx) / scale;
                const im = -(y - cy) / scale;
                tabA.clickPoint = {re, im};
                updateTabA();
            };
            
            updateTabA();
        }
        
        function epicycloidA(theta, d) {
            // z(Î¸) = (e^(idÎ¸) - d*e^(iÎ¸)) / (d+1)
            const eid = C.polar(1, d * theta);
            const ei = C.polar(1, theta);
            const num = C.sub(eid, C.scale(ei, d));
            return C.scale(num, 1/(d+1));
        }
        
        function blaschkeProduct(z, w, d, t) {
            // B_{d,w}(z) = e^(it) * ((z-w)/(1-conj(w)*z))^d
            const num = C.sub(z, w);
            const denom = C.sub({re:1, im:0}, C.mul(C.conj(w), z));
            const frac = C.div(num, denom);
            const powered = C.pow(frac, d);
            const phase = C.polar(1, t);
            return C.mul(phase, powered);
        }
        
        function isInsideEpicycloid(z, d, samples=500) {
            // íšŒì „ìˆ˜(winding number) ì‚¬ìš©
            let angle = 0;
            let prev = epicycloidA(0, d);
            for (let i = 1; i <= samples; i++) {
                const theta = 2 * Math.PI * i / samples;
                const curr = epicycloidA(theta, d);
                const v1 = C.sub(prev, z);
                const v2 = C.sub(curr, z);
                const a1 = C.arg(v1);
                const a2 = C.arg(v2);
                let da = a2 - a1;
                if (da > Math.PI) da -= 2*Math.PI;
                if (da < -Math.PI) da += 2*Math.PI;
                angle += da;
                prev = curr;
            }
            const winding = Math.abs(angle) / (2*Math.PI);
            return winding > 0.5;
        }
        
        function isOnEpicycloid(z, d, samples=500, tol=0.02) {
            for (let i = 0; i < samples; i++) {
                const theta = 2 * Math.PI * i / samples;
                const p = epicycloidA(theta, d);
                if (C.abs(C.sub(p, z)) < tol) return true;
            }
            return false;
        }
        
        function updateTabA() {
            const {ctx, canvas, d, r, phi, t, showOrbit, clickPoint} = tabA;
            const size = canvas.width;
            const cx = size / 2, cy = size / 2;
            const scale = size / 2.4;
            
            ctx.clearRect(0, 0, size, size);
            
            // ì¢Œí‘œ ë³€í™˜
            const toCanvas = (z) => ({
                x: cx + z.re * scale,
                y: cy - z.im * scale
            });
            
            // ë‹¨ìœ„ì› ê·¸ë¦¬ê¸°
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, scale, 0, 2*Math.PI);
            ctx.stroke();
            
            // ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ ê·¸ë¦¬ê¸°
            ctx.strokeStyle = '#2a5298';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i <= 400; i++) {
                const theta = 2 * Math.PI * i / 400;
                const z = epicycloidA(theta, d);
                const p = toCanvas(z);
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // w ì  ê·¸ë¦¬ê¸°
            const w = C.polar(r, phi);
            const wp = toCanvas(w);
            
            // ë¶„ë¥˜
            let classification = '';
            if (isOnEpicycloid(w, d)) {
                classification = '<span class="status-indicator parabolic">í¬ë¬¼í˜•</span>';
                ctx.fillStyle = '#ffc107';
            } else if (isInsideEpicycloid(w, d)) {
                classification = '<span class="status-indicator elliptic">íƒ€ì›í˜•</span>';
                ctx.fillStyle = '#28a745';
            } else {
                classification = '<span class="status-indicator hyperbolic">ìŒê³¡í˜•</span>';
                ctx.fillStyle = '#dc3545';
            }
            
            document.getElementById('classification').innerHTML = classification;
            
            ctx.beginPath();
            ctx.arc(wp.x, wp.y, 8, 0, 2*Math.PI);
            ctx.fill();
            
            // w ë ˆì´ë¸”
            ctx.fillStyle = '#000';
            ctx.font = '14px sans-serif';
            ctx.fillText('w', wp.x + 12, wp.y - 12);
            
            // ê¶¤ë„ ê·¸ë¦¬ê¸° (í™œì„±í™”ëœ ê²½ìš°)
            if (showOrbit && clickPoint) {
                let z = clickPoint;
                ctx.fillStyle = 'rgba(255, 100, 100, 0.6)';
                
                for (let i = 0; i < 100; i++) {
                    const p = toCanvas(z);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 2, 0, 2*Math.PI);
                    ctx.fill();
                    
                    z = blaschkeProduct(z, w, d, t);
                    if (C.abs(z) > 1.5) break;
                }
            }
            
            // ì¶• ê·¸ë¦¬ê¸°
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(size, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, size);
            ctx.stroke();
        }
        
        // ========================================
        // íƒ­ B: í•´ë°€í„´ ê·¹ì†Œ í˜¸í”„ íŠœë¸Œ
        // ========================================
        
        let tabB = {
            scene: null,
            camera: null,
            renderer: null,
            controls: null,
            k: 3,
            slope: 1.0,
            tubeRadius: 0.3,
            numPoints: 200,
            mouseDown: false,
            mouseX: 0,
            mouseY: 0,
            initialized: false
        };
        
        function initTabB() {
            const container = document.getElementById('container3DB');
            if (!container) return;
            
            // ì»¨í…Œì´ë„ˆ í¬ê¸° í™•ì¸
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 600;
            
            // Three.js ì„¤ì •
            tabB.scene = new THREE.Scene();
            tabB.scene.background = new THREE.Color(0xf5f5f5);
            
            tabB.camera = new THREE.PerspectiveCamera(
                50,
                width / height,
                0.1,
                1000
            );
            tabB.camera.position.set(15, 12, 15);
            tabB.camera.lookAt(0, 0, 0);
            
            tabB.renderer = new THREE.WebGLRenderer({antialias: true});
            tabB.renderer.setSize(width, height);
            container.innerHTML = '';
            container.appendChild(tabB.renderer.domElement);
            
            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            tabB.scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 10, 10);
            tabB.scene.add(dirLight);
            
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight2.position.set(-10, -10, -10);
            tabB.scene.add(dirLight2);
            
            // ì»¨íŠ¸ë¡¤
            document.getElementById('sliderK').oninput = (e) => {
                tabB.k = parseInt(e.target.value);
                document.getElementById('valueK').textContent = tabB.k;
                updateTabB();
            };
            
            document.getElementById('sliderSlope').oninput = (e) => {
                tabB.slope = parseFloat(e.target.value);
                document.getElementById('valueSlope').textContent = tabB.slope.toFixed(2);
                updateTabB();
            };
            
            document.getElementById('sliderTubeR').oninput = (e) => {
                tabB.tubeRadius = parseFloat(e.target.value);
                document.getElementById('valueTubeR').textContent = tabB.tubeRadius.toFixed(2);
                updateTabB();
            };
            
            document.getElementById('sliderNB').oninput = (e) => {
                tabB.numPoints = parseInt(e.target.value);
                document.getElementById('valueNB').textContent = tabB.numPoints;
                updateTabB();
            };
            
            // ë§ˆìš°ìŠ¤ ì¸í„°ë™ì…˜
            tabB.renderer.domElement.addEventListener('mousedown', (e) => {
                tabB.mouseDown = true;
                tabB.mouseX = e.clientX;
                tabB.mouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                tabB.mouseDown = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (tabB.mouseDown) {
                    const dx = e.clientX - tabB.mouseX;
                    const dy = e.clientY - tabB.mouseY;
                    
                    const angle = Math.sqrt(dx*dx + dy*dy) * 0.01;
                    const axis = new THREE.Vector3(-dy, dx, 0).normalize();
                    
                    tabB.camera.position.sub(new THREE.Vector3(0, 0, 0));
                    tabB.camera.position.applyAxisAngle(axis, angle);
                    tabB.camera.position.add(new THREE.Vector3(0, 0, 0));
                    tabB.camera.lookAt(0, 0, 0);
                    
                    tabB.mouseX = e.clientX;
                    tabB.mouseY = e.clientY;
                    
                    tabB.renderer.render(tabB.scene, tabB.camera);
                }
            });
            
            tabB.renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 1.1 : 0.9;
                tabB.camera.position.multiplyScalar(factor);
                tabB.renderer.render(tabB.scene, tabB.camera);
            });
            
            tabB.initialized = true;
            updateTabB();
            animateTabB();
        }
        
        function planarEpicycloid(theta, k) {
            // Î²_k(Î¸) = ((k+1)cosÎ¸ - cos((k+1)Î¸), (k+1)sinÎ¸ - sin((k+1)Î¸))
            const x = (k+1)*Math.cos(theta) - Math.cos((k+1)*theta);
            const y = (k+1)*Math.sin(theta) - Math.sin((k+1)*theta);
            return [x, y];
        }
        
        function lancretCurve(t, slope, k) {
            // ì¼ì • ê¸°ìš¸ê¸°ë¥¼ ê°€ì§„ 3D ê³¡ì„  ìƒì„± (ë‘í¬ë ˆ ê³¡ì„ )
            const [x, y] = planarEpicycloid(t, k);
            const scale = 1.5;
            const z = slope * t;
            return [x * scale, y * scale, z];
        }
        
        function frenetFrame(gamma, t, dt=0.01) {
            // ìˆ˜ì¹˜ì  í”„ë ˆë„¤ í”„ë ˆì„
            const p = gamma(t);
            const p1 = gamma(t + dt);
            const p2 = gamma(t - dt);
            
            const T = V3.normalize(V3.sub(p1, p2));
            
            const p_next = gamma(t + 2*dt);
            const p_prev = gamma(t - 2*dt);
            const T_next = V3.normalize(V3.sub(p_next, p));
            const T_prev = V3.normalize(V3.sub(p, p_prev));
            
            const dT = V3.sub(T_next, T_prev);
            let N = V3.normalize(dT);
            
            // Nì´ 0ë²¡í„°ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
            if (V3.norm(N) < 0.001) {
                N = [0, 0, 1];
            }
            
            const B = V3.normalize(V3.cross(T, N));
            
            return {T, N, B};
        }
        
        function updateTabB() {
            if (!tabB.initialized || !tabB.scene) return;
            
            const {scene, k, slope, tubeRadius, numPoints} = tabB;
            
            // ì´ì „ ê°ì²´ ì œê±° (ì¡°ëª… ì œì™¸)
            const objectsToRemove = [];
            scene.children.forEach(child => {
                if (child.type !== 'AmbientLight' && child.type !== 'DirectionalLight') {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => scene.remove(obj));
            
            // ì¶• ì¶”ê°€
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // 1. í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ
            const epicycloidPoints = [];
            for (let i = 0; i <= numPoints; i++) {
                const theta = 2 * Math.PI * i / numPoints;
                const [x, y] = planarEpicycloid(theta, k);
                epicycloidPoints.push(new THREE.Vector3(x * 1.5, y * 1.5, -2));
            }
            const epicycloidGeom = new THREE.BufferGeometry().setFromPoints(epicycloidPoints);
            const epicycloidLine = new THREE.Line(
                epicycloidGeom,
                new THREE.LineBasicMaterial({color: 0x0066cc, linewidth: 2})
            );
            scene.add(epicycloidLine);
            
            // 2. ë‘í¬ë ˆ ê³¡ì„ 
            const lancretPoints = [];
            const tMax = 2 * Math.PI;
            for (let i = 0; i <= numPoints; i++) {
                const t = tMax * i / numPoints;
                const p = lancretCurve(t, slope, k);
                lancretPoints.push(new THREE.Vector3(p[0], p[1], p[2]));
            }
            const lancretGeom = new THREE.BufferGeometry().setFromPoints(lancretPoints);
            const lancretLine = new THREE.Line(
                lancretGeom,
                new THREE.LineBasicMaterial({color: 0xcc0000, linewidth: 3})
            );
            scene.add(lancretLine);
            
            // 3. í˜¸í”„ íŠœë¸Œ
            const gamma = (t) => lancretCurve(t, slope, k);
            
            const tubeSegments = Math.floor(numPoints / 2);
            const radialSegments = 20;
            
            const positions = [];
            const indices = [];
            
            for (let i = 0; i <= tubeSegments; i++) {
                const t = tMax * i / tubeSegments;
                const p = gamma(t);
                const {N, B} = frenetFrame(gamma, t);
                
                for (let j = 0; j <= radialSegments; j++) {
                    const u = 2 * Math.PI * j / radialSegments;
                    const offset = V3.add(
                        V3.scale(N, tubeRadius * Math.cos(u)),
                        V3.scale(B, tubeRadius * Math.sin(u))
                    );
                    const vertex = V3.add(p, offset);
                    positions.push(vertex[0], vertex[1], vertex[2]);
                }
            }
            
            for (let i = 0; i < tubeSegments; i++) {
                for (let j = 0; j < radialSegments; j++) {
                    const a = i * (radialSegments + 1) + j;
                    const b = a + radialSegments + 1;
                    const c = a + 1;
                    const d = b + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            const tubeGeom = new THREE.BufferGeometry();
            tubeGeom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            tubeGeom.setIndex(indices);
            tubeGeom.computeVertexNormals();
            
            const tubeMesh = new THREE.Mesh(
                tubeGeom,
                new THREE.MeshPhongMaterial({
                    color: 0x00cc66,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7,
                    shininess: 30
                })
            );
            scene.add(tubeMesh);
            
            tabB.renderer.render(scene, tabB.camera);
        }
        
        function animateTabB() {
            requestAnimationFrame(animateTabB);
            if (currentTab === 1 && tabB.initialized) {
                tabB.renderer.render(tabB.scene, tabB.camera);
            }
        }
        
        // ========================================
        // íƒ­ C: ì‚´ì½”í”„ìŠ¤í‚¤ & êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ
        // ========================================
        
        let tabC = {
            scene: null,
            camera: null,
            renderer: null,
            canvas: null,
            ctx: null,
            m: 0.8,
            tMax: 4 * Math.PI,
            numPoints: 400,
            mouseDown: false,
            mouseX: 0,
            mouseY: 0,
            initialized: false
        };
        
        function initTabC() {
            const container = document.getElementById('container3DC');
            if (!container) return;
            
            // ì»¨í…Œì´ë„ˆ í¬ê¸° í™•ì¸
            const width = container.clientWidth || 800;
            const height = container.clientHeight || 500;
            
            // Three.js ì„¤ì •
            tabC.scene = new THREE.Scene();
            tabC.scene.background = new THREE.Color(0xf5f5f5);
            
            tabC.camera = new THREE.PerspectiveCamera(
                50,
                width / height,
                0.1,
                1000
            );
            tabC.camera.position.set(8, 6, 8);
            tabC.camera.lookAt(0, 0, 0);
            
            tabC.renderer = new THREE.WebGLRenderer({antialias: true});
            tabC.renderer.setSize(width, height);
            container.innerHTML = '';
            container.appendChild(tabC.renderer.domElement);
            
            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            tabC.scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 10, 10);
            tabC.scene.add(dirLight);
            
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            dirLight2.position.set(-10, -10, -10);
            tabC.scene.add(dirLight2);
            
            // ìº”ë²„ìŠ¤ ì„¤ì •
            tabC.canvas = document.getElementById('canvasC');
            tabC.ctx = tabC.canvas.getContext('2d');
            
            // ì»¨íŠ¸ë¡¤
            document.getElementById('sliderM').oninput = (e) => {
                tabC.m = parseFloat(e.target.value);
                if (Math.abs(tabC.m) < 0.05) tabC.m = 0.05 * Math.sign(tabC.m);
                document.getElementById('valueM').textContent = tabC.m.toFixed(2);
                updateTabC();
            };
            
            document.getElementById('sliderTmax').oninput = (e) => {
                tabC.tMax = parseFloat(e.target.value);
                document.getElementById('valueTmax').textContent = tabC.tMax.toFixed(2);
                updateTabC();
            };
            
            document.getElementById('sliderNC').oninput = (e) => {
                tabC.numPoints = parseInt(e.target.value);
                document.getElementById('valueNC').textContent = tabC.numPoints;
                updateTabC();
            };
            
            // ë§ˆìš°ìŠ¤ ì¸í„°ë™ì…˜
            tabC.renderer.domElement.addEventListener('mousedown', (e) => {
                tabC.mouseDown = true;
                tabC.mouseX = e.clientX;
                tabC.mouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                tabC.mouseDown = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (tabC.mouseDown && currentTab === 2) {
                    const dx = e.clientX - tabC.mouseX;
                    const dy = e.clientY - tabC.mouseY;
                    
                    const angle = Math.sqrt(dx*dx + dy*dy) * 0.01;
                    const axis = new THREE.Vector3(-dy, dx, 0).normalize();
                    
                    tabC.camera.position.sub(new THREE.Vector3(0, 0, 0));
                    tabC.camera.position.applyAxisAngle(axis, angle);
                    tabC.camera.position.add(new THREE.Vector3(0, 0, 0));
                    tabC.camera.lookAt(0, 0, 0);
                    
                    tabC.mouseX = e.clientX;
                    tabC.mouseY = e.clientY;
                    
                    tabC.renderer.render(tabC.scene, tabC.camera);
                }
            });
            
            tabC.renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 1.1 : 0.9;
                tabC.camera.position.multiplyScalar(factor);
                tabC.renderer.render(tabC.scene, tabC.camera);
            });
            
            tabC.initialized = true;
            updateTabC();
            animateTabC();
        }
        
        function salkowskiCurve(t, m) {
            // ì¼ì • ê³¡ë¥  Îº=1ì„ ê°€ì§„ ì‚´ì½”í”„ìŠ¤í‚¤ ê³¡ì„ 
            const a = Math.sqrt(Math.abs(1 - 9*m*m));
            
            // í‘œì¤€ í˜•ì‹
            const x = t + m * Math.sin(t) * Math.cos(t);
            const y = m * Math.sin(t) * Math.sin(t);
            const z = Math.cos(t);
            
            return [x * 2, y * 2, z * 2];
        }
        
        function sphericalEpicycloid(t, m) {
            // mì— ê¸°ë°˜í•œ íŒŒë¼ë¯¸í„° ê³„ì‚°
            const threshold = 1 / Math.sqrt(3);
            
            let a, q, omega, t0, c, d;
            
            if (Math.abs(m) > threshold) {
                // íƒ€ì›ì²´ ê²½ìš°
                a = 1.5;
                q = 2 + Math.abs(m);
                omega = Math.PI / 4 + m * 0.3;
                t0 = 0;
                c = 1.2;
                d = 0;
            } else {
                // ìŒê³¡ë©´ ê²½ìš° (ë³µì†Œ Ï‰)
                a = 1.5;
                q = 2 + Math.abs(m) * 2;
                omega = Math.PI / 6 + m * 0.5;
                t0 = 0;
                c = 0.8;
                d = 0;
            }
            
            // êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ ê³µì‹
            const x = a * ((q - Math.cos(omega)) * Math.cos(t) + 
                          Math.cos(omega) * Math.cos(q*t + t0) + 
                          Math.sin(t) * Math.sin(q*t + t0));
            
            const y = a * ((q - Math.cos(omega)) * Math.sin(t) + 
                          Math.cos(omega) * Math.sin(q*t + t0) - 
                          Math.cos(t) * Math.sin(q*t + t0));
            
            const z = a * Math.sin(omega) * (1 - Math.cos(q*t));
            
            // ì „ë‹¨ ë³€í™˜ ì ìš©
            return [x, y, c * z + d];
        }
        
        function updateTabC() {
            if (!tabC.initialized || !tabC.scene) return;
            
            const {scene, ctx, canvas, m, tMax, numPoints} = tabC;
            
            // ê³¡ë©´ ìœ í˜• í‘œì‹œ ì—…ë°ì´íŠ¸
            const threshold = 1 / Math.sqrt(3);
            let surfaceType = '';
            if (Math.abs(m) > threshold) {
                surfaceType = '<span class="status-indicator ellipsoid-region">íƒ€ì›ì²´ (|m| > 1/âˆš3)</span>';
            } else {
                surfaceType = '<span class="status-indicator hyperboloid-region">ìŒê³¡ë©´ (|m| < 1/âˆš3)</span>';
            }
            document.getElementById('surfaceType').innerHTML = surfaceType;
            
            // 3D ì”¬ ì´ˆê¸°í™”
            const objectsToRemove = [];
            scene.children.forEach(child => {
                if (child.type !== 'AmbientLight' && child.type !== 'DirectionalLight') {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => scene.remove(obj));
            
            // ì¶• ì¶”ê°€
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // ì‚´ì½”í”„ìŠ¤í‚¤ ê³¡ì„ 
            const salkowskiPoints = [];
            const salkowskiProjection = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const t = tMax * i / numPoints;
                const p = salkowskiCurve(t, m);
                salkowskiPoints.push(new THREE.Vector3(p[0], p[1], p[2]));
                salkowskiProjection.push([p[0], p[1]]);
            }
            
            const salkowskiGeom = new THREE.BufferGeometry().setFromPoints(salkowskiPoints);
            const salkowskiLine = new THREE.Line(
                salkowskiGeom,
                new THREE.LineBasicMaterial({color: 0xcc0000, linewidth: 3})
            );
            scene.add(salkowskiLine);
            
            // êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ
            const epicycloidPoints = [];
            const epicycloidProjection = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const t = tMax * i / numPoints;
                const p = sphericalEpicycloid(t, m);
                epicycloidPoints.push(new THREE.Vector3(p[0], p[1], p[2]));
                epicycloidProjection.push([p[0], p[1]]);
            }
            
            const epicycloidGeom = new THREE.BufferGeometry().setFromPoints(epicycloidPoints);
            const epicycloidLine = new THREE.Line(
                epicycloidGeom,
                new THREE.LineBasicMaterial({color: 0x00cc66, linewidth: 3})
            );
            scene.add(epicycloidLine);
            
            // XY í‰ë©´ ì°¸ì¡°
            const planeGeom = new THREE.PlaneGeometry(15, 15);
            const planeMat = new THREE.MeshBasicMaterial({
                color: 0xe0e0e0,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.2
            });
            const plane = new THREE.Mesh(planeGeom, planeMat);
            plane.rotation.x = Math.PI / 2;
            scene.add(plane);
            
            tabC.renderer.render(scene, tabC.camera);
            
            // 2D ì‚¬ì˜ ê·¸ë¦¬ê¸°
            const size = canvas.width;
            const cx = size / 2, cy = size / 2;
            const scale = size / 18;
            
            ctx.clearRect(0, 0, size, size);
            
            // ë°°ê²½
            ctx.fillStyle = '#f9f9f9';
            ctx.fillRect(0, 0, size, size);
            
            // ì¶•
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, cy);
            ctx.lineTo(size, cy);
            ctx.moveTo(cx, 0);
            ctx.lineTo(cx, size);
            ctx.stroke();
            
            // ì‚´ì½”í”„ìŠ¤í‚¤ ì‚¬ì˜
            ctx.strokeStyle = '#cc0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < salkowskiProjection.length; i++) {
                const x = cx + salkowskiProjection[i][0] * scale;
                const y = cy - salkowskiProjection[i][1] * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ ì‚¬ì˜ (ê²¹ì¹¨)
            ctx.strokeStyle = '#00cc66';
            ctx.lineWidth = 2.5;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            for (let i = 0; i < epicycloidProjection.length; i++) {
                const x = cx + epicycloidProjection[i][0] * scale;
                const y = cy - epicycloidProjection[i][1] * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0;
            
            // ë²”ë¡€
            ctx.font = 'bold 16px sans-serif';
            ctx.fillStyle = '#cc0000';
            ctx.fillText('â— ì‚´ì½”í”„ìŠ¤í‚¤ ê³¡ì„ ', 30, 40);
            ctx.fillStyle = '#00cc66';
            ctx.fillText('â— êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ', 30, 70);
        }
        
        function animateTabC() {
            requestAnimationFrame(animateTabC);
            if (currentTab === 2 && tabC.initialized) {
                tabC.renderer.render(tabC.scene, tabC.camera);
            }
        }
        
        // ========================================
        // íƒ­ D: í‰ë©´â†’êµ¬ë©´ ë§¤ê°œí™” í™•ì¥
        // ========================================
        
        let tabD = {
            canvas2D: null,
            ctx2D: null,
            scene: null,
            camera: null,
            renderer: null,
            q: 3.0,
            omega: Math.PI / 4,
            t0: 0,
            a: 1.0,
            tAnim: 0,
            speed: 1.0,
            isPlaying: false,
            mouseDown: false,
            mouseX: 0,
            mouseY: 0,
            initialized: false,
            animationId: null
        };
        
        function initTabD() {
            // 2D ìº”ë²„ìŠ¤ ì„¤ì •
            tabD.canvas2D = document.getElementById('canvasD2D');
            tabD.ctx2D = tabD.canvas2D.getContext('2d');
            
            // 3D ì„¤ì •
            const container = document.getElementById('container3DD');
            if (!container) return;
            
            const width = 500;
            const height = 500;
            
            tabD.scene = new THREE.Scene();
            tabD.scene.background = new THREE.Color(0xf5f5f5);
            
            tabD.camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            tabD.camera.position.set(3, 2, 3);
            tabD.camera.lookAt(0, 0, 0);
            
            tabD.renderer = new THREE.WebGLRenderer({antialias: true});
            tabD.renderer.setSize(width, height);
            container.innerHTML = '';
            container.appendChild(tabD.renderer.domElement);
            
            // ì¡°ëª…
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            tabD.scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 5, 5);
            tabD.scene.add(dirLight);
            
            // ì»¨íŠ¸ë¡¤
            document.getElementById('sliderQ').oninput = (e) => {
                tabD.q = parseFloat(e.target.value);
                document.getElementById('valueQ').textContent = tabD.q.toFixed(2);
                updateTabD();
            };
            
            document.getElementById('sliderOmega').oninput = (e) => {
                const deg = parseFloat(e.target.value);
                tabD.omega = deg * Math.PI / 180;
                document.getElementById('valueOmega').textContent = deg;
                updateTabD();
            };
            
            document.getElementById('sliderT0').oninput = (e) => {
                tabD.t0 = parseFloat(e.target.value);
                document.getElementById('valueT0').textContent = tabD.t0.toFixed(2);
                updateTabD();
            };
            
            document.getElementById('sliderA').oninput = (e) => {
                tabD.a = parseFloat(e.target.value);
                document.getElementById('valueA').textContent = tabD.a.toFixed(2);
                updateTabD();
            };
            
            document.getElementById('sliderTanim').oninput = (e) => {
                tabD.tAnim = parseFloat(e.target.value);
                document.getElementById('valueTanim').textContent = tabD.tAnim.toFixed(2);
                updateTabD();
            };
            
            document.getElementById('sliderSpeed').oninput = (e) => {
                tabD.speed = parseFloat(e.target.value);
                document.getElementById('valueSpeed').textContent = tabD.speed.toFixed(1) + 'x';
            };
            
            // ì¬ìƒ ë²„íŠ¼
            document.getElementById('playButton').onclick = () => {
                tabD.isPlaying = !tabD.isPlaying;
                const btn = document.getElementById('playButton');
                if (tabD.isPlaying) {
                    btn.textContent = 'â¸ ì •ì§€';
                    btn.classList.add('playing');
                } else {
                    btn.textContent = 'â–¶ ì¬ìƒ';
                    btn.classList.remove('playing');
                }
            };
            
            // ë§ˆìš°ìŠ¤ ì¸í„°ë™ì…˜ (3D)
            tabD.renderer.domElement.addEventListener('mousedown', (e) => {
                tabD.mouseDown = true;
                tabD.mouseX = e.clientX;
                tabD.mouseY = e.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                tabD.mouseDown = false;
            });
            
            window.addEventListener('mousemove', (e) => {
                if (tabD.mouseDown && currentTab === 3) {
                    const dx = e.clientX - tabD.mouseX;
                    const dy = e.clientY - tabD.mouseY;
                    
                    const angle = Math.sqrt(dx*dx + dy*dy) * 0.01;
                    const axis = new THREE.Vector3(-dy, dx, 0).normalize();
                    
                    tabD.camera.position.applyAxisAngle(axis, angle);
                    tabD.camera.lookAt(0, 0, 0);
                    
                    tabD.mouseX = e.clientX;
                    tabD.mouseY = e.clientY;
                    
                    tabD.renderer.render(tabD.scene, tabD.camera);
                }
            });
            
            tabD.renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                const factor = e.deltaY > 0 ? 1.1 : 0.9;
                tabD.camera.position.multiplyScalar(factor);
                tabD.renderer.render(tabD.scene, tabD.camera);
            });
            
            tabD.initialized = true;
            updateTabD();
            animateTabD();
        }
        
        // í‰ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ
        function planarEpicycloidD(t, q) {
            // q = (R+r)/r
            // x = (R+r)cos(t) - r*cos((R+r)/r * t)
            // y = (R+r)sin(t) - r*sin((R+r)/r * t)
            // ì •ê·œí™”: R+r = 1ë¡œ ë‘ë©´ r = 1/(q)
            const R_plus_r = 1;
            const r = R_plus_r / q;
            const R = R_plus_r - r;
            
            const x = R_plus_r * Math.cos(t) - r * Math.cos(q * t);
            const y = R_plus_r * Math.sin(t) - r * Math.sin(q * t);
            
            return [x, y];
        }
        
        // êµ¬ë©´ ì—í”¼ì‚¬ì´í´ë¡œì´ë“œ (Monterde 2024)
        function sphericalEpicycloidD(t, q, omega, t0, a) {
            const x = a * ((q - Math.cos(omega)) * Math.cos(t) + 
                          Math.cos(omega) * Math.cos(q*t + t0) + 
                          Math.sin(t) * Math.sin(q*t + t0));
            
            const y = a * ((q - Math.cos(omega)) * Math.sin(t) + 
                          Math.cos(omega) * Math.sin(q*t + t0) - 
                          Math.cos(t) * Math.sin(q*t + t0));
            
            const z = a * Math.sin(omega) * (1 - Math.cos(q*t));
            
            return [x, y, z];
        }
        
        function updateTabD() {
            if (!tabD.initialized) return;
            
            draw2DEpicycloid();
            draw3DEpicycloid();
        }
        
        function draw2DEpicycloid() {
            const {ctx2D, canvas2D, q, tAnim} = tabD;
            const size = canvas2D.width;
            const cx = size / 2, cy = size / 2;
            const scale = size / 3;
            
            ctx2D.clearRect(0, 0, size, size);
            
            // ë°°ê²½
            ctx2D.fillStyle = '#fafafa';
            ctx2D.fillRect(0, 0, size, size);
            
            // ì¶•
            ctx2D.strokeStyle = '#ddd';
            ctx2D.lineWidth = 1;
            ctx2D.beginPath();
            ctx2D.moveTo(0, cy);
            ctx2D.lineTo(size, cy);
            ctx2D.moveTo(cx, 0);
            ctx2D.lineTo(cx, size);
            ctx2D.stroke();
            
            // ê³ ì •ì› (R)
            const R_plus_r = 1;
            const r = R_plus_r / q;
            const R = R_plus_r - r;
            
            ctx2D.strokeStyle = '#0066cc';
            ctx2D.lineWidth = 2;
            ctx2D.beginPath();
            ctx2D.arc(cx, cy, R * scale, 0, 2*Math.PI);
            ctx2D.stroke();
            
            // íšŒì „ì›ì˜ ì¤‘ì‹¬
            const angle = tAnim;
            const centerX = cx + R_plus_r * Math.cos(angle) * scale;
            const centerY = cy - R_plus_r * Math.sin(angle) * scale;
            
            // íšŒì „ì› (r)
            ctx2D.strokeStyle = '#cc0000';
            ctx2D.lineWidth = 2;
            ctx2D.beginPath();
            ctx2D.arc(centerX, centerY, r * scale, 0, 2*Math.PI);
            ctx2D.stroke();
            
            // ì „ì²´ ê¶¤ì 
            ctx2D.strokeStyle = '#00cc66';
            ctx2D.lineWidth = 2.5;
            ctx2D.beginPath();
            for (let i = 0; i <= 500; i++) {
                const t = 2 * Math.PI * i / 500;
                const [x, y] = planarEpicycloidD(t, q);
                const px = cx + x * scale;
                const py = cy - y * scale;
                if (i === 0) ctx2D.moveTo(px, py);
                else ctx2D.lineTo(px, py);
            }
            ctx2D.stroke();
            
            // í˜„ì¬ ì 
            const [currX, currY] = planarEpicycloidD(tAnim, q);
            ctx2D.fillStyle = '#ff6600';
            ctx2D.beginPath();
            ctx2D.arc(cx + currX * scale, cy - currY * scale, 5, 0, 2*Math.PI);
            ctx2D.fill();
            
            // ì—°ê²°ì„ 
            ctx2D.strokeStyle = '#999';
            ctx2D.lineWidth = 1;
            ctx2D.setLineDash([5, 5]);
            ctx2D.beginPath();
            ctx2D.moveTo(centerX, centerY);
            ctx2D.lineTo(cx + currX * scale, cy - currY * scale);
            ctx2D.stroke();
            ctx2D.setLineDash([]);
        }
        
        function draw3DEpicycloid() {
            if (!tabD.scene) return;
            
            const {scene, q, omega, t0, a, tAnim} = tabD;
            
            // ì”¬ ì´ˆê¸°í™”
            const objectsToRemove = [];
            scene.children.forEach(child => {
                if (child.type !== 'AmbientLight' && child.type !== 'DirectionalLight') {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => scene.remove(obj));
            
            // ì¶•
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);
            
            // êµ¬ (ì™€ì´ì–´í”„ë ˆì„)
            const sphereGeom = new THREE.SphereGeometry(a, 32, 32);
            const sphereMat = new THREE.MeshBasicMaterial({
                color: 0xcccccc,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const sphere = new THREE.Mesh(sphereGeom, sphereMat);
            scene.add(sphere);
            
            // ê³ ì • ì› (êµ¬ë©´ ìœ„ì˜ í° ì›)
            // ìœ„ë„ omegaì— í•´ë‹¹í•˜ëŠ” ì›
            const fixedCirclePoints = [];
            const fixedRadius = a * Math.sin(omega);
            const fixedZ = a * (1 - Math.cos(omega));
            
            for (let i = 0; i <= 100; i++) {
                const angle = 2 * Math.PI * i / 100;
                fixedCirclePoints.push(new THREE.Vector3(
                    fixedRadius * Math.cos(angle),
                    fixedRadius * Math.sin(angle),
                    fixedZ
                ));
            }
            const fixedCircleGeom = new THREE.BufferGeometry().setFromPoints(fixedCirclePoints);
            const fixedCircleLine = new THREE.Line(
                fixedCircleGeom,
                new THREE.LineBasicMaterial({color: 0x0066cc, linewidth: 2})
            );
            scene.add(fixedCircleLine);
            
            // ì „ì²´ ê¶¤ì 
            const trajectoryPoints = [];
            for (let i = 0; i <= 500; i++) {
                const t = 2 * Math.PI * i / 500;
                const [x, y, z] = sphericalEpicycloidD(t, q, omega, t0, a);
                trajectoryPoints.push(new THREE.Vector3(x, y, z));
            }
            const trajectoryGeom = new THREE.BufferGeometry().setFromPoints(trajectoryPoints);
            const trajectoryLine = new THREE.Line(
                trajectoryGeom,
                new THREE.LineBasicMaterial({color: 0x00cc66, linewidth: 3})
            );
            scene.add(trajectoryLine);
            
            // í˜„ì¬ ì 
            const [currX, currY, currZ] = sphericalEpicycloidD(tAnim, q, omega, t0, a);
            const pointGeom = new THREE.SphereGeometry(0.05, 16, 16);
            const pointMat = new THREE.MeshBasicMaterial({color: 0xff6600});
            const point = new THREE.Mesh(pointGeom, pointMat);
            point.position.set(currX, currY, currZ);
            scene.add(point);
            
            // íšŒì „ì› (ê·¼ì‚¬ì ìœ¼ë¡œ í‘œì‹œ)
            // í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì ‘í‰ë©´ ìƒì˜ ì›
            const rollingCirclePoints = [];
            const rollingRadius = 0.2; // ì‹œê°í™”ë¥¼ ìœ„í•œ ê·¼ì‚¬ê°’
            
            for (let i = 0; i <= 50; i++) {
                const angle = 2 * Math.PI * i / 50;
                // ê°„ë‹¨í•œ ê·¼ì‚¬: í˜„ì¬ì  ì£¼ë³€ì— ì› ê·¸ë¦¬ê¸°
                const dx = rollingRadius * Math.cos(angle);
                const dy = rollingRadius * Math.sin(angle);
                rollingCirclePoints.push(new THREE.Vector3(
                    currX + dx,
                    currY + dy,
                    currZ
                ));
            }
            const rollingCircleGeom = new THREE.BufferGeometry().setFromPoints(rollingCirclePoints);
            const rollingCircleLine = new THREE.Line(
                rollingCircleGeom,
                new THREE.LineBasicMaterial({color: 0xcc0000, linewidth: 2})
            );
            scene.add(rollingCircleLine);
            
            tabD.renderer.render(scene, tabD.camera);
        }
        
        function animateTabD() {
            requestAnimationFrame(animateTabD);
            
            if (currentTab === 3 && tabD.initialized) {
                if (tabD.isPlaying) {
                    tabD.tAnim += 0.01 * tabD.speed;
                    if (tabD.tAnim > 4 * Math.PI) {
                        tabD.tAnim = 0;
                    }
                    
                    document.getElementById('sliderTanim').value = tabD.tAnim;
                    document.getElementById('valueTanim').textContent = tabD.tAnim.toFixed(2);
                    
                    updateTabD();
                }
                
                tabD.renderer.render(tabD.scene, tabD.camera);
            }
        }
        
        // ========================================
        // ì´ˆê¸°í™”
        // ========================================
        
        window.onload = () => {
            initTabA();
            
            // 3D ì´ˆê¸°í™”ëŠ” ì•½ê°„ ì§€ì—°
            setTimeout(() => {
                initTabB();
                initTabC();
                initTabD();
            }, 200);
        };
    </script>
</body>
</html>
