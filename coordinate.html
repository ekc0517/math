<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í¬ë¬¼ì„  ê±°ìš¸ì˜ ë°˜ì‚¬ ì„±ì§ˆ ë° ê¸°í•˜í•™ì  ì¦ëª… ì‹œë®¬ë ˆì´í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background: linear-gradient(135deg, #0d0d1a 0%, #1a1a2e 50%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            display: flex;
        }

        /* ==================== ì»¨íŠ¸ë¡¤ íŒ¨ë„ ==================== */
        .control-panel {
            width: 360px;
            min-width: 360px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: 100vh;
        }

        .panel-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #00d9ff;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 1px solid #0f3460;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .panel-subtitle {
            font-size: 0.75em;
            color: #888;
            text-align: center;
            margin-top: 5px;
            font-weight: normal;
        }

        .control-group {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #0f3460;
            transition: all 0.3s;
        }

        .control-group:hover {
            border-color: rgba(0, 217, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.1);
        }

        .control-group h3 {
            font-size: 0.95em;
            color: #ffd93d;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #ffd93d;
            border-radius: 50%;
            box-shadow: 0 0 8px #ffd93d;
        }

        /* ==================== ìŠ¬ë¼ì´ë” ==================== */
        .slider-container {
            margin-bottom: 14px;
        }

        .slider-container:last-child {
            margin-bottom: 0;
        }

        .slider-container label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 0.85em;
            color: #ccc;
        }

        .slider-container label span {
            color: #00d9ff;
            font-weight: bold;
            font-family: 'Consolas', 'Monaco', monospace;
            background: rgba(0, 217, 255, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #0f3460, #00d9ff);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }

        input[type="range"]:hover {
            box-shadow: 0 0 10px rgba(0, 217, 255, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #ffd93d, #ff9500);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 217, 61, 0.5);
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 217, 61, 0.8);
        }

        /* ==================== ì²´í¬ë°•ìŠ¤ ==================== */
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.85em;
            cursor: pointer;
            padding: 6px 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .checkbox-container:hover {
            background: rgba(0, 217, 255, 0.1);
        }

        .checkbox-container input {
            width: 18px;
            height: 18px;
            accent-color: #00d9ff;
            cursor: pointer;
        }

        /* ==================== ë²„íŠ¼ ==================== */
        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .action-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-btn:active {
            transform: scale(0.95);
        }

        .btn-start {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }

        .btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.5);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .btn-stop:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }

        .btn-reset {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            color: white;
            box-shadow: 0 4px 15px rgba(168, 85, 247, 0.3);
        }

        .btn-reset:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5);
        }

        /* ==================== í†µê³„ ê·¸ë¦¬ë“œ ==================== */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 12px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px 8px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s;
        }

        .stat-item:hover {
            background: rgba(0, 217, 255, 0.1);
            border-color: rgba(0, 217, 255, 0.2);
        }

        .stat-value {
            font-size: 1.6em;
            color: #00d9ff;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
            font-family: 'Consolas', monospace;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* ==================== ëª¨ë“œ ë²„íŠ¼ ==================== */
        .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 90px;
            padding: 12px 10px;
            border: 2px solid #0f3460;
            border-radius: 8px;
            background: rgba(15, 52, 96, 0.5);
            color: #aaa;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: rgba(15, 52, 96, 0.8);
            border-color: #00d9ff;
            color: #fff;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.3), rgba(15, 52, 96, 0.8));
            border-color: #00d9ff;
            color: white;
            box-shadow: 0 0 20px rgba(0, 217, 255, 0.4);
        }

        /* ==================== ì •ë³´ ë°•ìŠ¤ ==================== */
        .info-box {
            background: rgba(0, 217, 255, 0.08);
            border: 1px solid rgba(0, 217, 255, 0.2);
            border-radius: 10px;
            padding: 15px;
            font-size: 0.82em;
            line-height: 1.7;
        }

        .info-box .formula {
            font-family: 'Times New Roman', 'Georgia', serif;
            font-size: 1.4em;
            color: #ffd93d;
            text-align: center;
            margin: 12px 0;
            font-style: italic;
            text-shadow: 0 0 10px rgba(255, 217, 61, 0.3);
        }

        /* ==================== ì‹¤ì‹œê°„ ë°ì´í„° ==================== */
        .live-data {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.78em;
            line-height: 2;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .live-data .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .live-data .row:last-child {
            border-bottom: none;
        }

        .live-data .label {
            color: #888;
        }

        .live-data .value {
            color: #00d9ff;
            font-weight: bold;
        }

        .live-data .highlight {
            color: #4ecdc4;
            font-weight: bold;
            font-size: 1.1em;
        }

        .live-data .warning {
            color: #ffd93d;
        }

        /* ==================== ë²”ë¡€ ==================== */
        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 0.78em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .legend-color {
            width: 24px;
            height: 6px;
            border-radius: 3px;
            box-shadow: 0 0 8px currentColor;
        }

        /* ==================== ì´ë¡  í…ìŠ¤íŠ¸ ==================== */
        .theory-text {
            font-size: 0.8em;
            line-height: 1.8;
            color: #aaa;
            text-align: justify;
        }

        .theory-text strong {
            color: #ffd93d;
        }

        .theory-text .highlight {
            color: #00d9ff;
        }

        /* ==================== ìº”ë²„ìŠ¤ ì»¨í…Œì´ë„ˆ ==================== */
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: radial-gradient(ellipse at center, #0d1421 0%, #050510 100%);
            position: relative;
        }

        #mainCanvas {
            border-radius: 12px;
            box-shadow: 
                0 0 30px rgba(0, 217, 255, 0.2),
                0 0 60px rgba(0, 217, 255, 0.1),
                inset 0 0 100px rgba(0, 0, 0, 0.5);
            cursor: crosshair;
            background: #050510;
        }

        .canvas-info {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.8em;
            color: #888;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .canvas-info span {
            color: #00d9ff;
            font-weight: bold;
        }

        /* ==================== ë°˜ì‘í˜• ==================== */
        @media (max-width: 1000px) {
            body {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                min-width: auto;
                max-height: 50vh;
                border-right: none;
                border-bottom: 2px solid #0f3460;
            }
            .canvas-container {
                padding: 10px;
                min-height: 50vh;
            }
            .stats-grid {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 600px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .legend {
                grid-template-columns: 1fr;
            }
        }

        /* ==================== ìŠ¤í¬ë¡¤ë°” ì»¤ìŠ¤í…€ ==================== */
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }

        .control-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .control-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #0f3460, #00d9ff);
            border-radius: 4px;
        }

        .control-panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, #00d9ff, #0f3460);
        }

        /* ==================== ì• ë‹ˆë©”ì´ì…˜ ==================== */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .running-indicator {
            animation: pulse 1s infinite;
            color: #4ecdc4 !important;
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <h1 class="panel-title">
            ğŸ”­ ê´‘í•™ ë°˜ì‚¬ ì‹œë®¬ë ˆì´í„°
            <div class="panel-subtitle">V. Ivchenko ë…¼ë¬¸ ê¸°ë°˜ ê¸°í•˜í•™ì  ì¦ëª…</div>
        </h1>

        <!-- ==================== ì‹œë®¬ë ˆì´ì…˜ ì»¨íŠ¸ë¡¤ ==================== -->
        <div class="control-group">
            <h3>ğŸ® ì‹œë®¬ë ˆì´ì…˜ ì œì–´</h3>
            <div class="btn-group">
                <button class="action-btn btn-start" id="btnStart">â–¶ ë°œì‚¬</button>
                <button class="action-btn btn-stop" id="btnStop">â¸ ì •ì§€</button>
                <button class="action-btn btn-reset" id="btnReset">â†º ë¦¬ì…‹</button>
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="activeRays">0</div>
                    <div class="stat-label">í™œì„± ê´‘ì„ </div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="reflectedCount">0</div>
                    <div class="stat-label">ì´ ë°˜ì‚¬</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="focusPassCount">0</div>
                    <div class="stat-label">ì´ˆì  í†µê³¼</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="completedCount">0</div>
                    <div class="stat-label">ì™„ë£Œ</div>
                </div>
            </div>
        </div>

        <!-- ==================== ê³¡ì„  ì„ íƒ ==================== -->
        <div class="control-group">
            <h3>ğŸ“ ê³¡ì„  ìœ í˜• ì„ íƒ</h3>
            <div class="mode-buttons">
                <button class="mode-btn active" data-mode="parabola">í¬ë¬¼ì„ </button>
                <button class="mode-btn" data-mode="ellipse">íƒ€ì›</button>
                <button class="mode-btn" data-mode="hyperbola">ìŒê³¡ì„ </button>
            </div>
        </div>

        <!-- ==================== ë§¤ê°œë³€ìˆ˜ ì¡°ì ˆ ==================== -->
        <div class="control-group">
            <h3>âš™ï¸ ë§¤ê°œë³€ìˆ˜ ì¡°ì ˆ</h3>
            <div class="slider-container">
                <label>
                    <span class="slider-label" id="paramLabel">ì´ˆì  ê±°ë¦¬ (f)</span>
                    <span id="fValue">2.00</span>
                </label>
                <input type="range" id="focalLength" min="0.5" max="5" step="0.1" value="2">
            </div>
            <div class="slider-container">
                <label>
                    ê´‘ì„  ê°œìˆ˜
                    <span id="rayCountValue">12</span>
                </label>
                <input type="range" id="rayCount" min="4" max="48" step="2" value="12">
            </div>
            <div class="slider-container">
                <label>
                    ê´‘ì„  ì†ë„
                    <span id="speedValue">2.0</span>
                </label>
                <input type="range" id="raySpeed" min="0.5" max="6" step="0.25" value="2">
            </div>
            <div class="slider-container">
                <label>
                    ìµœëŒ€ ë°˜ì‚¬ íšŸìˆ˜
                    <span id="maxBounceValue">20</span>
                </label>
                <input type="range" id="maxBounce" min="1" max="50" step="1" value="20">
            </div>
            <div class="slider-container">
                <label>
                    í™•ëŒ€/ì¶•ì†Œ
                    <span id="scaleValue">40</span>
                </label>
                <input type="range" id="scale" min="20" max="100" step="5" value="40">
            </div>
        </div>

        <!-- ==================== ì‹œê°í™” ì˜µì…˜ ==================== -->
        <div class="control-group">
            <h3>ğŸ‘ï¸ ì‹œê°í™” ì˜µì…˜</h3>
            <label class="checkbox-container">
                <input type="checkbox" id="showGrid" checked>
                ì¢Œí‘œê³„ ë° ê·¸ë¦¬ë“œ í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showTrail" checked>
                ê´‘ì„  ê¶¤ì  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showReflectPoints" checked>
                ë°˜ì‚¬ ì§€ì  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showDragPoint" checked>
                ë“œë˜ê·¸ ì  P í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showTangentNormal" checked>
                ì ‘ì„ /ë²•ì„  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showAngles" checked>
                ì…ì‚¬ê°/ë°˜ì‚¬ê° í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showGlow" checked>
                ê¸€ë¡œìš° íš¨ê³¼
            </label>
        </div>

        <!-- ==================== ìˆ˜í•™ì  ê³µì‹ ==================== -->
        <div class="control-group">
            <h3>ğŸ“Š ìˆ˜í•™ì  ê³µì‹</h3>
            <div class="info-box">
                <div class="formula" id="formulaDisplay">y = xÂ² / 4f</div>
                <div id="curveDescription">
                    <strong>í¬ë¬¼ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                    ì¶•ì— í‰í–‰í•˜ê²Œ ì…ì‚¬í•˜ëŠ” ëª¨ë“  ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ì´ˆì  Fë¥¼ ì§€ë‚˜ê°‘ë‹ˆë‹¤.
                    í¬ë¬¼ì„ ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë°˜ì‚¬ë˜ì–´ ì´ˆì ì„ ë°˜ë³µ í†µê³¼í•©ë‹ˆë‹¤.
                </div>
            </div>
        </div>

        <!-- ==================== ì  P ì‹¤ì‹œê°„ ë°ì´í„° ==================== -->
        <div class="control-group">
            <h3>ğŸ“ ë“œë˜ê·¸ ì  P ì •ë³´</h3>
            <div class="live-data">
                <div class="row">
                    <span class="label">ì  P ì¢Œí‘œ:</span>
                    <span class="value" id="pointP">(2.00, 0.50)</span>
                </div>
                <div class="row">
                    <span class="label">ì ‘ì„  ê¸°ìš¸ê¸° (m):</span>
                    <span class="value" id="tangentSlope">0.500</span>
                </div>
                <div class="row">
                    <span class="label">ë²•ì„  ê¸°ìš¸ê¸°:</span>
                    <span class="value" id="normalSlope">-2.000</span>
                </div>
                <div class="row">
                    <span class="label">ì…ì‚¬ê° Î¸â‚:</span>
                    <span class="value" id="incidentAngle">26.57Â°</span>
                </div>
                <div class="row">
                    <span class="label">ë°˜ì‚¬ê° Î¸â‚‚:</span>
                    <span class="value" id="reflectAngle">26.57Â°</span>
                </div>
                <div class="row">
                    <span class="label">ê²€ì¦:</span>
                    <span class="highlight" id="verification">Î¸â‚ = Î¸â‚‚ âœ“</span>
                </div>
            </div>
        </div>

        <!-- ==================== ë²”ë¡€ ==================== -->
        <div class="control-group">
            <h3>ğŸ¨ ë²”ë¡€</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b; color: #ff6b6b;"></div>
                    <span>ê³¡ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d; color: #ffd93d;"></div>
                    <span>ì…ì‚¬ê´‘ / ì´ˆì  ì „</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff88; color: #00ff88;"></div>
                    <span>ë°˜ì‚¬ê´‘ / ì´ˆì  í›„</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d9ff; color: #00d9ff;"></div>
                    <span>ë°˜ì‚¬ ì§€ì </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4; color: #4ecdc4;"></div>
                    <span>ì ‘ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #a855f7; color: #a855f7;"></div>
                    <span>ë²•ì„ </span>
                </div>
            </div>
        </div>

        <!-- ==================== ì´ë¡ ì  ë°°ê²½ ==================== -->
        <div class="control-group">
            <h3>ğŸ“š ì´ë¡ ì  ë°°ê²½</h3>
            <p class="theory-text" id="theoryText">
                <strong>V. Ivchenkoì˜ í•´ì„ì  ì¦ëª…:</strong><br><br>
                ë¯¸ë¶„ë°©ì •ì‹ì„ ì´ìš©í•˜ì—¬ ë°˜ì‚¬ì˜ ë²•ì¹™(ì…ì‚¬ê° = ë°˜ì‚¬ê°)ì„ ë§Œì¡±í•˜ë©´ì„œ 
                í‰í–‰ê´‘ì„ ì´ í•œ ì ìœ¼ë¡œ ëª¨ì´ëŠ” ìœ ì¼í•œ ê³¡ì„ ì´ 
                <span class="highlight">y = xÂ²/4f</span> ì„ì„ ì¦ëª…í–ˆìŠµë‹ˆë‹¤.<br><br>
                ğŸ“ ì  Pì—ì„œì˜ ì ‘ì„  ê¸°ìš¸ê¸°: <span class="highlight">m = x/(2f)</span><br>
                ğŸ“ ë²•ì„ ì€ ì ‘ì„ ì— ìˆ˜ì§: <span class="highlight">m_n = -2f/x</span><br>
                ğŸ“ ë¹¨ê°„ ì  Pë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì‹¤ì‹œê°„ ê²€ì¦!<br><br>
                <strong>ë‹¤ì¤‘ ë°˜ì‚¬:</strong> ê´‘ì„ ì´ ê³¡ì„ ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë¬´ì¡°ê±´ ë°˜ì‚¬ë˜ë©°, 
                í¬ë¬¼ì„ ì˜ ê²½ìš° ë§¤ë²ˆ ì´ˆì ì„ í†µê³¼í•©ë‹ˆë‹¤.
            </p>
        </div>
    </div>

    <!-- ==================== ìº”ë²„ìŠ¤ ì˜ì—­ ==================== -->
    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
        <div class="canvas-info">
            ğŸ’¡ <span>ë¹¨ê°„ ì  P</span>ë¥¼ ë“œë˜ê·¸í•˜ì—¬ ê¸°í•˜í•™ì  ì„±ì§ˆì„ í™•ì¸í•˜ì„¸ìš”
        </div>
    </div>

    <script>
        // ============================================
        // í¬ë¬¼ì„  ê±°ìš¸ ë°˜ì‚¬ ì„±ì§ˆ ì‹œë®¬ë ˆì´í„°
        // ë¬´í•œ ë°˜ì‚¬ ë³´ì¥ ë²„ì „
        // ============================================

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // ìƒíƒœ ê´€ë¦¬
        // ============================================
        const state = {
            // ê³¡ì„  íŒŒë¼ë¯¸í„°
            f: 2.0,
            a: 5,
            b: 3,
            
            // ë·° ì„¤ì •
            scale: 40,
            centerX: 0,
            centerY: 0,
            
            // ì‹œë®¬ë ˆì´ì…˜ ì„¤ì •
            mode: 'parabola',
            raySpeed: 2.0,
            rayCount: 12,
            maxBounce: 20,
            isRunning: false,
            
            // ì‹œê°í™” ì˜µì…˜
            showGrid: true,
            showTrail: true,
            showReflectPoints: true,
            showDragPoint: true,
            showTangentNormal: true,
            showAngles: true,
            showGlow: true,
            
            // ë“œë˜ê·¸ ì  P
            pointP: { x: 2, y: 0 },
            isDragging: false,
            
            // í†µê³„
            totalReflections: 0,
            focusPassCount: 0,
            completedCount: 0
        };

        let rays = [];
        let animationId = null;

        // ============================================
        // ê´‘ì„  í´ë˜ìŠ¤ - ê°œì„ ëœ ë‹¤ì¤‘ ë°˜ì‚¬
        // ============================================
        class Ray {
            constructor(x, y, dx, dy, index, total) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.speed = 0.04;
                this.bounces = 0;
                this.active = true;
                
                // ê²½ë¡œ ì €ì¥
                this.segments = [];
                this.currentSegment = [{ x, y }];
                
                // ìƒ‰ìƒ
                this.colorIndex = 0;
                this.currentColor = 'yellow';
                
                const hueOffset = (index / total) * 30;
                this.colors = {
                    yellow: `hsla(${45 + hueOffset}, 100%, 55%, 0.9)`,
                    green: `hsla(${140 + hueOffset}, 100%, 50%, 0.9)`,
                    cyan: `hsla(${180 + hueOffset}, 100%, 55%, 0.9)`,
                    magenta: `hsla(${280 + hueOffset}, 100%, 60%, 0.9)`,
                    orange: `hsla(${20 + hueOffset}, 100%, 55%, 0.9)`
                };
                
                // íƒ€ì›ìš©
                this.ellipseState = 'toF2';
                
                // ë°˜ì‚¬ ì œì–´ (ê°œì„ ë¨)
                this.lastReflectPos = { x: null, y: null };
                this.stepsSinceReflect = 0;
            }

            update() {
                if (!this.active) return;

                const step = this.speed * state.raySpeed;
                this.stepsSinceReflect++;
                
                // ì´ì „ ìœ„ì¹˜ ì €ì¥
                const prevX = this.x;
                const prevY = this.y;
                
                // êµì°¨ì  ì°¾ê¸° (stepsSinceReflect >= 3ì¼ ë•Œë§Œ)
                let intersection = null;
                if (this.stepsSinceReflect >= 3) {
                    intersection = this.findIntersection();
                }
                
                if (intersection) {
                    const distToIntersect = Math.hypot(
                        intersection.x - this.x,
                        intersection.y - this.y
                    );

                    // êµì°¨ì ì— ì¶©ë¶„íˆ ê°€ê¹Œìš°ë©´ ë°˜ì‚¬
                    if (distToIntersect <= step * 1.5) {
                        // êµì°¨ì ìœ¼ë¡œ ì´ë™
                        this.x = intersection.x;
                        this.y = intersection.y;
                        this.currentSegment.push({ x: this.x, y: this.y });
                        
                        // ì„¸ê·¸ë¨¼íŠ¸ ì €ì¥
                        this.segments.push({
                            points: [...this.currentSegment],
                            color: this.currentColor
                        });
                        
                        // ë°˜ì‚¬ ìˆ˜í–‰
                        this.performReflection(intersection);
                        
                        // ìƒˆ ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘
                        this.currentSegment = [{ x: this.x, y: this.y }];
                        
                        return;
                    }
                }

                // ì¼ë°˜ ì´ë™
                this.x += this.dx * step;
                this.y += this.dy * step;

                // ì´ˆì  í†µê³¼ ì²´í¬
                this.checkFocusPass(prevX, prevY);

                // í™”ë©´ ë°– ì²´í¬
                this.checkBounds();
            }

            performReflection(intersection) {
                const { x: px, y: py, nx, ny } = intersection;
                
                // ë²•ì„  ë°©í–¥ ì¡°ì •
                let normalX = nx;
                let normalY = ny;
                const dotIn = this.dx * normalX + this.dy * normalY;
                if (dotIn > 0) {
                    normalX = -normalX;
                    normalY = -normalY;
                }
                
                // ë°˜ì‚¬ ê³µì‹
                const dot = this.dx * normalX + this.dy * normalY;
                this.dx = this.dx - 2 * dot * normalX;
                this.dy = this.dy - 2 * dot * normalY;
                
                // ì •ê·œí™”
                const len = Math.hypot(this.dx, this.dy);
                if (len > 0) {
                    this.dx /= len;
                    this.dy /= len;
                }
                
                // ë°˜ì‚¬ì ì—ì„œ ì•½ê°„ ë–¨ì–´ì§„ ìœ„ì¹˜ë¡œ ì´ë™
                this.x = px + this.dx * 0.25;
                this.y = py + this.dy * 0.25;
                
                // ê¸°ë¡
                this.lastReflectPos = { x: px, y: py };
                this.stepsSinceReflect = 0;
                this.bounces++;
                state.totalReflections++;
                
                // ìµœëŒ€ ë°˜ì‚¬ íšŸìˆ˜ ì²´í¬
                if (this.bounces >= state.maxBounce) {
                    this.finishRay();
                }
            }

            checkFocusPass(prevX, prevY) {
                const colorKeys = ['yellow', 'green', 'cyan', 'magenta', 'orange'];
                
                if (state.mode === 'parabola') {
                    const fx = 0, fy = state.f;
                    const dist = Math.hypot(this.x - fx, this.y - fy);
                    const prevDist = Math.hypot(prevX - fx, prevY - fy);
                    
                    // ì´ˆì  ê·¼ì²˜ë¥¼ ì§€ë‚˜ì³¤ëŠ”ì§€ ì²´í¬
                    if (dist < 0.6 && prevDist >= 0.6) {
                        this.switchColorAtFocus(fx, fy, colorKeys);
                    }
                } else if (state.mode === 'ellipse') {
                    const c = Math.sqrt(state.a * state.a - state.b * state.b);
                    const f1 = { x: -c, y: 0 };
                    const f2 = { x: c, y: 0 };
                    
                    if (this.ellipseState === 'toF2') {
                        const dist = Math.hypot(this.x - f2.x, this.y - f2.y);
                        const prevDist = Math.hypot(prevX - f2.x, prevY - f2.y);
                        if (dist < 0.7 && prevDist >= 0.7) {
                            this.switchColorAtFocus(f2.x, f2.y, colorKeys);
                            this.ellipseState = 'toF1';
                        }
                    } else {
                        const dist = Math.hypot(this.x - f1.x, this.y - f1.y);
                        const prevDist = Math.hypot(prevX - f1.x, prevY - f1.y);
                        if (dist < 0.7 && prevDist >= 0.7) {
                            this.switchColorAtFocus(f1.x, f1.y, colorKeys);
                            this.ellipseState = 'toF2';
                        }
                    }
                } else if (state.mode === 'hyperbola') {
                    const a = state.a / 2;
                    const c = Math.sqrt(a * a + state.b * state.b);
                    const f2 = { x: c, y: 0 };
                    
                    const dist = Math.hypot(this.x - f2.x, this.y - f2.y);
                    const prevDist = Math.hypot(prevX - f2.x, prevY - f2.y);
                    if (dist < 0.7 && prevDist >= 0.7 && this.colorIndex === 0) {
                        this.switchColorAtFocus(f2.x, f2.y, colorKeys);
                    }
                }
            }

            switchColorAtFocus(fx, fy, colorKeys) {
                this.currentSegment.push({ x: fx, y: fy });
                this.segments.push({
                    points: [...this.currentSegment],
                    color: this.currentColor
                });
                
                this.colorIndex++;
                this.currentColor = colorKeys[this.colorIndex % colorKeys.length];
                this.currentSegment = [{ x: fx, y: fy }];
                state.focusPassCount++;
            }

            checkBounds() {
                const margin = 20;
                if (Math.abs(this.x) > margin || Math.abs(this.y) > margin) {
                    this.finishRay();
                }
            }

            finishRay() {
                this.currentSegment.push({ x: this.x, y: this.y });
                this.segments.push({
                    points: [...this.currentSegment],
                    color: this.currentColor
                });
                this.active = false;
                state.completedCount++;
            }

            findIntersection() {
                if (state.mode === 'parabola') {
                    return this.findParabolaIntersection();
                } else if (state.mode === 'ellipse') {
                    return this.findEllipseIntersection();
                } else {
                    return this.findHyperbolaIntersection();
                }
            }

            findParabolaIntersection() {
                const f4 = 4 * state.f;
                
                // 2ì°¨ ë°©ì •ì‹: dxÂ²*tÂ² + (2*x*dx - 4f*dy)*t + (xÂ² - 4f*y) = 0
                const A = this.dx * this.dx;
                const B = 2 * this.x * this.dx - f4 * this.dy;
                const C = this.x * this.x - f4 * this.y;
                
                // ì‘ì€ ìµœì†Œ ê±°ë¦¬ (ë” ë¯¼ê°í•˜ê²Œ)
                const minT = 0.05;
                let solutions = [];
                
                if (Math.abs(A) < 1e-10) {
                    // ì„ í˜•
                    if (Math.abs(B) > 1e-10) {
                        const t = -C / B;
                        if (t > minT) solutions.push(t);
                    }
                } else {
                    const disc = B * B - 4 * A * C;
                    if (disc >= 0) {
                        const sqrtDisc = Math.sqrt(disc);
                        const t1 = (-B + sqrtDisc) / (2 * A);
                        const t2 = (-B - sqrtDisc) / (2 * A);
                        
                        if (t1 > minT) solutions.push(t1);
                        if (t2 > minT) solutions.push(t2);
                    }
                }
                
                if (solutions.length === 0) return null;
                
                // ê°€ì¥ ê°€ê¹Œìš´ êµì°¨ì  ì„ íƒ
                const t = Math.min(...solutions);
                const ix = this.x + this.dx * t;
                const iy = this.y + this.dy * t;
                
                // ë²”ìœ„ ì²´í¬
                if (Math.abs(ix) > 15 || iy < -1 || iy > 30) return null;
                
                // ë§ˆì§€ë§‰ ë°˜ì‚¬ì ê³¼ ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë¬´ì‹œ
                if (this.lastReflectPos.x !== null) {
                    const distFromLast = Math.hypot(
                        ix - this.lastReflectPos.x, 
                        iy - this.lastReflectPos.y
                    );
                    if (distFromLast < 0.2) return null;
                }
                
                // ë²•ì„  ê³„ì‚°
                const slope = ix / (2 * state.f);
                const nLen = Math.hypot(slope, 1);
                
                return {
                    x: ix, y: iy,
                    nx: -slope / nLen,
                    ny: 1 / nLen
                };
            }

            findEllipseIntersection() {
                const { a, b } = state;
                
                const A = (this.dx * this.dx) / (a * a) + (this.dy * this.dy) / (b * b);
                const B = 2 * ((this.x * this.dx) / (a * a) + (this.y * this.dy) / (b * b));
                const C = (this.x * this.x) / (a * a) + (this.y * this.y) / (b * b) - 1;
                
                const disc = B * B - 4 * A * C;
                if (disc < 0) return null;
                
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-B + sqrtDisc) / (2 * A);
                const t2 = (-B - sqrtDisc) / (2 * A);
                
                const minT = 0.05;
                const solutions = [t1, t2].filter(tt => tt > minT);
                if (solutions.length === 0) return null;
                
                const t = Math.min(...solutions);
                const ix = this.x + this.dx * t;
                const iy = this.y + this.dy * t;
                
                // ì¤‘ë³µ ì²´í¬
                if (this.lastReflectPos.x !== null) {
                    const distFromLast = Math.hypot(
                        ix - this.lastReflectPos.x, 
                        iy - this.lastReflectPos.y
                    );
                    if (distFromLast < 0.2) return null;
                }
                
                // ë²•ì„ 
                let nx = ix / (a * a);
                let ny = iy / (b * b);
                const nLen = Math.hypot(nx, ny);
                
                return {
                    x: ix, y: iy,
                    nx: nx / nLen,
                    ny: ny / nLen
                };
            }

            findHyperbolaIntersection() {
                const a = state.a / 2;
                const b = state.b;
                
                const A = (this.dx * this.dx) / (a * a) - (this.dy * this.dy) / (b * b);
                const B = 2 * ((this.x * this.dx) / (a * a) - (this.y * this.dy) / (b * b));
                const C = (this.x * this.x) / (a * a) - (this.y * this.y) / (b * b) - 1;
                
                if (Math.abs(A) < 1e-10) return null;
                
                const disc = B * B - 4 * A * C;
                if (disc < 0) return null;
                
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-B + sqrtDisc) / (2 * A);
                const t2 = (-B - sqrtDisc) / (2 * A);
                
                const minT = 0.05;
                
                for (const t of [t1, t2].filter(tt => tt > minT).sort((x, y) => x - y)) {
                    const ix = this.x + this.dx * t;
                    const iy = this.y + this.dy * t;
                    
                    if (ix >= a - 0.1) {
                        if (this.lastReflectPos.x !== null) {
                            const distFromLast = Math.hypot(
                                ix - this.lastReflectPos.x, 
                                iy - this.lastReflectPos.y
                            );
                            if (distFromLast < 0.2) continue;
                        }
                        
                        let nx = ix / (a * a);
                        let ny = -iy / (b * b);
                        const nLen = Math.hypot(nx, ny);
                        
                        return {
                            x: ix, y: iy,
                            nx: nx / nLen,
                            ny: ny / nLen
                        };
                    }
                }
                
                return null;
            }

            draw() {
                const getColor = (colorName) => this.colors[colorName] || this.colors.yellow;

                // ì €ì¥ëœ ì„¸ê·¸ë¨¼íŠ¸
                for (const segment of this.segments) {
                    if (segment.points.length < 2) continue;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = getColor(segment.color);
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    if (state.showGlow) {
                        ctx.shadowColor = getColor(segment.color);
                        ctx.shadowBlur = 8;
                    }
                    
                    const p0 = toCanvas(segment.points[0].x, segment.points[0].y);
                    ctx.moveTo(p0.x, p0.y);
                    
                    for (let i = 1; i < segment.points.length; i++) {
                        const p = toCanvas(segment.points[i].x, segment.points[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸
                if (this.currentSegment.length > 0 && state.showTrail) {
                    ctx.beginPath();
                    ctx.strokeStyle = getColor(this.currentColor);
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    
                    if (state.showGlow) {
                        ctx.shadowColor = getColor(this.currentColor);
                        ctx.shadowBlur = 8;
                    }
                    
                    const p0 = toCanvas(this.currentSegment[0].x, this.currentSegment[0].y);
                    ctx.moveTo(p0.x, p0.y);
                    
                    for (let i = 1; i < this.currentSegment.length; i++) {
                        const p = toCanvas(this.currentSegment[i].x, this.currentSegment[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                    
                    if (this.active) {
                        const pCur = toCanvas(this.x, this.y);
                        ctx.lineTo(pCur.x, pCur.y);
                    }
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }

                // ë°˜ì‚¬ ì§€ì 
                if (state.showReflectPoints) {
                    for (const segment of this.segments) {
                        if (segment.points.length > 1) {
                            const lastPoint = segment.points[segment.points.length - 1];
                            const pos = toCanvas(lastPoint.x, lastPoint.y);
                            
                            ctx.beginPath();
                            ctx.fillStyle = 'rgba(0, 212, 255, 0.9)';
                            if (state.showGlow) {
                                ctx.shadowColor = '#00d4ff';
                                ctx.shadowBlur = 10;
                            }
                            ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    }
                }

                // ê´‘ì„  ë¨¸ë¦¬
                if (this.active) {
                    const pos = toCanvas(this.x, this.y);
                    const colorMap = {
                        yellow: '#ffcc00',
                        green: '#00ff88',
                        cyan: '#00d9ff',
                        magenta: '#ff00ff',
                        orange: '#ff8800'
                    };
                    const headColor = colorMap[this.currentColor] || '#ffcc00';
                    
                    if (state.showGlow) {
                        const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 20);
                        gradient.addColorStop(0, headColor);
                        gradient.addColorStop(0.5, headColor + '88');
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.beginPath();
                        ctx.fillStyle = gradient;
                        ctx.arc(pos.x, pos.y, 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.beginPath();
                    ctx.fillStyle = '#fff';
                    ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // ë°©í–¥ í‘œì‹œ
                    ctx.beginPath();
                    ctx.strokeStyle = headColor;
                    ctx.lineWidth = 2;
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineTo(pos.x + this.dx * 15, pos.y - this.dy * 15);
                    ctx.stroke();
                }
            }
        }

        // ============================================
        // ìº”ë²„ìŠ¤ ì„¤ì •
        // ============================================
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxSize = Math.min(container.clientWidth - 40, container.clientHeight - 80, 850);
            canvas.width = maxSize;
            canvas.height = maxSize;
            state.centerX = canvas.width / 2;
            state.centerY = canvas.height / 2;
        }

        function toCanvas(x, y) {
            return {
                x: state.centerX + x * state.scale,
                y: state.centerY - y * state.scale
            };
        }

        function toMath(px, py) {
            return {
                x: (px - state.centerX) / state.scale,
                y: (state.centerY - py) / state.scale
            };
        }

        // ============================================
        // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
        // ============================================
        function drawGrid() {
            if (!state.showGrid) return;

            const w = canvas.width;
            const h = canvas.height;

            // ë³´ì¡° ê·¸ë¦¬ë“œ
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.12)';
            ctx.lineWidth = 0.5;
            const gridStep = state.scale / 2;
            
            for (let x = state.centerX % gridStep; x < w; x += gridStep) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % gridStep; y < h; y += gridStep) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì£¼ ê·¸ë¦¬ë“œ
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.25)';
            ctx.lineWidth = 1;
            
            for (let x = state.centerX % state.scale; x < w; x += state.scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % state.scale; y < h; y += state.scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì¢Œí‘œì¶•
            ctx.strokeStyle = 'rgba(150, 150, 180, 0.6)';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(0, state.centerY);
            ctx.lineTo(w, state.centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(state.centerX, 0);
            ctx.lineTo(state.centerX, h);
            ctx.stroke();

            // ì¶• ë¼ë²¨
            ctx.fillStyle = 'rgba(150, 150, 180, 0.8)';
            ctx.font = 'bold 14px Consolas, monospace';
            ctx.fillText('x', w - 20, state.centerY - 10);
            ctx.fillText('y', state.centerX + 10, 20);

            // ëˆˆê¸ˆ
            ctx.font = '11px Consolas, monospace';
            ctx.fillStyle = 'rgba(150, 150, 180, 0.6)';
            const range = Math.ceil(w / state.scale / 2);
            
            for (let i = -range; i <= range; i++) {
                if (i === 0) continue;
                const pos = toCanvas(i, 0);
                if (pos.x > 10 && pos.x < w - 10) {
                    ctx.fillText(i.toString(), pos.x - 4, pos.y + 16);
                }
            }
            for (let i = -range; i <= range; i++) {
                if (i === 0) continue;
                const pos = toCanvas(0, i);
                if (pos.y > 10 && pos.y < h - 10) {
                    ctx.fillText(i.toString(), pos.x + 6, pos.y + 4);
                }
            }
            
            ctx.fillStyle = 'rgba(150, 150, 180, 0.8)';
            ctx.fillText('O', state.centerX - 15, state.centerY + 16);
        }

        // ============================================
        // í¬ë¬¼ì„  ê·¸ë¦¬ê¸°
        // ============================================
        function drawParabola() {
            const range = canvas.width / state.scale;
            
            if (state.showGlow) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.2)';
                ctx.lineWidth = 16;
                ctx.beginPath();
                let first = true;
                for (let x = -range; x <= range; x += 0.1) {
                    const y = (x * x) / (4 * state.f);
                    const pos = toCanvas(x, y);
                    if (pos.y < -100 || pos.y > canvas.height + 100) continue;
                    if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                    else ctx.lineTo(pos.x, pos.y);
                }
                ctx.stroke();
            }

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 15;
            }
            
            ctx.beginPath();
            let first = true;
            for (let x = -range; x <= range; x += 0.05) {
                const y = (x * x) / (4 * state.f);
                const pos = toCanvas(x, y);
                if (pos.y < -100 || pos.y > canvas.height + 100) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            drawFocus(0, state.f, 'F', '#ffd93d');

            ctx.strokeStyle = 'rgba(255, 217, 61, 0.25)';
            ctx.lineWidth = 1;
            ctx.setLineDash([8, 8]);
            const directrix = toCanvas(0, -state.f);
            ctx.beginPath();
            ctx.moveTo(0, directrix.y);
            ctx.lineTo(canvas.width, directrix.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = 'rgba(255, 217, 61, 0.6)';
            ctx.font = '12px Arial';
            ctx.fillText('ì¤€ì„  (y = -f)', 10, directrix.y - 8);
        }

        // ============================================
        // íƒ€ì› ê·¸ë¦¬ê¸°
        // ============================================
        function drawEllipse() {
            const { a, b } = state;
            const c = Math.sqrt(Math.max(0, a * a - b * b));

            if (state.showGlow) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.15)';
                ctx.lineWidth = 18;
                ctx.beginPath();
                ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(255, 107, 107, 0.4)';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 12;
            }
            ctx.beginPath();
            ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            drawFocus(-c, 0, 'Fâ‚', '#ff006e');
            drawFocus(c, 0, 'Fâ‚‚', '#00ff88');

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            ctx.setLineDash([6, 6]);
            ctx.beginPath();
            ctx.moveTo(state.centerX - a * state.scale - 30, state.centerY);
            ctx.lineTo(state.centerX + a * state.scale + 30, state.centerY);
            ctx.moveTo(state.centerX, state.centerY - b * state.scale - 30);
            ctx.lineTo(state.centerX, state.centerY + b * state.scale + 30);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ============================================
        // ìŒê³¡ì„  ê·¸ë¦¬ê¸°
        // ============================================
        function drawHyperbola() {
            const a = state.a / 2;
            const b = state.b;
            const c = Math.sqrt(a * a + b * b);

            if (state.showGlow) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.15)';
                ctx.lineWidth = 15;
                ctx.beginPath();
                let first = true;
                for (let y = -12; y <= 12; y += 0.15) {
                    const x = a * Math.sqrt(1 + (y * y) / (b * b));
                    const pos = toCanvas(x, y);
                    if (pos.x > canvas.width + 50) continue;
                    if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                    else ctx.lineTo(pos.x, pos.y);
                }
                ctx.stroke();
            }

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 12;
            }
            ctx.beginPath();
            let first = true;
            for (let y = -12; y <= 12; y += 0.1) {
                const x = a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (pos.x > canvas.width + 50) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.strokeStyle = 'rgba(255, 107, 107, 0.25)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            first = true;
            for (let y = -12; y <= 12; y += 0.1) {
                const x = -a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (pos.x < -50) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            drawFocus(-c, 0, 'Fâ‚', '#ff006e');
            drawFocus(c, 0, 'Fâ‚‚', '#00ff88');

            ctx.strokeStyle = 'rgba(255, 217, 61, 0.15)';
            ctx.lineWidth = 1;
            ctx.setLineDash([6, 6]);
            const slope = b / a;
            ctx.beginPath();
            ctx.moveTo(0, state.centerY + 500 * slope);
            ctx.lineTo(canvas.width, state.centerY - 500 * slope);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, state.centerY - 500 * slope);
            ctx.lineTo(canvas.width, state.centerY + 500 * slope);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ============================================
        // ì´ˆì  ê·¸ë¦¬ê¸°
        // ============================================
        function drawFocus(x, y, label, color) {
            const pos = toCanvas(x, y);
            
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 35);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.25, color + 'cc');
            gradient.addColorStop(0.5, color + '55');
            gradient.addColorStop(1, 'transparent');
            
            ctx.beginPath();
            ctx.fillStyle = gradient;
            ctx.arc(pos.x, pos.y, 35, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = color;
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = color;
            ctx.shadowBlur = state.showGlow ? 10 : 0;
            ctx.fillText(label, pos.x, pos.y - 45);
            ctx.shadowBlur = 0;
        }

        // ============================================
        // ë“œë˜ê·¸ ì  P
        // ============================================
        function drawInteractivePointP() {
            if (!state.showDragPoint) return;

            const px = state.pointP.x;
            let py, tangentSlope, normalSlope;

            if (state.mode === 'parabola') {
                py = (px * px) / (4 * state.f);
                tangentSlope = px / (2 * state.f);
            } else if (state.mode === 'ellipse') {
                const { a, b } = state;
                const xClamped = Math.max(-a + 0.1, Math.min(a - 0.1, px));
                py = b * Math.sqrt(Math.max(0, 1 - (xClamped * xClamped) / (a * a)));
                if (py > 0.01) {
                    tangentSlope = -(b * b * xClamped) / (a * a * py);
                } else {
                    tangentSlope = Infinity;
                }
                state.pointP.x = xClamped;
            } else {
                const a = state.a / 2;
                const b = state.b;
                const xClamped = Math.max(a + 0.1, px);
                py = b * Math.sqrt(Math.max(0, (xClamped * xClamped) / (a * a) - 1));
                if (py > 0.01) {
                    tangentSlope = (b * b * xClamped) / (a * a * py);
                } else {
                    tangentSlope = 0;
                }
                state.pointP.x = xClamped;
            }

            state.pointP.y = py;
            normalSlope = isFinite(tangentSlope) && tangentSlope !== 0 ? -1 / tangentSlope : Infinity;
            
            const pos = toCanvas(state.pointP.x, py);

            // ì ‘ì„ 
            if (state.showTangentNormal && isFinite(tangentSlope)) {
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.setLineDash([10, 5]);
                
                if (state.showGlow) {
                    ctx.shadowColor = '#4ecdc4';
                    ctx.shadowBlur = 8;
                }
                
                const dx = 4;
                const p1 = toCanvas(state.pointP.x - dx, py - tangentSlope * dx);
                const p2 = toCanvas(state.pointP.x + dx, py + tangentSlope * dx);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#4ecdc4';
                ctx.font = '12px Arial';
                ctx.fillText('ì ‘ì„ ', p2.x + 10, p2.y - 10);
            }

            // ë²•ì„ 
            if (state.showTangentNormal && isFinite(normalSlope) && Math.abs(normalSlope) < 100) {
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                
                if (state.showGlow) {
                    ctx.shadowColor = '#a855f7';
                    ctx.shadowBlur = 8;
                }
                
                const dx = 2.5;
                const n1 = toCanvas(state.pointP.x - dx, py - normalSlope * dx);
                const n2 = toCanvas(state.pointP.x + dx, py + normalSlope * dx);
                
                ctx.beginPath();
                ctx.moveTo(n1.x, n1.y);
                ctx.lineTo(n2.x, n2.y);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.shadowBlur = 0;
                
                ctx.fillStyle = '#a855f7';
                ctx.font = '12px Arial';
                ctx.fillText('ë²•ì„ ', n2.x + 10, n2.y + 15);
            }

            // í¬ë¬¼ì„  ëª¨ë“œ: ì…ì‚¬ê´‘/ë°˜ì‚¬ê´‘
            if (state.mode === 'parabola') {
                const rayTop = toCanvas(state.pointP.x, py + 6);
                ctx.strokeStyle = '#ffd93d';
                ctx.lineWidth = 2.5;
                ctx.setLineDash([]);
                
                if (state.showGlow) {
                    ctx.shadowColor = '#ffd93d';
                    ctx.shadowBlur = 10;
                }
                
                ctx.beginPath();
                ctx.moveTo(rayTop.x, rayTop.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();

                const focus = toCanvas(0, state.f);
                ctx.strokeStyle = '#00ff88';
                
                if (state.showGlow) {
                    ctx.shadowColor = '#00ff88';
                    ctx.shadowBlur = 10;
                }
                
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(focus.x, focus.y);
                ctx.stroke();
                ctx.shadowBlur = 0;

                if (state.showAngles) {
                    drawAngleVisualization(state.pointP.x, py, tangentSlope);
                }
            }

            // ì  P
            ctx.fillStyle = '#ff6b6b';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 15;
            }
            
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('P (ë“œë˜ê·¸)', pos.x + 18, pos.y - 15);

            updateLiveData(state.pointP.x, py, tangentSlope, normalSlope);
        }

        // ============================================
        // ê°ë„ ì‹œê°í™”
        // ============================================
        function drawAngleVisualization(px, py, tangentSlope) {
            const pos = toCanvas(px, py);
            const radius = 45;
            
            const slope = px / (2 * state.f);
            const normalAngle = Math.atan2(1, -slope);
            const normalAngleCanvas = -normalAngle;
            
            const incidentAngleCanvas = Math.PI / 2;
            
            const toFocusX = 0 - px;
            const toFocusY = state.f - py;
            const reflectAngle = Math.atan2(-toFocusY, toFocusX);

            let theta1 = Math.abs(normalAngleCanvas - incidentAngleCanvas);
            if (theta1 > Math.PI) theta1 = 2 * Math.PI - theta1;
            if (theta1 > Math.PI / 2) theta1 = Math.PI - theta1;
            
            let theta2 = Math.abs(reflectAngle - normalAngleCanvas);
            if (theta2 > Math.PI) theta2 = 2 * Math.PI - theta2;
            if (theta2 > Math.PI / 2) theta2 = Math.PI - theta2;

            const theta1Deg = theta1 * 180 / Math.PI;
            const theta2Deg = theta2 * 180 / Math.PI;

            // ì…ì‚¬ê° í˜¸
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const startAngle1 = Math.min(normalAngleCanvas, incidentAngleCanvas);
            const endAngle1 = Math.max(normalAngleCanvas, incidentAngleCanvas);
            ctx.arc(pos.x, pos.y, radius, startAngle1, endAngle1);
            ctx.stroke();

            // ë°˜ì‚¬ê° í˜¸
            ctx.strokeStyle = 'rgba(0, 255, 136, 0.8)';
            ctx.beginPath();
            const startAngle2 = Math.min(normalAngleCanvas, reflectAngle);
            const endAngle2 = Math.max(normalAngleCanvas, reflectAngle);
            ctx.arc(pos.x, pos.y, radius - 12, startAngle2, endAngle2);
            ctx.stroke();

            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = '#ffd93d';
            const labelAngle1 = (normalAngleCanvas + incidentAngleCanvas) / 2;
            ctx.fillText('Î¸â‚', pos.x + Math.cos(labelAngle1) * (radius + 18), 
                        pos.y + Math.sin(labelAngle1) * (radius + 18));

            ctx.fillStyle = '#00ff88';
            const labelAngle2 = (normalAngleCanvas + reflectAngle) / 2;
            ctx.fillText('Î¸â‚‚', pos.x + Math.cos(labelAngle2) * (radius - 28), 
                        pos.y + Math.sin(labelAngle2) * (radius - 28));

            document.getElementById('incidentAngle').textContent = theta1Deg.toFixed(2) + 'Â°';
            document.getElementById('reflectAngle').textContent = theta2Deg.toFixed(2) + 'Â°';

            const diff = Math.abs(theta1Deg - theta2Deg);
            const verificationEl = document.getElementById('verification');
            if (diff < 0.5) {
                verificationEl.textContent = 'Î¸â‚ = Î¸â‚‚ âœ“';
                verificationEl.className = 'highlight';
            } else {
                verificationEl.textContent = `Î” = ${diff.toFixed(2)}Â°`;
                verificationEl.className = 'warning';
            }
        }

        function updateLiveData(px, py, tangentSlope, normalSlope) {
            document.getElementById('pointP').textContent = `(${px.toFixed(2)}, ${py.toFixed(2)})`;
            document.getElementById('tangentSlope').textContent = isFinite(tangentSlope) ? tangentSlope.toFixed(3) : 'âˆ';
            document.getElementById('normalSlope').textContent = isFinite(normalSlope) && Math.abs(normalSlope) < 1000 
                ? normalSlope.toFixed(3) : 'âˆ';
        }

        // ============================================
        // ê´‘ì„  ìƒì„±
        // ============================================
        function emitRays() {
            rays = [];
            state.totalReflections = 0;
            state.focusPassCount = 0;
            state.completedCount = 0;
            
            const count = state.rayCount;

            if (state.mode === 'parabola') {
                const spread = 8;
                for (let i = 0; i < count; i++) {
                    const x = count === 1 ? 0 : -spread / 2 + (spread * i) / (count - 1);
                    rays.push(new Ray(x, 12, 0, -1, i, count));
                }
            } else if (state.mode === 'ellipse') {
                const c = Math.sqrt(state.a * state.a - state.b * state.b);
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    rays.push(new Ray(-c, 0, Math.cos(angle), Math.sin(angle), i, count));
                }
            } else {
                const a = state.a / 2;
                const c = Math.sqrt(a * a + state.b * state.b);
                const f2 = { x: c, y: 0 };
                
                for (let i = 0; i < count; i++) {
                    const startY = count === 1 ? 0 : -6 + (12 * i) / (count - 1);
                    const startX = -12;
                    const dx = f2.x - startX;
                    const dy = f2.y - startY;
                    const len = Math.hypot(dx, dy);
                    rays.push(new Ray(startX, startY, dx / len, dy / len, i, count));
                }
            }
        }

        function updateStats() {
            const activeCount = rays.filter(r => r.active).length;
            document.getElementById('activeRays').textContent = activeCount;
            document.getElementById('reflectedCount').textContent = state.totalReflections;
            document.getElementById('focusPassCount').textContent = state.focusPassCount;
            document.getElementById('completedCount').textContent = state.completedCount;
            
            const statValue = document.querySelectorAll('.stat-value')[0];
            if (state.isRunning && activeCount > 0) {
                statValue.classList.add('running-indicator');
            } else {
                statValue.classList.remove('running-indicator');
            }
        }

        // ============================================
        // ë Œë”ë§ ë£¨í”„
        // ============================================
        function animate() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();

            switch (state.mode) {
                case 'parabola': drawParabola(); break;
                case 'ellipse': drawEllipse(); break;
                case 'hyperbola': drawHyperbola(); break;
            }

            for (const ray of rays) {
                if (state.isRunning) {
                    ray.update();
                }
                ray.draw();
            }

            drawInteractivePointP();
            updateStats();

            if (rays.length > 0 && !rays.some(r => r.active) && state.isRunning) {
                state.isRunning = false;
                document.getElementById('btnStart').textContent = 'â–¶ ë°œì‚¬';
            }

            animationId = requestAnimationFrame(animate);
        }

        // ============================================
        // ì»¨íŠ¸ë¡¤
        // ============================================
        function toggleSimulation() {
            if (state.isRunning) {
                state.isRunning = false;
                document.getElementById('btnStart').textContent = 'â–¶ ê³„ì†';
            } else {
                if (rays.length === 0 || rays.every(r => !r.active)) {
                    emitRays();
                }
                state.isRunning = true;
                document.getElementById('btnStart').textContent = 'â¸ ì¼ì‹œì •ì§€';
            }
        }

        function stopSimulation() {
            state.isRunning = false;
            document.getElementById('btnStart').textContent = 'â–¶ ë°œì‚¬';
        }

        function resetSimulation() {
            stopSimulation();
            rays = [];
            state.totalReflections = 0;
            state.focusPassCount = 0;
            state.completedCount = 0;
            updateStats();
        }

        // ============================================
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        // ============================================
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        canvas.addEventListener('mousedown', (e) => {
            if (!state.showDragPoint) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const pPos = toCanvas(state.pointP.x, state.pointP.y);
            const dist = Math.hypot(mouseX - pPos.x, mouseY - pPos.y);
            
            if (dist < 30) {
                state.isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const math = toMath(mouseX, 0);
            
            let newX = math.x;
            if (state.mode === 'parabola') {
                newX = Math.max(-8, Math.min(8, newX));
            } else if (state.mode === 'ellipse') {
                newX = Math.max(-state.a + 0.2, Math.min(state.a - 0.2, newX));
            } else {
                newX = Math.max(state.a / 2 + 0.2, Math.min(10, newX));
            }
            
            state.pointP.x = newX;
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        canvas.addEventListener('mouseleave', () => {
            state.isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        // í„°ì¹˜ ì´ë²¤íŠ¸
        canvas.addEventListener('touchstart', (e) => {
            if (!state.showDragPoint) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            const pPos = toCanvas(state.pointP.x, state.pointP.y);
            const dist = Math.hypot(touchX - pPos.x, touchY - pPos.y);
            
            if (dist < 50) {
                state.isDragging = true;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            if (!state.isDragging) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const math = toMath(touchX, 0);
            
            let newX = math.x;
            if (state.mode === 'parabola') {
                newX = Math.max(-8, Math.min(8, newX));
            } else if (state.mode === 'ellipse') {
                newX = Math.max(-state.a + 0.2, Math.min(state.a - 0.2, newX));
            } else {
                newX = Math.max(state.a / 2 + 0.2, Math.min(10, newX));
            }
            
            state.pointP.x = newX;
        });

        canvas.addEventListener('touchend', () => {
            state.isDragging = false;
        });

        // ë²„íŠ¼
        document.getElementById('btnStart').addEventListener('click', toggleSimulation);
        document.getElementById('btnStop').addEventListener('click', stopSimulation);
        document.getElementById('btnReset').addEventListener('click', resetSimulation);

        // ìŠ¬ë¼ì´ë”
        document.getElementById('focalLength').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            
            if (state.mode === 'parabola') {
                state.f = value;
                document.getElementById('fValue').textContent = value.toFixed(2);
            } else if (state.mode === 'ellipse') {
                state.a = 5;
                const ecc = value / 5;
                state.b = state.a * Math.sqrt(1 - ecc * ecc);
                document.getElementById('fValue').textContent = ecc.toFixed(2);
            } else {
                state.a = value * 2;
                state.b = value;
                document.getElementById('fValue').textContent = value.toFixed(2);
            }
            
            resetSimulation();
        });

        document.getElementById('rayCount').addEventListener('input', (e) => {
            state.rayCount = parseInt(e.target.value);
            document.getElementById('rayCountValue').textContent = state.rayCount;
        });

        document.getElementById('raySpeed').addEventListener('input', (e) => {
            state.raySpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = state.raySpeed.toFixed(1);
        });

        document.getElementById('maxBounce').addEventListener('input', (e) => {
            state.maxBounce = parseInt(e.target.value);
            document.getElementById('maxBounceValue').textContent = state.maxBounce;
        });

        document.getElementById('scale').addEventListener('input', (e) => {
            state.scale = parseInt(e.target.value);
            document.getElementById('scaleValue').textContent = state.scale;
        });

        // ì²´í¬ë°•ìŠ¤
        document.getElementById('showGrid').addEventListener('change', (e) => state.showGrid = e.target.checked);
        document.getElementById('showTrail').addEventListener('change', (e) => state.showTrail = e.target.checked);
        document.getElementById('showReflectPoints').addEventListener('change', (e) => state.showReflectPoints = e.target.checked);
        document.getElementById('showDragPoint').addEventListener('change', (e) => state.showDragPoint = e.target.checked);
        document.getElementById('showTangentNormal').addEventListener('change', (e) => state.showTangentNormal = e.target.checked);
        document.getElementById('showAngles').addEventListener('change', (e) => state.showAngles = e.target.checked);
        document.getElementById('showGlow').addEventListener('change', (e) => state.showGlow = e.target.checked);

        // ëª¨ë“œ ë²„íŠ¼
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.mode = e.target.dataset.mode;
                
                resetSimulation();
                updateCurveInfo();
                updateSliderForMode();
                
                if (state.mode === 'parabola') {
                    state.pointP.x = 2;
                } else if (state.mode === 'ellipse') {
                    state.pointP.x = 2;
                } else {
                    state.pointP.x = 3;
                }
            });
        });

        function updateSliderForMode() {
            const slider = document.getElementById('focalLength');
            const label = document.getElementById('paramLabel');
            
            if (state.mode === 'parabola') {
                slider.min = 0.5;
                slider.max = 5;
                slider.step = 0.1;
                slider.value = 2;
                state.f = 2;
                label.textContent = 'ì´ˆì  ê±°ë¦¬ (f)';
                document.getElementById('fValue').textContent = '2.00';
            } else if (state.mode === 'ellipse') {
                slider.min = 0.5;
                slider.max = 4.5;
                slider.step = 0.1;
                slider.value = 3;
                state.a = 5;
                state.b = state.a * Math.sqrt(1 - 0.36);
                label.textContent = 'ì´ì‹¬ë¥  (e)';
                document.getElementById('fValue').textContent = '0.60';
            } else {
                slider.min = 1;
                slider.max = 4;
                slider.step = 0.25;
                slider.value = 2;
                state.a = 4;
                state.b = 2;
                label.textContent = 'í¬ê¸° (a)';
                document.getElementById('fValue').textContent = '2.00';
            }
        }

        function updateCurveInfo() {
            const formula = document.getElementById('formulaDisplay');
            const desc = document.getElementById('curveDescription');
            const theory = document.getElementById('theoryText');

            switch (state.mode) {
                case 'parabola':
                    formula.textContent = 'y = xÂ² / 4f';
                    desc.innerHTML = '<strong>í¬ë¬¼ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>ì¶•ì— í‰í–‰í•˜ê²Œ ì…ì‚¬í•˜ëŠ” ëª¨ë“  ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ì´ˆì  Fë¥¼ ì§€ë‚˜ê°‘ë‹ˆë‹¤. í¬ë¬¼ì„ ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë°˜ì‚¬ë˜ì–´ ì´ˆì ì„ ë°˜ë³µ í†µê³¼í•©ë‹ˆë‹¤.';
                    theory.innerHTML = `<strong>V. Ivchenkoì˜ í•´ì„ì  ì¦ëª…:</strong><br><br>
                        ë¯¸ë¶„ë°©ì •ì‹ì„ ì´ìš©í•˜ì—¬ ë°˜ì‚¬ì˜ ë²•ì¹™(ì…ì‚¬ê° = ë°˜ì‚¬ê°)ì„ ë§Œì¡±í•˜ë©´ì„œ 
                        í‰í–‰ê´‘ì„ ì´ í•œ ì ìœ¼ë¡œ ëª¨ì´ëŠ” ìœ ì¼í•œ ê³¡ì„ ì´ 
                        <span class="highlight">y = xÂ²/4f</span> ì„ì„ ì¦ëª…í–ˆìŠµë‹ˆë‹¤.<br><br>
                        ğŸ“ ì  Pì—ì„œì˜ ì ‘ì„  ê¸°ìš¸ê¸°: <span class="highlight">m = x/(2f)</span><br>
                        ğŸ“ ë²•ì„ ì€ ì ‘ì„ ì— ìˆ˜ì§: <span class="highlight">m_n = -2f/x</span><br>
                        ğŸ“ ë¹¨ê°„ ì  Pë¥¼ ë“œë˜ê·¸í•˜ì—¬ ì‹¤ì‹œê°„ ê²€ì¦!<br><br>
                        <strong>ë‹¤ì¤‘ ë°˜ì‚¬:</strong> ê´‘ì„ ì´ ê³¡ì„ ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë¬´ì¡°ê±´ ë°˜ì‚¬ë˜ë©°, 
                        í¬ë¬¼ì„ ì˜ ê²½ìš° ë§¤ë²ˆ ì´ˆì ì„ í†µê³¼í•©ë‹ˆë‹¤.`;
                    break;
                    
                case 'ellipse':
                    formula.textContent = 'xÂ²/aÂ² + yÂ²/bÂ² = 1';
                    desc.innerHTML = '<strong>íƒ€ì› (Whispering Gallery):</strong><br>Fâ‚ì—ì„œ ì¶œë°œí•œ ê´‘ì„ ì´ Fâ‚‚ë¥¼ ê±°ì³ ë‹¤ì‹œ Fâ‚ìœ¼ë¡œ ëŒì•„ì˜µë‹ˆë‹¤.';
                    theory.innerHTML = `<strong>íƒ€ì›ì˜ ì†ì‚­ì„ì˜ ë°©:</strong><br><br>
                        íƒ€ì› ë‚´ë¶€ì—ì„œ í•œ ì´ˆì ì—ì„œ ë‚˜ì˜¨ ëª¨ë“  ê´‘ì„ ì€ ë‹¤ë¥¸ ì´ˆì ì„ í†µê³¼í•©ë‹ˆë‹¤.<br><br>
                        ğŸ“ Fâ‚ â†’ Fâ‚‚ (ë…¸ë€ìƒ‰) â†’ Fâ‚ (ì´ˆë¡ìƒ‰) ìˆœí™˜<br>
                        ğŸ“ ìŒí–¥í•™ì  ì‘ìš©: ì†ì‚­ì„ì˜ ë°© íš¨ê³¼<br>
                        ğŸ“ ê´‘ì„ ì´ íƒ€ì›ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë°˜ì‚¬ë©ë‹ˆë‹¤.`;
                    break;
                    
                case 'hyperbola':
                    formula.textContent = 'xÂ²/aÂ² - yÂ²/bÂ² = 1';
                    desc.innerHTML = '<strong>ìŒê³¡ì„  ë°˜ì‚¬:</strong><br>Fâ‚‚ë¥¼ í–¥í•˜ëŠ” ê´‘ì„ ì´ ë°˜ì‚¬ í›„ Fâ‚ì—ì„œ ë°œì‚°í•˜ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤.';
                    theory.innerHTML = `<strong>ìŒê³¡ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br><br>
                        í•œ ì´ˆì ì„ í–¥í•˜ëŠ” ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ë‹¤ë¥¸ ì´ˆì ì—ì„œ ë°œì‚°í•˜ëŠ” ê²ƒì²˜ëŸ¼ í–‰ë™í•©ë‹ˆë‹¤.<br><br>
                        ğŸ“ ì¹´ì„¸ê·¸ë ˆì¸ ë§ì›ê²½ì˜ ì›ë¦¬<br>
                        ğŸ“ Fâ‚‚ë¥¼ í–¥í•œ ê´‘ì„  â†’ ë°˜ì‚¬ â†’ Fâ‚ ë°©í–¥ìœ¼ë¡œ<br>
                        ğŸ“ ìŒê³¡ì„ ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë°˜ì‚¬ë©ë‹ˆë‹¤.`;
                    break;
            }
        }

        // ì´ˆê¸°í™”
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();
    </script>
</body>
</html>
