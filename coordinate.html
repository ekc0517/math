<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í¬ë¬¼ì„  ê±°ìš¸ì˜ ë°˜ì‚¬ ì„±ì§ˆ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
        }

        .control-panel {
            width: 320px;
            min-width: 320px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #00d9ff;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 1px solid #0f3460;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .control-group {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #0f3460;
        }

        .control-group h3 {
            font-size: 0.95em;
            color: #ffd93d;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #ffd93d;
            border-radius: 50%;
        }

        .slider-container {
            margin-bottom: 12px;
        }

        .slider-container label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85em;
            color: #ccc;
        }

        .slider-container label span {
            color: #00d9ff;
            font-weight: bold;
            font-family: 'Consolas', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #0f3460, #00d9ff);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ffd93d;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 217, 61, 0.5);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.85em;
            cursor: pointer;
        }

        .checkbox-container input {
            width: 18px;
            height: 18px;
            accent-color: #00d9ff;
            cursor: pointer;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .action-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-start {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-start:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-reset {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            color: white;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8em;
            line-height: 1.6;
        }

        .info-box .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
            color: #ffd93d;
            text-align: center;
            margin: 10px 0;
            font-style: italic;
        }

        .live-data {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 0.75em;
            line-height: 1.8;
        }

        .live-data .label {
            color: #888;
        }

        .live-data .value {
            color: #00d9ff;
        }

        .live-data .highlight {
            color: #ffd93d;
            font-weight: bold;
        }

        .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 80px;
            padding: 10px 8px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #ccc;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: #1a4a7a;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00d9ff, #0f3460);
            color: white;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
        }

        .theory-text {
            font-size: 0.78em;
            line-height: 1.7;
            color: #aaa;
            text-align: justify;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: #0d1421;
        }

        #mainCanvas {
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.2);
            cursor: crosshair;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.75em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4em;
            color: #00d9ff;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
        }

        @media (max-width: 900px) {
            body {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                min-width: auto;
                max-height: 40vh;
                border-right: none;
                border-bottom: 2px solid #0f3460;
            }
            .canvas-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <h1 class="panel-title">ğŸ”­ í¬ë¬¼ì„  ê±°ìš¸ ì‹œë®¬ë ˆì´í„°</h1>

        <!-- ì‹œë®¬ë ˆì´ì…˜ ì»¨íŠ¸ë¡¤ -->
        <div class="control-group">
            <h3>ì‹œë®¬ë ˆì´ì…˜ ì œì–´</h3>
            <div class="btn-group">
                <button class="action-btn btn-start" id="btnStart">â–¶ ì‹œì‘</button>
                <button class="action-btn btn-stop" id="btnStop">â¸ ì •ì§€</button>
                <button class="action-btn btn-reset" id="btnReset">â†º ë¦¬ì…‹</button>
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="activeRays">0</div>
                    <div class="stat-label">í™œì„± ê´‘ì„ </div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="reflectedCount">0</div>
                    <div class="stat-label">ë°˜ì‚¬ëœ ê´‘ì„ </div>
                </div>
            </div>
        </div>

        <!-- ê¸°ë³¸ ì»¨íŠ¸ë¡¤ -->
        <div class="control-group">
            <h3>ë§¤ê°œë³€ìˆ˜ ì¡°ì ˆ</h3>
            <div class="slider-container">
                <label>ì´ˆì  ê±°ë¦¬ (f): <span id="fValue">2.0</span></label>
                <input type="range" id="focalLength" min="0.5" max="5" step="0.1" value="2">
            </div>
            <div class="slider-container">
                <label>ê´‘ì„  ì†ë„: <span id="speedValue">3</span></label>
                <input type="range" id="raySpeed" min="1" max="8" step="0.5" value="3">
            </div>
            <div class="slider-container">
                <label>ë°œì‚¬ ê°„ê²© (ms): <span id="intervalValue">300</span></label>
                <input type="range" id="spawnInterval" min="50" max="1000" step="50" value="300">
            </div>
            <div class="slider-container">
                <label>ê´‘ì„  í­: <span id="widthValue">6</span></label>
                <input type="range" id="rayWidth" min="2" max="10" step="1" value="6">
            </div>
            <div class="slider-container">
                <label>í™•ëŒ€/ì¶•ì†Œ: <span id="scaleValue">50</span></label>
                <input type="range" id="scale" min="20" max="100" step="5" value="50">
            </div>
        </div>

        <!-- ì‹œê°í™” ì˜µì…˜ -->
        <div class="control-group">
            <h3>ì‹œê°í™” ì˜µì…˜</h3>
            <label class="checkbox-container">
                <input type="checkbox" id="showGrid" checked>
                ì¢Œí‘œê³„ ë° ê·¸ë¦¬ë“œ í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showTrail" checked>
                ê´‘ì„  ê¶¤ì  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showTangent" checked>
                ì ‘ì„ /ë²•ì„  í‘œì‹œ (ë“œë˜ê·¸ ì )
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showAngles" checked>
                ê°ë„ í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showGlow" checked>
                ê¸€ë¡œìš° íš¨ê³¼
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="randomSpawn">
                ëœë¤ ìœ„ì¹˜ ë°œì‚¬
            </label>
        </div>

        <!-- ê³¡ì„  ì„ íƒ -->
        <div class="control-group">
            <h3>ê³¡ì„  ìœ í˜• ì„ íƒ</h3>
            <div class="mode-buttons">
                <button class="mode-btn active" data-mode="parabola">í¬ë¬¼ì„ </button>
                <button class="mode-btn" data-mode="ellipse">íƒ€ì›</button>
                <button class="mode-btn" data-mode="hyperbola">ìŒê³¡ì„ </button>
            </div>
        </div>

        <!-- ìˆ˜í•™ì  ì •ë³´ -->
        <div class="control-group">
            <h3>ìˆ˜í•™ì  ê³µì‹</h3>
            <div class="info-box">
                <div class="formula" id="formulaDisplay">y = xÂ² / 4f</div>
                <div id="curveDescription">
                    <strong>í¬ë¬¼ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                    ì¶•ì— í‰í–‰í•˜ê²Œ ì…ì‚¬í•˜ëŠ” ëª¨ë“  ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ì´ˆì  Fë¥¼ ì§€ë‚˜ê°‘ë‹ˆë‹¤.
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ë°ì´í„° -->
        <div class="control-group">
            <h3>ë“œë˜ê·¸ ì  P ì •ë³´</h3>
            <div class="live-data" id="liveData">
                <div><span class="label">ì  P ì¢Œí‘œ:</span> <span class="value" id="pointP">(-, -)</span></div>
                <div><span class="label">ì ‘ì„  ê¸°ìš¸ê¸°:</span> <span class="value" id="tangentSlope">-</span></div>
                <div><span class="label">ì…ì‚¬ê° Î¸â‚:</span> <span class="value" id="incidentAngle">-</span></div>
                <div><span class="label">ë°˜ì‚¬ê° Î¸â‚‚:</span> <span class="value" id="reflectAngle">-</span></div>
                <div><span class="label">ê²€ì¦:</span> <span class="highlight" id="verification">Î¸â‚ = Î¸â‚‚ âœ“</span></div>
            </div>
        </div>

        <!-- ë²”ë¡€ -->
        <div class="control-group">
            <h3>ë²”ë¡€</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>í¬ë¬¼ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>ì…ì‚¬ê´‘</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d9ff;"></div>
                    <span>ë°˜ì‚¬ê´‘</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>ì ‘ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #a855f7;"></div>
                    <span>ë²•ì„ </span>
                </div>
            </div>
        </div>

        <!-- ì´ë¡  ì„¤ëª… -->
        <div class="control-group">
            <h3>ì´ë¡ ì  ë°°ê²½</h3>
            <p class="theory-text" id="theoryText">
                <strong>V. Ivchenkoì˜ í•´ì„ì  ì¦ëª…:</strong><br><br>
                í¬ë¬¼ì„  y = xÂ²/4fëŠ” í‰í–‰ê´‘ì„ ì´ í•œ ì (ì´ˆì )ìœ¼ë¡œ ëª¨ì´ëŠ” ìœ ì¼í•œ ê³¡ì„ ì…ë‹ˆë‹¤.<br><br>
                ğŸ“ ë°˜ì‚¬ ë²•ì¹™: ì…ì‚¬ê° = ë°˜ì‚¬ê°<br>
                ğŸ“ ì ‘ì„  ê¸°ìš¸ê¸°: m = x/(2f)<br>
                ğŸ“ ê´‘ì„ ì„ ë“œë˜ê·¸í•˜ì—¬ ì‹¤ì‹œê°„ ê²€ì¦!
            </p>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <script>
        // ============================================
        // í¬ë¬¼ì„  ê±°ìš¸ ë°˜ì‚¬ ì‹œë®¬ë ˆì´í„°
        // ê´‘ì„  ë¬¼ë¦¬ ì‹œë®¬ë ˆì´ì…˜ ë²„ì „
        // ============================================

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // ìƒíƒœ ê´€ë¦¬
        // ============================================
        const state = {
            f: 2.0,
            scale: 50,
            mode: 'parabola',
            raySpeed: 3,
            spawnInterval: 300,
            rayWidth: 6,
            
            showGrid: true,
            showTrail: true,
            showTangent: true,
            showAngles: true,
            showGlow: true,
            randomSpawn: false,
            
            isRunning: false,
            
            // íƒ€ì›/ìŒê³¡ì„  íŒŒë¼ë¯¸í„°
            a: 4,
            b: 2,
            
            // ë“œë˜ê·¸ ì  P
            pointP: { x: 2, y: 0 },
            isDragging: false,
            
            centerX: 0,
            centerY: 0
        };

        // ê´‘ì„  ë°°ì—´
        let rays = [];
        let reflectedCount = 0;
        let spawnTimer = null;
        let rayIdCounter = 0;

        // ============================================
        // ê´‘ì„  í´ë˜ìŠ¤
        // ============================================
        class Ray {
            constructor(x, y, vx, vy) {
                this.id = rayIdCounter++;
                this.x = x;           // í˜„ì¬ x ìœ„ì¹˜ (ìˆ˜í•™ ì¢Œí‘œ)
                this.y = y;           // í˜„ì¬ y ìœ„ì¹˜ (ìˆ˜í•™ ì¢Œí‘œ)
                this.vx = vx;         // x ì†ë„
                this.vy = vy;         // y ì†ë„
                this.reflected = false;
                this.active = true;
                this.trail = [];      // ê¶¤ì  ì €ì¥
                this.maxTrail = 80;
                this.hitPoint = null; // ë°˜ì‚¬ ì§€ì 
                this.color = '#ffd93d';
                this.reflectedColor = '#00d9ff';
            }

            update(dt) {
                if (!this.active) return;

                // ê¶¤ì  ì €ì¥
                this.trail.push({ x: this.x, y: this.y, reflected: this.reflected });
                if (this.trail.length > this.maxTrail) {
                    this.trail.shift();
                }

                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                const speed = state.raySpeed * 0.05;
                this.x += this.vx * speed;
                this.y += this.vy * speed;

                // ì¶©ëŒ ê°ì§€ (ë°˜ì‚¬ ì „ë§Œ)
                if (!this.reflected) {
                    this.checkCollision();
                }

                // í™”ë©´ ë°– ì²´í¬
                const margin = 15;
                if (this.x < -margin || this.x > margin || 
                    this.y < -margin || this.y > margin) {
                    this.active = false;
                }
            }

            checkCollision() {
                let curveY;
                let isOnCurve = false;

                if (state.mode === 'parabola') {
                    // í¬ë¬¼ì„ : y = xÂ² / 4f
                    curveY = (this.x * this.x) / (4 * state.f);
                    // ê´‘ì„ ì´ í¬ë¬¼ì„  ì•„ë˜ë¡œ ë‚´ë ¤ì™”ëŠ”ì§€ í™•ì¸
                    if (this.y <= curveY + 0.1 && this.y >= curveY - 0.3) {
                        isOnCurve = true;
                    }
                } else if (state.mode === 'ellipse') {
                    // íƒ€ì›: xÂ²/aÂ² + yÂ²/bÂ² = 1
                    const a = state.a, b = state.b;
                    if (Math.abs(this.x) < a) {
                        curveY = b * Math.sqrt(1 - (this.x * this.x) / (a * a));
                        if (Math.abs(this.y - curveY) < 0.2 || Math.abs(this.y + curveY) < 0.2) {
                            isOnCurve = true;
                            if (this.y < 0) curveY = -curveY;
                        }
                    }
                } else if (state.mode === 'hyperbola') {
                    // ìŒê³¡ì„ : xÂ²/aÂ² - yÂ²/bÂ² = 1
                    const a = state.a / 2, b = state.b;
                    if (Math.abs(this.x) >= a) {
                        curveY = b * Math.sqrt((this.x * this.x) / (a * a) - 1);
                        if (Math.abs(this.y - curveY) < 0.2 || Math.abs(this.y + curveY) < 0.2) {
                            isOnCurve = true;
                            if (this.y < 0) curveY = -curveY;
                        }
                    }
                }

                if (isOnCurve && curveY !== undefined) {
                    this.reflect(this.x, curveY);
                }
            }

            reflect(hitX, hitY) {
                this.reflected = true;
                this.hitPoint = { x: hitX, y: hitY };
                this.x = hitX;
                this.y = hitY;
                reflectedCount++;

                // ë²•ì„  ë²¡í„° ê³„ì‚°
                let normal = this.getNormal(hitX, hitY);

                // ì…ì‚¬ ë²¡í„° (ì •ê·œí™”)
                const incLen = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const incDir = { x: this.vx / incLen, y: this.vy / incLen };

                // ë°˜ì‚¬ ë²¡í„° ê³„ì‚°: r = d - 2(dÂ·n)n
                const dot = incDir.x * normal.x + incDir.y * normal.y;
                this.vx = incDir.x - 2 * dot * normal.x;
                this.vy = incDir.y - 2 * dot * normal.y;

                // ì •ê·œí™”
                const refLen = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                this.vx /= refLen;
                this.vy /= refLen;
            }

            getNormal(x, y) {
                let nx, ny;

                if (state.mode === 'parabola') {
                    // í¬ë¬¼ì„ ì˜ ê¸°ìš¸ê¸°: dy/dx = x / 2f
                    // ë²•ì„  ë°©í–¥: (-slope, 1) ì •ê·œí™”, ìœ„ìª½ ë°©í–¥
                    const slope = x / (2 * state.f);
                    nx = -slope;
                    ny = 1;
                } else if (state.mode === 'ellipse') {
                    // íƒ€ì›ì˜ ë²•ì„ : ì  (x, y)ì—ì„œ ë°”ê¹¥ìª½
                    const a = state.a, b = state.b;
                    nx = x / (a * a);
                    ny = y / (b * b);
                } else {
                    // ìŒê³¡ì„ ì˜ ë²•ì„ 
                    const a = state.a / 2, b = state.b;
                    nx = x / (a * a);
                    ny = -y / (b * b);
                }

                // ì •ê·œí™”
                const len = Math.sqrt(nx * nx + ny * ny);
                return { x: nx / len, y: ny / len };
            }

            draw() {
                if (!this.active && this.trail.length === 0) return;

                // ê¶¤ì  ê·¸ë¦¬ê¸°
                if (state.showTrail && this.trail.length > 1) {
                    for (let i = 1; i < this.trail.length; i++) {
                        const p0 = this.trail[i - 1];
                        const p1 = this.trail[i];
                        const pos0 = toCanvas(p0.x, p0.y);
                        const pos1 = toCanvas(p1.x, p1.y);

                        const alpha = i / this.trail.length;
                        const color = p1.reflected ? this.reflectedColor : this.color;
                        
                        ctx.strokeStyle = color;
                        ctx.globalAlpha = alpha * 0.7;
                        ctx.lineWidth = state.rayWidth * alpha;
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(pos0.x, pos0.y);
                        ctx.lineTo(pos1.x, pos1.y);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1;
                }

                // í˜„ì¬ ìœ„ì¹˜ì— ê´‘ì„  ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
                if (this.active) {
                    const pos = toCanvas(this.x, this.y);
                    const color = this.reflected ? this.reflectedColor : this.color;

                    if (state.showGlow) {
                        ctx.shadowColor = color;
                        ctx.shadowBlur = 15;
                    }

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, state.rayWidth, 0, Math.PI * 2);
                    ctx.fill();

                    // ë°©í–¥ í‘œì‹œ
                    const arrowLen = 12;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineTo(pos.x + this.vx * arrowLen, pos.y - this.vy * arrowLen);
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                }

                // ë°˜ì‚¬ ì§€ì  í‘œì‹œ
                if (this.hitPoint) {
                    const hitPos = toCanvas(this.hitPoint.x, this.hitPoint.y);
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(hitPos.x, hitPos.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ============================================
        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
        // ============================================
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth - 40, container.clientHeight - 40, 800);
            canvas.width = size;
            canvas.height = size;
            state.centerX = canvas.width / 2;
            state.centerY = canvas.height / 2;
        }

        // ============================================
        // ì¢Œí‘œ ë³€í™˜
        // ============================================
        function toCanvas(x, y) {
            return {
                x: state.centerX + x * state.scale,
                y: state.centerY - y * state.scale
            };
        }

        function toMath(px, py) {
            return {
                x: (px - state.centerX) / state.scale,
                y: (state.centerY - py) / state.scale
            };
        }

        // ============================================
        // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
        // ============================================
        function drawGrid() {
            if (!state.showGrid) return;

            const w = canvas.width;
            const h = canvas.height;

            // ë³´ì¡° ê·¸ë¦¬ë“œ
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.15)';
            ctx.lineWidth = 0.5;
            const gridStep = state.scale / 2;
            for (let x = state.centerX % gridStep; x < w; x += gridStep) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % gridStep; y < h; y += gridStep) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì£¼ ê·¸ë¦¬ë“œ
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.lineWidth = 1;
            for (let x = state.centerX % state.scale; x < w; x += state.scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % state.scale; y < h; y += state.scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì¢Œí‘œì¶•
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, state.centerY);
            ctx.lineTo(w, state.centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(state.centerX, 0);
            ctx.lineTo(state.centerX, h);
            ctx.stroke();

            // ì¶• ë ˆì´ë¸”
            ctx.fillStyle = '#666';
            ctx.font = '14px Consolas, monospace';
            ctx.fillText('x', w - 20, state.centerY - 10);
            ctx.fillText('y', state.centerX + 10, 20);

            // ëˆˆê¸ˆ ìˆ«ì
            ctx.font = '10px Consolas, monospace';
            const range = Math.ceil(w / state.scale / 2);
            for (let i = -range; i <= range; i++) {
                if (i === 0) continue;
                const pos = toCanvas(i, 0);
                if (pos.x > 0 && pos.x < w) {
                    ctx.fillText(i.toString(), pos.x - 5, pos.y + 15);
                }
            }
        }

        // ============================================
        // í¬ë¬¼ì„  ê·¸ë¦¬ê¸°
        // ============================================
        function drawParabola() {
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 15;
            }
            
            ctx.beginPath();
            const range = canvas.width / state.scale;
            let first = true;

            for (let x = -range; x <= range; x += 0.05) {
                const y = (x * x) / (4 * state.f);
                const pos = toCanvas(x, y);
                if (pos.y < -50 || pos.y > canvas.height + 50) continue;
                
                if (first) {
                    ctx.moveTo(pos.x, pos.y);
                    first = false;
                } else {
                    ctx.lineTo(pos.x, pos.y);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ì´ˆì  F
            const focus = toCanvas(0, state.f);
            
            if (state.showGlow) {
                ctx.shadowColor = '#ffd93d';
                ctx.shadowBlur = 20;
            }
            
            ctx.fillStyle = '#ffd93d';
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px serif';
            ctx.fillText('F', focus.x + 15, focus.y + 5);

            // ì¤€ì„ 
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const directrix = toCanvas(0, -state.f);
            ctx.beginPath();
            ctx.moveTo(0, directrix.y);
            ctx.lineTo(canvas.width, directrix.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ============================================
        // íƒ€ì› ê·¸ë¦¬ê¸°
        // ============================================
        function drawEllipse() {
            const a = state.a, b = state.b;
            const c = Math.sqrt(a * a - b * b);

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 15;
            }

            ctx.beginPath();
            for (let t = 0; t <= 2 * Math.PI; t += 0.02) {
                const x = a * Math.cos(t);
                const y = b * Math.sin(t);
                const pos = toCanvas(x, y);
                if (t === 0) ctx.moveTo(pos.x, pos.y);
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ë‘ ì´ˆì 
            [[-c, 'Fâ‚'], [c, 'Fâ‚‚']].forEach(([fx, label]) => {
                const fPos = toCanvas(fx, 0);
                ctx.fillStyle = '#ffd93d';
                ctx.beginPath();
                ctx.arc(fPos.x, fPos.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px serif';
                ctx.fillText(label, fPos.x + 12, fPos.y + 5);
            });
        }

        // ============================================
        // ìŒê³¡ì„  ê·¸ë¦¬ê¸°
        // ============================================
        function drawHyperbola() {
            const a = state.a / 2, b = state.b;
            const c = Math.sqrt(a * a + b * b);

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 15;
            }

            // ì˜¤ë¥¸ìª½ ê°€ì§€
            ctx.beginPath();
            let first = true;
            for (let y = -8; y <= 8; y += 0.1) {
                const x = a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            // ì™¼ìª½ ê°€ì§€
            ctx.beginPath();
            first = true;
            for (let y = -8; y <= 8; y += 0.1) {
                const x = -a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ë‘ ì´ˆì 
            [[-c, 'Fâ‚'], [c, 'Fâ‚‚']].forEach(([fx, label]) => {
                const fPos = toCanvas(fx, 0);
                ctx.fillStyle = '#ffd93d';
                ctx.beginPath();
                ctx.arc(fPos.x, fPos.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px serif';
                ctx.fillText(label, fPos.x + 12, fPos.y + 5);
            });
        }

        // ============================================
        // ì¸í„°ë™í‹°ë¸Œ ì  P
        // ============================================
        function drawInteractivePoint() {
            const px = state.pointP.x;
            let py;

            if (state.mode === 'parabola') {
                py = (px * px) / (4 * state.f);
            } else if (state.mode === 'ellipse') {
                py = state.b * Math.sqrt(Math.max(0, 1 - (px * px) / (state.a * state.a)));
            } else {
                const a = state.a / 2;
                py = Math.abs(px) >= a ? state.b * Math.sqrt((px * px) / (a * a) - 1) : 0;
            }

            state.pointP.y = py;
            const pos = toCanvas(px, py);

            // ì ‘ì„  ê¸°ìš¸ê¸° ê³„ì‚°
            let tangentSlope;
            if (state.mode === 'parabola') {
                tangentSlope = px / (2 * state.f);
            } else if (state.mode === 'ellipse') {
                tangentSlope = py !== 0 ? -(state.b * state.b * px) / (state.a * state.a * py) : Infinity;
            } else {
                const a = state.a / 2;
                tangentSlope = py !== 0 ? (state.b * state.b * px) / (a * a * py) : 0;
            }

            if (state.showTangent && isFinite(tangentSlope)) {
                // ì ‘ì„ 
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                const dx = 3;
                const p1 = toCanvas(px - dx, py - tangentSlope * dx);
                const p2 = toCanvas(px + dx, py + tangentSlope * dx);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);

                // ë²•ì„ 
                if (tangentSlope !== 0) {
                    const normalSlope = -1 / tangentSlope;
                    ctx.strokeStyle = '#a855f7';
                    ctx.setLineDash([4, 4]);
                    const dx2 = 2;
                    const n1 = toCanvas(px - dx2, py - normalSlope * dx2);
                    const n2 = toCanvas(px + dx2, py + normalSlope * dx2);
                    ctx.beginPath();
                    ctx.moveTo(n1.x, n1.y);
                    ctx.lineTo(n2.x, n2.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            // ì…ì‚¬/ë°˜ì‚¬ê´‘ í‘œì‹œ
            if (state.mode === 'parabola') {
                // ì…ì‚¬ê´‘
                const rayTop = toCanvas(px, py + 5);
                ctx.strokeStyle = '#ffd93d';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(rayTop.x, rayTop.y);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();

                // ë°˜ì‚¬ê´‘ (ì´ˆì ìœ¼ë¡œ)
                const focus = toCanvas(0, state.f);
                ctx.strokeStyle = '#00d9ff';
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(focus.x, focus.y);
                ctx.stroke();

                // ê°ë„ í‘œì‹œ
                if (state.showAngles) {
                    drawAngles(px, py, tangentSlope);
                }
            }

            // ì  P
            ctx.fillStyle = '#ff6b6b';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px serif';
            ctx.fillText('P (ë“œë˜ê·¸)', pos.x + 18, pos.y - 10);

            updateLiveData(px, py, tangentSlope);
        }

        // ============================================
        // ê°ë„ ì‹œê°í™”
        // ============================================
        function drawAngles(px, py, tangentSlope) {
            const pos = toCanvas(px, py);
            const radius = 40;

            // ë²•ì„  ê°ë„
            const slope = px / (2 * state.f);
            const normalAngle = Math.atan2(1, -slope); // ìˆ˜í•™ ì¢Œí‘œê³„
            const normalAngleCanvas = -normalAngle; // ìº”ë²„ìŠ¤ ì¢Œí‘œê³„

            // ì…ì‚¬ê´‘ ê°ë„ (ìœ„ì—ì„œ ì•„ë˜ë¡œ = 270ë„ = -90ë„)
            const incidentAngleCanvas = Math.PI / 2;

            // ë°˜ì‚¬ê´‘ ê°ë„ (ì´ˆì  ë°©í–¥)
            const toFocusX = 0 - px;
            const toFocusY = state.f - py;
            const reflectAngle = Math.atan2(-toFocusY, toFocusX);

            // ê°ë„ ê³„ì‚°
            let theta1 = Math.abs(normalAngleCanvas - incidentAngleCanvas);
            if (theta1 > Math.PI) theta1 = 2 * Math.PI - theta1;
            let theta2 = Math.abs(reflectAngle - normalAngleCanvas);
            if (theta2 > Math.PI) theta2 = 2 * Math.PI - theta2;

            const theta1Deg = (theta1 * 180 / Math.PI);
            const theta2Deg = (theta2 * 180 / Math.PI);

            // ì…ì‚¬ê° í˜¸
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const startAngle1 = Math.min(normalAngleCanvas, incidentAngleCanvas);
            const endAngle1 = Math.max(normalAngleCanvas, incidentAngleCanvas);
            ctx.arc(pos.x, pos.y, radius, startAngle1, endAngle1);
            ctx.stroke();

            // ë°˜ì‚¬ê° í˜¸
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.8)';
            ctx.beginPath();
            const startAngle2 = Math.min(normalAngleCanvas, reflectAngle);
            const endAngle2 = Math.max(normalAngleCanvas, reflectAngle);
            ctx.arc(pos.x, pos.y, radius - 10, startAngle2, endAngle2);
            ctx.stroke();

            // ê°ë„ ë ˆì´ë¸”
            ctx.font = 'bold 11px serif';
            ctx.fillStyle = '#ffd93d';
            const labelAngle1 = (normalAngleCanvas + incidentAngleCanvas) / 2;
            ctx.fillText('Î¸â‚', pos.x + Math.cos(labelAngle1) * (radius + 15), 
                        pos.y + Math.sin(labelAngle1) * (radius + 15));

            ctx.fillStyle = '#00d9ff';
            const labelAngle2 = (normalAngleCanvas + reflectAngle) / 2;
            ctx.fillText('Î¸â‚‚', pos.x + Math.cos(labelAngle2) * (radius - 25), 
                        pos.y + Math.sin(labelAngle2) * (radius - 25));

            // UI ì—…ë°ì´íŠ¸
            document.getElementById('incidentAngle').textContent = theta1Deg.toFixed(1) + 'Â°';
            document.getElementById('reflectAngle').textContent = theta2Deg.toFixed(1) + 'Â°';

            const diff = Math.abs(theta1Deg - theta2Deg);
            if (diff < 2) {
                document.getElementById('verification').textContent = 'Î¸â‚ = Î¸â‚‚ âœ“';
                document.getElementById('verification').style.color = '#4ecdc4';
            } else {
                document.getElementById('verification').textContent = `Î” = ${diff.toFixed(1)}Â°`;
                document.getElementById('verification').style.color = '#ffd93d';
            }
        }

        function updateLiveData(px, py, slope) {
            document.getElementById('pointP').textContent = `(${px.toFixed(2)}, ${py.toFixed(2)})`;
            document.getElementById('tangentSlope').textContent = isFinite(slope) ? slope.toFixed(3) : 'âˆ';
        }

        // ============================================
        // ê´‘ì„  ìƒì„±
        // ============================================
        function spawnRay() {
            let x, y, vx, vy;

            if (state.mode === 'parabola') {
                // ìœ„ì—ì„œ ì•„ë˜ë¡œ ë–¨ì–´ì§€ëŠ” í‰í–‰ê´‘ì„ 
                if (state.randomSpawn) {
                    x = (Math.random() - 0.5) * 8;
                } else {
                    x = ((rayIdCounter % 9) - 4) * 0.8;
                }
                y = 8;
                vx = 0;
                vy = -1;
            } else if (state.mode === 'ellipse') {
                // í•œ ì´ˆì ì—ì„œ ë‚˜ì˜¤ëŠ” ê´‘ì„ 
                const c = Math.sqrt(state.a * state.a - state.b * state.b);
                x = -c;
                y = 0;
                const angle = (Math.random() - 0.5) * Math.PI * 0.8;
                vx = Math.cos(angle);
                vy = Math.sin(angle);
            } else {
                // ìŒê³¡ì„ : í•œ ì´ˆì ì„ í–¥í•˜ëŠ” ê´‘ì„ 
                const a = state.a / 2, b = state.b;
                const c = Math.sqrt(a * a + b * b);
                const angle = Math.random() * Math.PI * 2;
                x = 8 * Math.cos(angle);
                y = 8 * Math.sin(angle);
                // ì´ˆì  F2ë¥¼ í–¥í•¨
                const dx = c - x;
                const dy = 0 - y;
                const len = Math.sqrt(dx * dx + dy * dy);
                vx = dx / len;
                vy = dy / len;
            }

            rays.push(new Ray(x, y, vx, vy));
        }

        // ============================================
        // ì‹œë®¬ë ˆì´ì…˜ ì œì–´
        // ============================================
        function startSimulation() {
            if (state.isRunning) return;
            state.isRunning = true;
            document.getElementById('btnStart').textContent = 'â–¶ ì‹¤í–‰ì¤‘...';
            
            spawnTimer = setInterval(spawnRay, state.spawnInterval);
            spawnRay(); // ì¦‰ì‹œ ì²« ê´‘ì„  ìƒì„±
        }

        function stopSimulation() {
            state.isRunning = false;
            document.getElementById('btnStart').textContent = 'â–¶ ì‹œì‘';
            
            if (spawnTimer) {
                clearInterval(spawnTimer);
                spawnTimer = null;
            }
        }

        function resetSimulation() {
            stopSimulation();
            rays = [];
            reflectedCount = 0;
            rayIdCounter = 0;
        }

        // ============================================
        // ë©”ì¸ ë Œë”ë§ ë£¨í”„
        // ============================================
        function render() {
            // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê·¸ë¦¬ë“œ
            drawGrid();

            // ê³¡ì„ 
            switch (state.mode) {
                case 'parabola': drawParabola(); break;
                case 'ellipse': drawEllipse(); break;
                case 'hyperbola': drawHyperbola(); break;
            }

            // ê´‘ì„  ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            rays = rays.filter(ray => ray.active || ray.trail.length > 0);
            rays.forEach(ray => {
                ray.update();
                ray.draw();
            });

            // ë¹„í™œì„± ê´‘ì„ ì˜ ê¶¤ì  í˜ì´ë“œì•„ì›ƒ
            rays.forEach(ray => {
                if (!ray.active && ray.trail.length > 0) {
                    ray.trail.shift();
                }
            });

            // ì¸í„°ë™í‹°ë¸Œ ì 
            drawInteractivePoint();

            // ì •ë³´ í‘œì‹œ
            ctx.fillStyle = 'rgba(0, 217, 255, 0.9)';
            ctx.font = '14px Consolas, monospace';
            ctx.fillText(`f = ${state.f.toFixed(1)}`, 15, 25);
            ctx.fillText(`ê´‘ì„ : ${rays.filter(r => r.active).length}ê°œ`, 15, 45);

            // í†µê³„ ì—…ë°ì´íŠ¸
            document.getElementById('activeRays').textContent = rays.filter(r => r.active).length;
            document.getElementById('reflectedCount').textContent = reflectedCount;

            requestAnimationFrame(render);
        }

        // ============================================
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        // ============================================
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const py = state.mode === 'parabola' 
                ? (state.pointP.x ** 2) / (4 * state.f) 
                : state.pointP.y;
            const pPos = toCanvas(state.pointP.x, py);
            const dist = Math.sqrt((mouseX - pPos.x) ** 2 + (mouseY - pPos.y) ** 2);

            if (dist < 25) {
                state.isDragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const math = toMath(mouseX, 0);

            let newX = Math.max(-5, Math.min(5, math.x));
            if (state.mode === 'ellipse') {
                newX = Math.max(-state.a + 0.1, Math.min(state.a - 0.1, newX));
            } else if (state.mode === 'hyperbola') {
                const a = state.a / 2;
                if (Math.abs(newX) < a) newX = newX >= 0 ? a : -a;
            }
            state.pointP.x = newX;
        });

        canvas.addEventListener('mouseup', () => state.isDragging = false);
        canvas.addEventListener('mouseleave', () => state.isDragging = false);

        // í„°ì¹˜ ì´ë²¤íŠ¸
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;

            const py = state.mode === 'parabola' 
                ? (state.pointP.x ** 2) / (4 * state.f) 
                : state.pointP.y;
            const pPos = toCanvas(state.pointP.x, py);
            const dist = Math.sqrt((mouseX - pPos.x) ** 2 + (mouseY - pPos.y) ** 2);

            if (dist < 35) state.isDragging = true;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!state.isDragging) return;

            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = touch.clientX - rect.left;
            const math = toMath(mouseX, 0);

            let newX = Math.max(-5, Math.min(5, math.x));
            if (state.mode === 'ellipse') {
                newX = Math.max(-state.a + 0.1, Math.min(state.a - 0.1, newX));
            } else if (state.mode === 'hyperbola') {
                const a = state.a / 2;
                if (Math.abs(newX) < a) newX = newX >= 0 ? a : -a;
            }
            state.pointP.x = newX;
        });

        canvas.addEventListener('touchend', () => state.isDragging = false);

        // ì»¨íŠ¸ë¡¤ íŒ¨ë„
        document.getElementById('btnStart').addEventListener('click', startSimulation);
        document.getElementById('btnStop').addEventListener('click', stopSimulation);
        document.getElementById('btnReset').addEventListener('click', resetSimulation);

        document.getElementById('focalLength').addEventListener('input', (e) => {
            state.f = parseFloat(e.target.value);
            document.getElementById('fValue').textContent = state.f.toFixed(1);
        });

        document.getElementById('raySpeed').addEventListener('input', (e) => {
            state.raySpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = state.raySpeed;
        });

        document.getElementById('spawnInterval').addEventListener('input', (e) => {
            state.spawnInterval = parseInt(e.target.value);
            document.getElementById('intervalValue').textContent = state.spawnInterval;
            if (state.isRunning) {
                clearInterval(spawnTimer);
                spawnTimer = setInterval(spawnRay, state.spawnInterval);
            }
        });

        document.getElementById('rayWidth').addEventListener('input', (e) => {
            state.rayWidth = parseInt(e.target.value);
            document.getElementById('widthValue').textContent = state.rayWidth;
        });

        document.getElementById('scale').addEventListener('input', (e) => {
            state.scale = parseInt(e.target.value);
            document.getElementById('scaleValue').textContent = state.scale;
        });

        // ì²´í¬ë°•ìŠ¤
        document.getElementById('showGrid').addEventListener('change', (e) => state.showGrid = e.target.checked);
        document.getElementById('showTrail').addEventListener('change', (e) => state.showTrail = e.target.checked);
        document.getElementById('showTangent').addEventListener('change', (e) => state.showTangent = e.target.checked);
        document.getElementById('showAngles').addEventListener('change', (e) => state.showAngles = e.target.checked);
        document.getElementById('showGlow').addEventListener('change', (e) => state.showGlow = e.target.checked);
        document.getElementById('randomSpawn').addEventListener('change', (e) => state.randomSpawn = e.target.checked);

        // ëª¨ë“œ ë²„íŠ¼
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.mode = e.target.dataset.mode;
                resetSimulation();
                updateCurveInfo();
                state.pointP.x = state.mode === 'hyperbola' ? 3 : 2;
            });
        });

        function updateCurveInfo() {
            const formula = document.getElementById('formulaDisplay');
            const desc = document.getElementById('curveDescription');

            switch (state.mode) {
                case 'parabola':
                    formula.textContent = 'y = xÂ² / 4f';
                    desc.innerHTML = '<strong>í¬ë¬¼ì„ :</strong> í‰í–‰ê´‘ì„  â†’ ì´ˆì  ì§‘ì¤‘';
                    break;
                case 'ellipse':
                    formula.textContent = 'xÂ²/aÂ² + yÂ²/bÂ² = 1';
                    desc.innerHTML = '<strong>íƒ€ì›:</strong> Fâ‚ì—ì„œ ì¶œë°œ â†’ Fâ‚‚ë¡œ ì§‘ì¤‘';
                    break;
                case 'hyperbola':
                    formula.textContent = 'xÂ²/aÂ² - yÂ²/bÂ² = 1';
                    desc.innerHTML = '<strong>ìŒê³¡ì„ :</strong> Fâ‚‚ë¡œ í–¥í•˜ëŠ” ë¹› â†’ Fâ‚ì—ì„œ ë°œì‚°í•˜ëŠ” ê²ƒì²˜ëŸ¼ ë°˜ì‚¬';
                    break;
            }
        }

        // ì´ˆê¸°í™”
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        render();
        
        // ìë™ ì‹œì‘
        setTimeout(startSimulation, 500);
    </script>
</body>
</html>
