<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í¬ë¬¼ì„  ê±°ìš¸ì˜ ë°˜ì‚¬ ì„±ì§ˆ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
        }

        /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        .control-panel {
            width: 320px;
            min-width: 320px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #00d9ff;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 1px solid #0f3460;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .control-group {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #0f3460;
        }

        .control-group h3 {
            font-size: 0.95em;
            color: #ffd93d;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #ffd93d;
            border-radius: 50%;
        }

        .slider-container {
            margin-bottom: 12px;
        }

        .slider-container label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85em;
            color: #ccc;
        }

        .slider-container label span {
            color: #00d9ff;
            font-weight: bold;
            font-family: 'Consolas', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #0f3460, #00d9ff);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ffd93d;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 217, 61, 0.5);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.85em;
            cursor: pointer;
        }

        .checkbox-container input {
            width: 18px;
            height: 18px;
            accent-color: #00d9ff;
            cursor: pointer;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8em;
            line-height: 1.6;
        }

        .info-box .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
            color: #ffd93d;
            text-align: center;
            margin: 10px 0;
            font-style: italic;
        }

        .live-data {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 0.75em;
            line-height: 1.8;
        }

        .live-data .label {
            color: #888;
        }

        .live-data .value {
            color: #00d9ff;
        }

        .live-data .highlight {
            color: #ffd93d;
            font-weight: bold;
        }

        .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 80px;
            padding: 10px 8px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #ccc;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: #1a4a7a;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00d9ff, #0f3460);
            color: white;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
        }

        .theory-text {
            font-size: 0.78em;
            line-height: 1.7;
            color: #aaa;
            text-align: justify;
        }

        /* ìº”ë²„ìŠ¤ ì˜ì—­ */
        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: #0d1421;
        }

        #mainCanvas {
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.2);
            cursor: crosshair;
        }

        /* ë²”ë¡€ */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.75em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        /* ë°˜ì‘í˜• */
        @media (max-width: 900px) {
            body {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                min-width: auto;
                max-height: 40vh;
                border-right: none;
                border-bottom: 2px solid #0f3460;
            }
            .canvas-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <h1 class="panel-title">ğŸ”­ í¬ë¬¼ì„  ê±°ìš¸ ì‹œë®¬ë ˆì´í„°</h1>

        <!-- ê¸°ë³¸ ì»¨íŠ¸ë¡¤ -->
        <div class="control-group">
            <h3>ë§¤ê°œë³€ìˆ˜ ì¡°ì ˆ</h3>
            <div class="slider-container">
                <label>ì´ˆì  ê±°ë¦¬ (f): <span id="fValue">2.0</span></label>
                <input type="range" id="focalLength" min="0.5" max="5" step="0.1" value="2">
            </div>
            <div class="slider-container">
                <label>ê´‘ì„  ê°œìˆ˜: <span id="rayCountValue">7</span></label>
                <input type="range" id="rayCount" min="1" max="15" step="2" value="7">
            </div>
            <div class="slider-container">
                <label>í™•ëŒ€/ì¶•ì†Œ: <span id="scaleValue">50</span></label>
                <input type="range" id="scale" min="20" max="100" step="5" value="50">
            </div>
        </div>

        <!-- ì‹œê°í™” ì˜µì…˜ -->
        <div class="control-group">
            <h3>ì‹œê°í™” ì˜µì…˜</h3>
            <label class="checkbox-container">
                <input type="checkbox" id="showGrid" checked>
                ì¢Œí‘œê³„ ë° ê·¸ë¦¬ë“œ í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showRays" checked>
                í‰í–‰ ê´‘ì„  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showTangent" checked>
                ì ‘ì„  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showNormal" checked>
                ë²•ì„  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showAngles" checked>
                ê°ë„ í‘œì‹œ (ì…ì‚¬ê° = ë°˜ì‚¬ê°)
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="animateRays">
                ê´‘ì„  ì• ë‹ˆë©”ì´ì…˜
            </label>
        </div>

        <!-- ê³¡ì„  ì„ íƒ -->
        <div class="control-group">
            <h3>ê³¡ì„  ìœ í˜• ì„ íƒ</h3>
            <div class="mode-buttons">
                <button class="mode-btn active" data-mode="parabola">í¬ë¬¼ì„ </button>
                <button class="mode-btn" data-mode="ellipse">íƒ€ì›</button>
                <button class="mode-btn" data-mode="hyperbola">ìŒê³¡ì„ </button>
            </div>
        </div>

        <!-- ìˆ˜í•™ì  ì •ë³´ -->
        <div class="control-group">
            <h3>ìˆ˜í•™ì  ê³µì‹</h3>
            <div class="info-box">
                <div class="formula" id="formulaDisplay">y = xÂ² / 4f</div>
                <div id="curveDescription">
                    <strong>í¬ë¬¼ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                    ì¶•ì— í‰í–‰í•˜ê²Œ ì…ì‚¬í•˜ëŠ” ëª¨ë“  ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ì´ˆì  Fë¥¼ ì§€ë‚˜ê°‘ë‹ˆë‹¤.
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ë°ì´í„° -->
        <div class="control-group">
            <h3>ì‹¤ì‹œê°„ ì¸¡ì •ê°’</h3>
            <div class="live-data" id="liveData">
                <div><span class="label">ì  P ì¢Œí‘œ:</span> <span class="value" id="pointP">(-, -)</span></div>
                <div><span class="label">ì ‘ì„  ê¸°ìš¸ê¸°:</span> <span class="value" id="tangentSlope">-</span></div>
                <div><span class="label">ì…ì‚¬ê° Î¸â‚:</span> <span class="value" id="incidentAngle">-</span></div>
                <div><span class="label">ë°˜ì‚¬ê° Î¸â‚‚:</span> <span class="value" id="reflectAngle">-</span></div>
                <div><span class="label">ê²€ì¦:</span> <span class="highlight" id="verification">Î¸â‚ = Î¸â‚‚ âœ“</span></div>
            </div>
        </div>

        <!-- ë²”ë¡€ -->
        <div class="control-group">
            <h3>ë²”ë¡€</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>í¬ë¬¼ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>ì…ì‚¬ê´‘</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d9ff;"></div>
                    <span>ë°˜ì‚¬ê´‘</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ecdc4;"></div>
                    <span>ì ‘ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #a855f7;"></div>
                    <span>ë²•ì„ </span>
                </div>
            </div>
        </div>

        <!-- ì´ë¡  ì„¤ëª… -->
        <div class="control-group">
            <h3>ì´ë¡ ì  ë°°ê²½</h3>
            <p class="theory-text" id="theoryText">
                <strong>V. Ivchenkoì˜ í•´ì„ì  ì¦ëª…:</strong><br><br>
                ë¯¸ë¶„ë°©ì •ì‹ì„ ì´ìš©í•˜ì—¬ ë°˜ì‚¬ì˜ ë²•ì¹™(ì…ì‚¬ê° = ë°˜ì‚¬ê°)ì„ ë§Œì¡±í•˜ë©´ì„œ 
                í‰í–‰ê´‘ì„ ì´ í•œ ì ìœ¼ë¡œ ëª¨ì´ëŠ” ìœ ì¼í•œ ê³¡ì„ ì´ í¬ë¬¼ì„  y = xÂ²/4f ì„ì„ ì¦ëª…í–ˆìŠµë‹ˆë‹¤.<br><br>
                ğŸ“ ì  Pì—ì„œì˜ ì ‘ì„  ê¸°ìš¸ê¸°: m = x/(2f)<br>
                ğŸ“ ë²•ì„ ì€ ì ‘ì„ ì— ìˆ˜ì§: m_n = -2f/x<br>
                ğŸ“ ì…ì‚¬ê°ê³¼ ë°˜ì‚¬ê°ì´ í•­ìƒ ë™ì¼í•¨ì„ ê¸°í•˜í•™ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
            </p>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <script>
        // ============================================
        // í¬ë¬¼ì„  ê±°ìš¸ ë°˜ì‚¬ ì„±ì§ˆ ì‹œë®¬ë ˆì´í„°
        // ê¸°ë°˜ ë…¼ë¬¸: V. Ivchenko - The analytical proof 
        // of the reflective property of a parabolic mirror
        // ============================================

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // ìƒíƒœ ë³€ìˆ˜ë“¤
        let state = {
            f: 2.0,                  // ì´ˆì  ê±°ë¦¬
            rayCount: 7,             // ê´‘ì„  ê°œìˆ˜
            scale: 50,               // í”½ì…€/ë‹¨ìœ„
            mode: 'parabola',        // ê³¡ì„  ëª¨ë“œ
            showGrid: true,
            showRays: true,
            showTangent: true,
            showNormal: true,
            showAngles: true,
            animateRays: false,
            
            // ë“œë˜ê·¸ í¬ì¸íŠ¸ P
            pointP: { x: 2, y: 0 },  // í¬ë¬¼ì„  ìœ„ì˜ ì 
            isDragging: false,
            
            // íƒ€ì›/ìŒê³¡ì„  ì¶”ê°€ íŒŒë¼ë¯¸í„°
            a: 4,  // ì¥ë°˜ê²½
            b: 2,  // ë‹¨ë°˜ê²½
            
            // ì• ë‹ˆë©”ì´ì…˜
            animationPhase: 0
        };

        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth - 40, container.clientHeight - 40, 800);
            canvas.width = size;
            canvas.height = size;
            state.centerX = canvas.width / 2;
            state.centerY = canvas.height / 2;
        }

        // ì¢Œí‘œ ë³€í™˜: ìˆ˜í•™ ì¢Œí‘œ â†’ ìº”ë²„ìŠ¤ í”½ì…€
        function toCanvas(x, y) {
            return {
                x: state.centerX + x * state.scale,
                y: state.centerY - y * state.scale  // yì¶• ë°˜ì „
            };
        }

        // ì¢Œí‘œ ë³€í™˜: ìº”ë²„ìŠ¤ í”½ì…€ â†’ ìˆ˜í•™ ì¢Œí‘œ
        function toMath(px, py) {
            return {
                x: (px - state.centerX) / state.scale,
                y: (state.centerY - py) / state.scale
            };
        }

        // ============================================
        // ê·¸ë¦¬ë“œ ë° ì¢Œí‘œì¶• ê·¸ë¦¬ê¸°
        // ============================================
        function drawGrid() {
            if (!state.showGrid) return;

            const w = canvas.width;
            const h = canvas.height;
            
            // ë³´ì¡° ê·¸ë¦¬ë“œ (ì‘ì€ ëˆˆê¸ˆ)
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.2)';
            ctx.lineWidth = 0.5;
            
            const gridStep = state.scale / 2;
            for (let x = state.centerX % gridStep; x < w; x += gridStep) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % gridStep; y < h; y += gridStep) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì£¼ ê·¸ë¦¬ë“œ (í° ëˆˆê¸ˆ)
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.4)';
            ctx.lineWidth = 1;
            
            for (let x = state.centerX % state.scale; x < w; x += state.scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % state.scale; y < h; y += state.scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì¢Œí‘œì¶•
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            // Xì¶•
            ctx.beginPath();
            ctx.moveTo(0, state.centerY);
            ctx.lineTo(w, state.centerY);
            ctx.stroke();
            
            // Yì¶•
            ctx.beginPath();
            ctx.moveTo(state.centerX, 0);
            ctx.lineTo(state.centerX, h);
            ctx.stroke();

            // ì¶• ë ˆì´ë¸”
            ctx.fillStyle = '#888';
            ctx.font = '14px Consolas, monospace';
            ctx.fillText('x', w - 20, state.centerY - 10);
            ctx.fillText('y', state.centerX + 10, 20);
            
            // ëˆˆê¸ˆ ìˆ«ì
            ctx.font = '11px Consolas, monospace';
            ctx.fillStyle = '#666';
            const range = Math.ceil(w / state.scale / 2);
            for (let i = -range; i <= range; i++) {
                if (i === 0) continue;
                const pos = toCanvas(i, 0);
                ctx.fillText(i.toString(), pos.x - 5, pos.y + 15);
            }
            for (let i = -range; i <= range; i++) {
                if (i === 0) continue;
                const pos = toCanvas(0, i);
                ctx.fillText(i.toString(), pos.x + 8, pos.y + 4);
            }
            
            // ì›ì  í‘œì‹œ
            ctx.fillText('O', state.centerX - 15, state.centerY + 15);
        }

        // ============================================
        // í¬ë¬¼ì„  ê·¸ë¦¬ê¸°: y = xÂ² / 4f
        // ============================================
        function drawParabola() {
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff6b6b';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            
            const range = canvas.width / state.scale;
            let first = true;
            
            for (let x = -range; x <= range; x += 0.05) {
                // í¬ë¬¼ì„  ë°©ì •ì‹: y = xÂ² / 4f
                const y = (x * x) / (4 * state.f);
                const pos = toCanvas(x, y);
                
                if (pos.y < 0 || pos.y > canvas.height) continue;
                
                if (first) {
                    ctx.moveTo(pos.x, pos.y);
                    first = false;
                } else {
                    ctx.lineTo(pos.x, pos.y);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ì´ˆì  F í‘œì‹œ
            const focus = toCanvas(0, state.f);
            ctx.fillStyle = '#ffd93d';
            ctx.beginPath();
            ctx.arc(focus.x, focus.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px serif';
            ctx.fillText('F', focus.x + 12, focus.y + 5);
            
            // ì¤€ì„ (Directrix) í‘œì‹œ: y = -f
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const directrix = toCanvas(0, -state.f);
            ctx.beginPath();
            ctx.moveTo(0, directrix.y);
            ctx.lineTo(canvas.width, directrix.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = 'rgba(255, 217, 61, 0.5)';
            ctx.font = '12px serif';
            ctx.fillText('ì¤€ì„  (y = -f)', 10, directrix.y - 5);
        }

        // ============================================
        // íƒ€ì› ê·¸ë¦¬ê¸°: xÂ²/aÂ² + yÂ²/bÂ² = 1
        // ============================================
        function drawEllipse() {
            const a = state.a;
            const b = state.b;
            const c = Math.sqrt(a * a - b * b);  // ì´ˆì  ê±°ë¦¬
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff6b6b';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            
            for (let t = 0; t <= 2 * Math.PI; t += 0.02) {
                const x = a * Math.cos(t);
                const y = b * Math.sin(t);
                const pos = toCanvas(x, y);
                
                if (t === 0) ctx.moveTo(pos.x, pos.y);
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ë‘ ì´ˆì  í‘œì‹œ
            const f1 = toCanvas(-c, 0);
            const f2 = toCanvas(c, 0);
            
            ctx.fillStyle = '#ffd93d';
            ctx.beginPath();
            ctx.arc(f1.x, f1.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(f2.x, f2.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px serif';
            ctx.fillText("Fâ‚", f1.x - 20, f1.y + 5);
            ctx.fillText("Fâ‚‚", f2.x + 12, f2.y + 5);
        }

        // ============================================
        // ìŒê³¡ì„  ê·¸ë¦¬ê¸°: xÂ²/aÂ² - yÂ²/bÂ² = 1
        // ============================================
        function drawHyperbola() {
            const a = state.a / 2;
            const b = state.b;
            const c = Math.sqrt(a * a + b * b);  // ì´ˆì  ê±°ë¦¬
            
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff6b6b';
            ctx.shadowBlur = 10;
            
            // ì˜¤ë¥¸ìª½ ê°€ì§€
            ctx.beginPath();
            let first = true;
            for (let t = -2; t <= 2; t += 0.05) {
                const x = a / Math.cos(t);
                const y = b * Math.tan(t);
                if (Math.abs(y) > 10) continue;
                const pos = toCanvas(x, y);
                
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
            
            // ì™¼ìª½ ê°€ì§€
            ctx.beginPath();
            first = true;
            for (let t = -2; t <= 2; t += 0.05) {
                const x = -a / Math.cos(t);
                const y = b * Math.tan(t);
                if (Math.abs(y) > 10) continue;
                const pos = toCanvas(x, y);
                
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ë‘ ì´ˆì  í‘œì‹œ
            const f1 = toCanvas(-c, 0);
            const f2 = toCanvas(c, 0);
            
            ctx.fillStyle = '#ffd93d';
            ctx.beginPath();
            ctx.arc(f1.x, f1.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(f2.x, f2.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px serif';
            ctx.fillText("Fâ‚", f1.x - 20, f1.y + 5);
            ctx.fillText("Fâ‚‚", f2.x + 12, f2.y + 5);
            
            // ì ê·¼ì„  í‘œì‹œ
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const slope = b / a;
            ctx.beginPath();
            ctx.moveTo(0, state.centerY + 300 * slope);
            ctx.lineTo(canvas.width, state.centerY - 300 * slope);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, state.centerY - 300 * slope);
            ctx.lineTo(canvas.width, state.centerY + 300 * slope);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ============================================
        // ë°˜ì‚¬ ë²¡í„° ê³„ì‚°
        // ë°˜ì‚¬ ë²•ì¹™: r = d - 2(dÂ·n)n
        // ============================================
        function calculateReflection(incidentDir, normal) {
            // ë²•ì„  ë²¡í„° ì •ê·œí™”
            const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            const n = { x: normal.x / len, y: normal.y / len };
            
            // ë‚´ì  ê³„ì‚°: d Â· n
            const dot = incidentDir.x * n.x + incidentDir.y * n.y;
            
            // ë°˜ì‚¬ ë²¡í„°: r = d - 2(dÂ·n)n
            return {
                x: incidentDir.x - 2 * dot * n.x,
                y: incidentDir.y - 2 * dot * n.y
            };
        }

        // ============================================
        // í¬ë¬¼ì„  ìœ„ì˜ ì ì—ì„œì˜ ë²•ì„  ë²¡í„°
        // í¬ë¬¼ì„ : y = xÂ²/4f, dy/dx = x/2f
        // ë²•ì„  ë°©í–¥: (-dy/dx, 1) ì •ê·œí™”
        // ============================================
        function getParabolaNormal(x) {
            const slope = x / (2 * state.f);  // ì ‘ì„  ê¸°ìš¸ê¸°
            // ë²•ì„ ì€ ì ‘ì„ ì— ìˆ˜ì§, ìœ„ìª½ì„ í–¥í•˜ë„ë¡
            let normal = { x: -slope, y: 1 };
            const len = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
            return { x: normal.x / len, y: normal.y / len };
        }

        // ============================================
        // í‰í–‰ ê´‘ì„  ë° ë°˜ì‚¬ ê·¸ë¦¬ê¸°
        // ============================================
        function drawRays() {
            if (!state.showRays) return;
            
            const raySpacing = 6 / (state.rayCount - 1 || 1);
            const startX = -3;
            const endX = 3;
            
            for (let i = 0; i < state.rayCount; i++) {
                const x = state.rayCount === 1 ? 0 : startX + i * raySpacing;
                drawSingleRay(x);
            }
        }

        function drawSingleRay(x) {
            // í¬ë¬¼ì„  ìœ„ì˜ ì : y = xÂ²/4f
            const y = (x * x) / (4 * state.f);
            const hitPoint = toCanvas(x, y);
            
            // ì…ì‚¬ê´‘ (ìœ„ì—ì„œ ë‚´ë ¤ì˜´)
            const rayStart = toCanvas(x, 10);
            
            // ì• ë‹ˆë©”ì´ì…˜ ì²˜ë¦¬
            let animOffset = 0;
            if (state.animateRays) {
                animOffset = (Date.now() / 20) % 40;
            }
            
            // ì…ì‚¬ê´‘ ê·¸ë¦¬ê¸° (ë…¸ë€ìƒ‰)
            ctx.strokeStyle = '#ffd93d';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(rayStart.x, rayStart.y);
            ctx.lineTo(hitPoint.x, hitPoint.y);
            ctx.stroke();
            
            // í™”ì‚´í‘œ ë¨¸ë¦¬ (ì…ì‚¬)
            if (state.animateRays) {
                const arrowY = rayStart.y + animOffset * 5;
                if (arrowY < hitPoint.y) {
                    drawArrowHead(rayStart.x, arrowY, 0, 1, '#ffd93d');
                }
            }
            
            // ë²•ì„  ë²¡í„° ê³„ì‚°
            const normal = getParabolaNormal(x);
            
            // ì…ì‚¬ ë°©í–¥ (ì•„ë˜ë¡œ)
            const incident = { x: 0, y: -1 };
            
            // ë°˜ì‚¬ ë²¡í„° ê³„ì‚°
            const reflected = calculateReflection(incident, normal);
            
            // ë°˜ì‚¬ê´‘ ê·¸ë¦¬ê¸° (ì´ˆì ì„ í–¥í•¨) - í•˜ëŠ˜ìƒ‰
            ctx.strokeStyle = '#00d9ff';
            ctx.lineWidth = 2;
            
            // ë°˜ì‚¬ê´‘ ì—°ì¥
            const reflectEnd = toCanvas(
                x + reflected.x * 20,
                y + reflected.y * 20
            );
            
            ctx.beginPath();
            ctx.moveTo(hitPoint.x, hitPoint.y);
            ctx.lineTo(reflectEnd.x, reflectEnd.y);
            ctx.stroke();
            
            // ë°˜ì‚¬ì  í‘œì‹œ
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(hitPoint.x, hitPoint.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }

        // ============================================
        // í™”ì‚´í‘œ ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
        // ============================================
        function drawArrowHead(x, y, dx, dy, color) {
            const size = 8;
            const angle = Math.atan2(dy, dx);
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x + Math.cos(angle) * size, y + Math.sin(angle) * size);
            ctx.lineTo(x + Math.cos(angle + 2.5) * size, y + Math.sin(angle + 2.5) * size);
            ctx.lineTo(x + Math.cos(angle - 2.5) * size, y + Math.sin(angle - 2.5) * size);
            ctx.closePath();
            ctx.fill();
        }

        // ============================================
        // ì¸í„°ë™í‹°ë¸Œ ì  P ë° ê¸°í•˜í•™ì  ìš”ì†Œ ê·¸ë¦¬ê¸°
        // ============================================
        function drawInteractivePoint() {
            const px = state.pointP.x;
            let py;
            
            if (state.mode === 'parabola') {
                py = (px * px) / (4 * state.f);
            } else if (state.mode === 'ellipse') {
                const a = state.a;
                const b = state.b;
                py = b * Math.sqrt(1 - (px * px) / (a * a));
                if (isNaN(py)) py = 0;
            } else {
                const a = state.a / 2;
                const b = state.b;
                if (Math.abs(px) >= a) {
                    py = b * Math.sqrt((px * px) / (a * a) - 1);
                } else {
                    py = 0;
                }
            }
            
            state.pointP.y = py;
            const pos = toCanvas(px, py);
            
            // ì ‘ì„  ê¸°ìš¸ê¸° ê³„ì‚°
            let tangentSlope;
            if (state.mode === 'parabola') {
                tangentSlope = px / (2 * state.f);
            } else if (state.mode === 'ellipse') {
                const a = state.a;
                const b = state.b;
                if (py !== 0) {
                    tangentSlope = -(b * b * px) / (a * a * py);
                } else {
                    tangentSlope = Infinity;
                }
            } else {
                const a = state.a / 2;
                const b = state.b;
                if (py !== 0) {
                    tangentSlope = (b * b * px) / (a * a * py);
                } else {
                    tangentSlope = 0;
                }
            }
            
            // ì ‘ì„  ê·¸ë¦¬ê¸°
            if (state.showTangent && isFinite(tangentSlope)) {
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                
                const dx = 3;
                const p1 = toCanvas(px - dx, py - tangentSlope * dx);
                const p2 = toCanvas(px + dx, py + tangentSlope * dx);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ì ‘ì„  ë¼ë²¨
                ctx.fillStyle = '#4ecdc4';
                ctx.font = '12px serif';
                ctx.fillText('ì ‘ì„ ', p2.x + 5, p2.y - 5);
            }
            
            // ë²•ì„  ê·¸ë¦¬ê¸°
            if (state.showNormal && isFinite(tangentSlope) && tangentSlope !== 0) {
                const normalSlope = -1 / tangentSlope;
                
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 2;
                ctx.setLineDash([4, 4]);
                
                const dx = 2;
                const p1 = toCanvas(px - dx, py - normalSlope * dx);
                const p2 = toCanvas(px + dx, py + normalSlope * dx);
                
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ë²•ì„  ë¼ë²¨
                ctx.fillStyle = '#a855f7';
                ctx.font = '12px serif';
                ctx.fillText('ë²•ì„ ', p2.x + 5, p2.y + 15);
            }
            
            // ì…ì‚¬ê´‘ê³¼ ë°˜ì‚¬ê´‘ (ì  Pì—ì„œ)
            const rayStartP = toCanvas(px, py + 5);
            ctx.strokeStyle = '#ffd93d';
            ctx.lineWidth = 2.5;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(rayStartP.x, rayStartP.y);
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
            
            // ë°˜ì‚¬ê´‘ (ì´ˆì ìœ¼ë¡œ)
            const focus = toCanvas(0, state.f);
            ctx.strokeStyle = '#00d9ff';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            ctx.lineTo(focus.x, focus.y);
            ctx.stroke();
            
            // ê°ë„ ì‹œê°í™”
            if (state.showAngles && state.mode === 'parabola') {
                drawAngles(px, py, tangentSlope);
            }
            
            // ì  P ê·¸ë¦¬ê¸°
            ctx.fillStyle = '#ff6b6b';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px serif';
            ctx.fillText('P', pos.x + 15, pos.y - 10);
            
            // ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸
            updateLiveData(px, py, tangentSlope);
        }

        // ============================================
        // ì…ì‚¬ê°ê³¼ ë°˜ì‚¬ê° ì‹œê°í™”
        // ============================================
        function drawAngles(px, py, tangentSlope) {
            const pos = toCanvas(px, py);
            const radius = 35;
            
            // ë²•ì„  ê°ë„ (ìœ„ìª½ ë°©í–¥)
            const normal = getParabolaNormal(px);
            const normalAngle = Math.atan2(-normal.y, normal.x);  // ìº”ë²„ìŠ¤ ì¢Œí‘œê³„
            
            // ì…ì‚¬ê´‘ ê°ë„ (ì•„ë˜ì—ì„œ ìœ„ë¡œ, ì¦‰ -y ë°©í–¥ì—ì„œ ì˜´)
            const incidentAngle = -Math.PI / 2;  // ìœ„ì—ì„œ ì•„ë˜ë¡œ = -90ë„
            
            // ë°˜ì‚¬ê´‘ ê°ë„ (ì´ˆì  ë°©í–¥)
            const toFocus = { x: 0 - px, y: state.f - py };
            const reflectAngle = Math.atan2(-toFocus.y, toFocus.x);  // ìº”ë²„ìŠ¤ ì¢Œí‘œê³„
            
            // ì…ì‚¬ê° (ì…ì‚¬ê´‘ê³¼ ë²•ì„  ì‚¬ì´)
            const theta1 = Math.abs(normalAngle - incidentAngle);
            const theta1Deg = (theta1 * 180 / Math.PI) % 90;
            
            // ë°˜ì‚¬ê° (ë°˜ì‚¬ê´‘ê³¼ ë²•ì„  ì‚¬ì´)
            const theta2 = Math.abs(reflectAngle - normalAngle);
            const theta2Deg = (theta2 * 180 / Math.PI) % 90;
            
            // ì…ì‚¬ê° í˜¸ ê·¸ë¦¬ê¸°
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius, Math.min(normalAngle, incidentAngle), Math.max(normalAngle, incidentAngle));
            ctx.stroke();
            
            // ì…ì‚¬ê° ë ˆì´ë¸”
            const labelAngle1 = (normalAngle + incidentAngle) / 2;
            ctx.fillStyle = '#ffd93d';
            ctx.font = 'bold 12px serif';
            ctx.fillText(`Î¸â‚`, pos.x + Math.cos(labelAngle1) * (radius + 15), pos.y + Math.sin(labelAngle1) * (radius + 15));
            
            // ë°˜ì‚¬ê° í˜¸ ê·¸ë¦¬ê¸°
            ctx.strokeStyle = 'rgba(0, 217, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, radius - 8, Math.min(normalAngle, reflectAngle), Math.max(normalAngle, reflectAngle));
            ctx.stroke();
            
            // ë°˜ì‚¬ê° ë ˆì´ë¸”
            const labelAngle2 = (normalAngle + reflectAngle) / 2;
            ctx.fillStyle = '#00d9ff';
            ctx.fillText(`Î¸â‚‚`, pos.x + Math.cos(labelAngle2) * (radius + 5), pos.y + Math.sin(labelAngle2) * (radius + 5));
            
            // ê°ë„ ê°’ ì—…ë°ì´íŠ¸
            document.getElementById('incidentAngle').textContent = theta1Deg.toFixed(1) + 'Â°';
            document.getElementById('reflectAngle').textContent = theta2Deg.toFixed(1) + 'Â°';
            
            if (Math.abs(theta1Deg - theta2Deg) < 1) {
                document.getElementById('verification').textContent = 'Î¸â‚ = Î¸â‚‚ âœ“';
                document.getElementById('verification').style.color = '#4ecdc4';
            } else {
                document.getElementById('verification').textContent = `Î” = ${Math.abs(theta1Deg - theta2Deg).toFixed(2)}Â°`;
                document.getElementById('verification').style.color = '#ffd93d';
            }
        }

        // ============================================
        // ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸
        // ============================================
        function updateLiveData(px, py, slope) {
            document.getElementById('pointP').textContent = `(${px.toFixed(2)}, ${py.toFixed(2)})`;
            document.getElementById('tangentSlope').textContent = isFinite(slope) ? slope.toFixed(3) : 'âˆ';
        }

        // ============================================
        // ë©”ì¸ ë Œë”ë§ í•¨ìˆ˜
        // ============================================
        function render() {
            // ìº”ë²„ìŠ¤ í´ë¦¬ì–´
            ctx.fillStyle = '#0a0a15';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
            drawGrid();
            
            // ê³¡ì„  ëª¨ë“œì— ë”°ë¼ ê·¸ë¦¬ê¸°
            switch (state.mode) {
                case 'parabola':
                    drawParabola();
                    break;
                case 'ellipse':
                    drawEllipse();
                    break;
                case 'hyperbola':
                    drawHyperbola();
                    break;
            }
            
            // ê´‘ì„  ê·¸ë¦¬ê¸° (í¬ë¬¼ì„  ëª¨ë“œì—ì„œë§Œ)
            if (state.mode === 'parabola') {
                drawRays();
            }
            
            // ì¸í„°ë™í‹°ë¸Œ ì  ê·¸ë¦¬ê¸°
            drawInteractivePoint();
            
            // ì •ë³´ í‘œì‹œ
            ctx.fillStyle = 'rgba(0, 217, 255, 0.9)';
            ctx.font = '14px Consolas, monospace';
            ctx.fillText(`f = ${state.f.toFixed(1)}`, 15, 25);
            ctx.fillText(`ëª¨ë“œ: ${state.mode === 'parabola' ? 'í¬ë¬¼ì„ ' : state.mode === 'ellipse' ? 'íƒ€ì›' : 'ìŒê³¡ì„ '}`, 15, 45);
            
            // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
            requestAnimationFrame(render);
        }

        // ============================================
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
        // ============================================
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const math = toMath(mouseX, mouseY);
            
            // ì  P ê·¼ì²˜ì¸ì§€ í™•ì¸
            const py = state.mode === 'parabola' 
                ? (state.pointP.x * state.pointP.x) / (4 * state.f)
                : state.pointP.y;
            const pPos = toCanvas(state.pointP.x, py);
            const dist = Math.sqrt((mouseX - pPos.x) ** 2 + (mouseY - pPos.y) ** 2);
            
            if (dist < 20) {
                state.isDragging = true;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const math = toMath(mouseX, 0);
            
            // x ë²”ìœ„ ì œí•œ
            let newX = Math.max(-5, Math.min(5, math.x));
            
            // íƒ€ì›/ìŒê³¡ì„ ì˜ ê²½ìš° ì¶”ê°€ ì œì•½
            if (state.mode === 'ellipse') {
                newX = Math.max(-state.a + 0.1, Math.min(state.a - 0.1, newX));
            } else if (state.mode === 'hyperbola') {
                if (Math.abs(newX) < state.a / 2) {
                    newX = newX >= 0 ? state.a / 2 : -state.a / 2;
                }
            }
            
            state.pointP.x = newX;
        });

        canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
        });

        canvas.addEventListener('mouseleave', () => {
            state.isDragging = false;
        });

        // ============================================
        // ì»¨íŠ¸ë¡¤ íŒ¨ë„ ì´ë²¤íŠ¸
        // ============================================
        document.getElementById('focalLength').addEventListener('input', (e) => {
            state.f = parseFloat(e.target.value);
            document.getElementById('fValue').textContent = state.f.toFixed(1);
        });

        document.getElementById('rayCount').addEventListener('input', (e) => {
            state.rayCount = parseInt(e.target.value);
            document.getElementById('rayCountValue').textContent = state.rayCount;
        });

        document.getElementById('scale').addEventListener('input', (e) => {
            state.scale = parseInt(e.target.value);
            document.getElementById('scaleValue').textContent = state.scale;
        });

        // ì²´í¬ë°•ìŠ¤ë“¤
        document.getElementById('showGrid').addEventListener('change', (e) => {
            state.showGrid = e.target.checked;
        });

        document.getElementById('showRays').addEventListener('change', (e) => {
            state.showRays = e.target.checked;
        });

        document.getElementById('showTangent').addEventListener('change', (e) => {
            state.showTangent = e.target.checked;
        });

        document.getElementById('showNormal').addEventListener('change', (e) => {
            state.showNormal = e.target.checked;
        });

        document.getElementById('showAngles').addEventListener('change', (e) => {
            state.showAngles = e.target.checked;
        });

        document.getElementById('animateRays').addEventListener('change', (e) => {
            state.animateRays = e.target.checked;
        });

        // ëª¨ë“œ ë²„íŠ¼ë“¤
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.mode = e.target.dataset.mode;
                
                // ìˆ˜ì‹ ë° ì„¤ëª… ì—…ë°ì´íŠ¸
                updateCurveInfo();
                
                // ì  P ìœ„ì¹˜ ì´ˆê¸°í™”
                state.pointP.x = state.mode === 'hyperbola' ? 3 : 2;
            });
        });

        // ============================================
        // ê³¡ì„  ì •ë³´ ì—…ë°ì´íŠ¸
        // ============================================
        function updateCurveInfo() {
            const formula = document.getElementById('formulaDisplay');
            const desc = document.getElementById('curveDescription');
            const theory = document.getElementById('theoryText');
            
            switch (state.mode) {
                case 'parabola':
                    formula.textContent = 'y = xÂ² / 4f';
                    desc.innerHTML = `<strong>í¬ë¬¼ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                        ì¶•ì— í‰í–‰í•˜ê²Œ ì…ì‚¬í•˜ëŠ” ëª¨ë“  ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ì´ˆì  Fë¥¼ ì§€ë‚˜ê°‘ë‹ˆë‹¤.`;
                    theory.innerHTML = `<strong>V. Ivchenkoì˜ í•´ì„ì  ì¦ëª…:</strong><br><br>
                        ë¯¸ë¶„ë°©ì •ì‹ì„ ì´ìš©í•˜ì—¬ ë°˜ì‚¬ì˜ ë²•ì¹™(ì…ì‚¬ê° = ë°˜ì‚¬ê°)ì„ ë§Œì¡±í•˜ë©´ì„œ 
                        í‰í–‰ê´‘ì„ ì´ í•œ ì ìœ¼ë¡œ ëª¨ì´ëŠ” ìœ ì¼í•œ ê³¡ì„ ì´ í¬ë¬¼ì„  y = xÂ²/4f ì„ì„ ì¦ëª…í–ˆìŠµë‹ˆë‹¤.<br><br>
                        ğŸ“ ì  Pì—ì„œì˜ ì ‘ì„  ê¸°ìš¸ê¸°: m = x/(2f)<br>
                        ğŸ“ ë²•ì„ ì€ ì ‘ì„ ì— ìˆ˜ì§: m_n = -2f/x<br>
                        ğŸ“ ì…ì‚¬ê°ê³¼ ë°˜ì‚¬ê°ì´ í•­ìƒ ë™ì¼í•¨ì„ ê¸°í•˜í•™ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`;
                    break;
                    
                case 'ellipse':
                    formula.textContent = 'xÂ²/aÂ² + yÂ²/bÂ² = 1';
                    desc.innerHTML = `<strong>íƒ€ì›ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                        í•œ ì´ˆì  Fâ‚ì—ì„œ ë‚˜ì˜¨ ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ë°˜ë“œì‹œ ë‹¤ë¥¸ ì´ˆì  Fâ‚‚ë¥¼ ì§€ë‚˜ê°‘ë‹ˆë‹¤. (ì†ì‚­ì„ì˜ ë°©)`;
                    theory.innerHTML = `<strong>íƒ€ì›ì˜ ë‘ ì´ˆì  ì„±ì§ˆ:</strong><br><br>
                        íƒ€ì› ìœ„ì˜ ì–´ëŠ ì ì—ì„œë“  ë‘ ì´ˆì ê¹Œì§€ì˜ ê±°ë¦¬ì˜ í•©ì€ ì¼ì •í•©ë‹ˆë‹¤ (= 2a).<br><br>
                        ğŸ“ c = âˆš(aÂ² - bÂ²)ë¡œ ì´ˆì  ìœ„ì¹˜ ê²°ì •<br>
                        ğŸ“ ì ‘ì„ ì€ âˆ Fâ‚PFâ‚‚ë¥¼ ì´ë“±ë¶„<br>
                        ğŸ“ ìŒí–¥í•™ì  ì‘ìš©: ì†ì‚­ì„ì˜ ë°©(Whispering Gallery)`;
                    break;
                    
                case 'hyperbola':
                    formula.textContent = 'xÂ²/aÂ² - yÂ²/bÂ² = 1';
                    desc.innerHTML = `<strong>ìŒê³¡ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                        í•œ ì´ˆì  Fâ‚ì„ í–¥í•˜ëŠ” ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ë‹¤ë¥¸ ì´ˆì  Fâ‚‚ì—ì„œ ë°œì‚°í•˜ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤.`;
                    theory.innerHTML = `<strong>ìŒê³¡ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br><br>
                        ìŒê³¡ì„  ìœ„ì˜ ì–´ëŠ ì ì—ì„œë“  ë‘ ì´ˆì ê¹Œì§€ì˜ ê±°ë¦¬ì˜ ì°¨ëŠ” ì¼ì •í•©ë‹ˆë‹¤ (= 2a).<br><br>
                        ğŸ“ c = âˆš(aÂ² + bÂ²)ë¡œ ì´ˆì  ìœ„ì¹˜ ê²°ì •<br>
                        ğŸ“ í•œ ì´ˆì ìœ¼ë¡œ í–¥í•˜ëŠ” ë¹›ì€ ë‹¤ë¥¸ ì´ˆì ì—ì„œ ë‚˜ì˜¤ëŠ” ê²ƒì²˜ëŸ¼ ë°˜ì‚¬<br>
                        ğŸ“ ì¹´ì„¸ê·¸ë ˆì¸ ë§ì›ê²½ì˜ ë³´ì¡° ê±°ìš¸ì— í™œìš©`;
                    break;
            }
        }

        // ============================================
        // ì´ˆê¸°í™” ë° ì‹œì‘
        // ============================================
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        render();

        // í„°ì¹˜ ì´ë²¤íŠ¸ ì§€ì›
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = touch.clientX - rect.left;
            const mouseY = touch.clientY - rect.top;
            
            const py = state.mode === 'parabola' 
                ? (state.pointP.x * state.pointP.x) / (4 * state.f)
                : state.pointP.y;
            const pPos = toCanvas(state.pointP.x, py);
            const dist = Math.sqrt((mouseX - pPos.x) ** 2 + (mouseY - pPos.y) ** 2);
            
            if (dist < 30) {
                state.isDragging = true;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!state.isDragging) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const mouseX = touch.clientX - rect.left;
            const math = toMath(mouseX, 0);
            
            let newX = Math.max(-5, Math.min(5, math.x));
            
            if (state.mode === 'ellipse') {
                newX = Math.max(-state.a + 0.1, Math.min(state.a - 0.1, newX));
            } else if (state.mode === 'hyperbola') {
                if (Math.abs(newX) < state.a / 2) {
                    newX = newX >= 0 ? state.a / 2 : -state.a / 2;
                }
            }
            
            state.pointP.x = newX;
        });

        canvas.addEventListener('touchend', () => {
            state.isDragging = false;
        });
    </script>
</body>
</html>
