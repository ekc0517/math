<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Bezier Lab - 2D/3D</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #f093fb;
            --accent: #4facfe;
            --bg: #f7fafc;
            --panel-bg: #ffffff;
            --text: #2d3748;
            --text-light: #718096;
            --border: #e2e8f0;
            --danger: #fc8181;
            --success: #68d391;
            --curve-color: #667eea;
            --control-poly: #fc8181;
            --hull-color: rgba(102, 126, 234, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: var(--text);
            min-height: 100vh;
        }

        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: var(--panel-bg);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--text-light);
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            gap: 20px;
            margin-bottom: 20px;
        }

        /* Panel Styles */
        .control-panel, .info-panel {
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            padding: 20px;
            height: fit-content;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .panel-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }

        .panel-section:last-child {
            border-bottom: none;
        }

        .panel-section h3 {
            font-size: 1rem;
            margin-bottom: 15px;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Buttons */
        button {
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .mode-btn, .action-btn {
            width: 100%;
            margin-bottom: 8px;
            background: var(--bg);
            color: var(--text);
        }

        .mode-btn:hover, .action-btn:hover {
            background: var(--primary);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .mode-btn.active {
            background: var(--primary);
            color: white;
        }

        .degree-buttons, .continuity-buttons, .grid-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            margin-top: 8px;
        }

        .degree-btn, .continuity-btn, .grid-btn {
            padding: 8px 4px;
            background: var(--bg);
            color: var(--text);
            font-size: 0.85rem;
        }

        .continuity-buttons {
            grid-template-columns: repeat(3, 1fr);
        }

        .grid-buttons {
            grid-template-columns: repeat(3, 1fr);
        }

        .degree-btn.active, .continuity-btn.active, .grid-btn.active {
            background: var(--accent);
            color: white;
        }

        .preset-btn {
            width: 100%;
            margin-bottom: 8px;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            color: white;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .preset-btn.danger {
            background: linear-gradient(135deg, var(--danger), #f56565);
        }

        /* Controls */
        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: var(--text);
        }

        .control-group small {
            color: var(--text-light);
            font-size: 0.75rem;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .checkbox-label input {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Canvas Area */
        .canvas-area {
            background: var(--panel-bg);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            padding: 20px;
            position: relative;
        }

        #canvas {
            width: 100%;
            height: 700px;
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: crosshair;
            background: white;
            display: block;
        }

        #canvas-3d {
            width: 100%;
            height: 700px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: #1a1a2e;
            display: none;
        }

        .canvas-instructions {
            margin-top: 15px;
            padding: 15px;
            background: var(--bg);
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .canvas-instructions ul {
            list-style: none;
            margin-top: 10px;
        }

        .canvas-instructions li {
            padding: 5px 0;
        }

        kbd {
            background: white;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 8px;
            font-family: monospace;
            font-size: 0.85rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Info Panel */
        .info-box, .concept-box {
            background: var(--bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .info-box h4, .concept-box h4 {
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: var(--primary);
        }

        .info-box p, .concept-box p {
            font-size: 0.85rem;
            color: var(--text-light);
            line-height: 1.6;
        }

        #current-properties {
            list-style: none;
            font-size: 0.85rem;
            color: var(--text-light);
        }

        #current-properties li {
            padding: 4px 0;
        }

        .concept-box ul {
            margin-top: 10px;
            margin-left: 20px;
            font-size: 0.85rem;
            color: var(--text-light);
            line-height: 1.6;
        }

        .concept-box li {
            margin-bottom: 8px;
        }

        .concept-box strong {
            color: var(--primary);
        }

        /* Footer */
        footer {
            background: var(--panel-bg);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        footer a {
            color: var(--primary);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Scrollbar */
        .control-panel::-webkit-scrollbar,
        .info-panel::-webkit-scrollbar {
            width: 6px;
        }

        .control-panel::-webkit-scrollbar-track,
        .info-panel::-webkit-scrollbar-track {
            background: var(--bg);
            border-radius: 3px;
        }

        .control-panel::-webkit-scrollbar-thumb,
        .info-panel::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 3px;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .main-content {
                grid-template-columns: 260px 1fr 280px;
            }
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .control-panel, .info-panel {
                max-height: none;
            }
        }

        #t-value {
            color: var(--primary);
            font-weight: bold;
        }

        .hidden {
            display: none !important;
        }

        /* 3D specific styles */
        .surface-section {
            display: none;
        }

        .surface-section.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header>
            <h1>ğŸ¨ Interactive Bezier Lab</h1>
            <p class="subtitle">ë² ì§€ì— ë‹¤í•­ì‹ì˜ ì‹œê°ì  íƒêµ¬ - 2D ê³¡ì„ ì—ì„œ 3D ê³¡ë©´ê¹Œì§€</p>
        </header>

        <div class="main-content">
            <!-- Control Panel -->
            <aside class="control-panel">
                <section class="panel-section">
                    <h3>ğŸ¯ ëª¨ë“œ ì„ íƒ</h3>
                    <div class="mode-buttons">
                        <button id="mode-2d" class="mode-btn active">ê³¡ì„  ëª¨ë“œ (2D)</button>
                        <button id="mode-3d" class="mode-btn">ê³¡ë©´ ëª¨ë“œ (3D)</button>
                    </div>
                </section>

                <!-- 2D Controls -->
                <div id="controls-2d">
                    <section class="panel-section">
                        <h3>âš™ï¸ ê³¡ì„  ì„¤ì •</h3>
                        
                        <div class="control-group">
                            <label>ì°¨ìˆ˜ (Degree):</label>
                            <div class="degree-buttons">
                                <button class="degree-btn" data-degree="2">2ì°¨</button>
                                <button class="degree-btn active" data-degree="3">3ì°¨</button>
                                <button class="degree-btn" data-degree="4">4ì°¨</button>
                                <button class="degree-btn" data-degree="5">5ì°¨</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>
                                t ê°’: <span id="t-value">0.50</span>
                                <small>(de Casteljau ì•Œê³ ë¦¬ì¦˜)</small>
                            </label>
                            <input type="range" id="t-slider" min="0" max="100" value="50" class="slider">
                        </div>
                    </section>

                    <section class="panel-section">
                        <h3>ğŸ‘ï¸ ì‹œê°í™” ì˜µì…˜</h3>
                        
                        <label class="checkbox-label">
                            <input type="checkbox" id="show-polygon" checked>
                            <span>ì œì–´ ë‹¤ê°í˜• ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-hull" checked>
                            <span>ë³¼ë¡ ê»ì§ˆ ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-tangents" checked>
                            <span>ì–‘ ë ì ‘ì„  ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-casteljau">
                            <span>de Casteljau ê³¼ì • ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-labels" checked>
                            <span>ì œì–´ì  ë²ˆí˜¸ ë³´ì´ê¸°</span>
                        </label>
                    </section>

                    <section class="panel-section">
                        <h3>ğŸ”— ê³¡ì„  ì—°ê²°</h3>
                        
                        <div class="control-group">
                            <button id="add-curve" class="action-btn">â• ê³¡ì„  ì¶”ê°€</button>
                        </div>

                        <div class="control-group">
                            <label>ì—°ì†ì„± ëª¨ë“œ:</label>
                            <div class="continuity-buttons">
                                <button class="continuity-btn" data-mode="none">ì—†ìŒ</button>
                                <button class="continuity-btn active" data-mode="c0">Câ°</button>
                                <button class="continuity-btn" data-mode="c1">CÂ¹</button>
                            </div>
                        </div>
                    </section>

                    <section class="panel-section">
                        <h3>ğŸ“¦ í”„ë¦¬ì…‹ (2D)</h3>
                        
                        <button class="preset-btn" id="preset-basic">ê¸°ë³¸ ê³¡ì„ </button>
                        <button class="preset-btn" id="preset-s-curve">Sì ê³¡ì„ </button>
                        <button class="preset-btn" id="preset-loop">ë£¨í”„</button>
                        <button class="preset-btn" id="preset-caricature">ìºë¦¬ì»¤ì²˜ í„±ì„ </button>
                        <button class="preset-btn danger" id="clear-all">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
                    </section>
                </div>

                <!-- 3D Controls -->
                <div id="controls-3d" class="hidden">
                    <section class="panel-section">
                        <h3>âš™ï¸ ê³¡ë©´ ì„¤ì •</h3>
                        
                        <div class="control-group">
                            <label>ì œì–´ì  ê²©ì:</label>
                            <div class="grid-buttons">
                                <button class="grid-btn" data-grid="3">3Ã—3</button>
                                <button class="grid-btn active" data-grid="4">4Ã—4</button>
                                <button class="grid-btn" data-grid="5">5Ã—5</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>
                                ê³¡ë©´ í•´ìƒë„: <span id="resolution-value">20</span>
                            </label>
                            <input type="range" id="resolution-slider" min="10" max="50" value="20" class="slider">
                        </div>
                    </section>

                    <section class="panel-section">
                        <h3>ğŸ‘ï¸ 3D ì‹œê°í™”</h3>
                        
                        <label class="checkbox-label">
                            <input type="checkbox" id="show-wireframe" checked>
                            <span>ì™€ì´ì–´í”„ë ˆì„ ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-surface" checked>
                            <span>ê³¡ë©´ ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-grid" checked>
                            <span>ì œì–´ ê²©ì ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-control-points" checked>
                            <span>ì œì–´ì  ë³´ì´ê¸°</span>
                        </label>

                        <label class="checkbox-label">
                            <input type="checkbox" id="show-axes">
                            <span>ì¢Œí‘œì¶• ë³´ì´ê¸°</span>
                        </label>
                    </section>

                    <section class="panel-section">
                        <h3>ğŸ¨ ì¬ì§ˆ ì„¤ì •</h3>
                        
                        <div class="control-group">
                            <label>ê³¡ë©´ ìƒ‰ìƒ:</label>
                            <input type="color" id="surface-color" value="#667eea" style="width: 100%; height: 40px; cursor: pointer;">
                        </div>
                    </section>

                    <section class="panel-section">
                        <h3>ğŸ“¦ í”„ë¦¬ì…‹ (3D)</h3>
                        
                        <button class="preset-btn" id="preset-flat">í‰ë©´</button>
                        <button class="preset-btn" id="preset-dome">ë” í˜•íƒœ</button>
                        <button class="preset-btn" id="preset-wave">íŒŒë„</button>
                        <button class="preset-btn" id="preset-saddle">ì•ˆì¥ë©´</button>
                        <button class="preset-btn" id="preset-twist">ë¹„í‹€ë¦¼</button>
                        <button class="preset-btn danger" id="clear-all-3d">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
                    </section>
                </div>
            </aside>

            <!-- Canvas Area -->
            <main class="canvas-area">
                <canvas id="canvas"></canvas>
                <div id="canvas-3d"></div>
                <div class="canvas-instructions" id="instructions-2d">
                    <p><strong>ì‚¬ìš©ë²• (2D):</strong></p>
                    <ul>
                        <li><kbd>í´ë¦­</kbd>: ì œì–´ì  ì¶”ê°€</li>
                        <li><kbd>ë“œë˜ê·¸</kbd>: ì œì–´ì  ì´ë™</li>
                        <li><kbd>ìš°í´ë¦­</kbd>: ì œì–´ì  ì‚­ì œ</li>
                    </ul>
                </div>
                <div class="canvas-instructions hidden" id="instructions-3d">
                    <p><strong>ì‚¬ìš©ë²• (3D):</strong></p>
                    <ul>
                        <li><kbd>ì¢Œí´ë¦­ + ë“œë˜ê·¸</kbd>: ì¹´ë©”ë¼ íšŒì „</li>
                        <li><kbd>ìš°í´ë¦­ + ë“œë˜ê·¸</kbd>: ì¹´ë©”ë¼ ì´ë™</li>
                        <li><kbd>ë§ˆìš°ìŠ¤ íœ </kbd>: í™•ëŒ€/ì¶•ì†Œ</li>
                        <li><kbd>ì œì–´ì  í´ë¦­</kbd>: ì„ íƒ ë° ì´ë™ (í™”ì‚´í‘œ ì‚¬ìš©)</li>
                    </ul>
                </div>
            </main>

            <!-- Info Panel -->
            <aside class="info-panel">
                <section class="panel-section">
                    <h3>â„¹ï¸ ì •ë³´</h3>
                    
                    <div class="info-box">
                        <h4>ì„ íƒëœ ìš”ì†Œ</h4>
                        <p id="selected-point">ì—†ìŒ</p>
                    </div>

                    <div class="info-box">
                        <h4>í˜„ì¬ ì •ë³´</h4>
                        <p id="curve-info">ì œì–´ì ì„ í´ë¦­í•˜ì—¬ ì‹œì‘í•˜ì„¸ìš”</p>
                    </div>

                    <div class="info-box">
                        <h4>í˜„ì¬ ì†ì„±</h4>
                        <ul id="current-properties">
                            <li>ì œì–´ì : 0ê°œ</li>
                        </ul>
                    </div>
                </section>

                <section class="panel-section">
                    <h3>ğŸ“š ê°œë… ì„¤ëª…</h3>
                    <div class="concept-box" id="concept-explanation">
                        <h4>ë² ì§€ì— ê³¡ì„ ì´ë€?</h4>
                        <p>ë² ì§€ì— ê³¡ì„ ì€ ì œì–´ì ë“¤ì„ ì´ìš©í•´ ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ì„ ìƒì„±í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. 
                        ë²ˆìŠ¤íƒ€ì¸ ê¸°ì € ë‹¤í•­ì‹ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì„±ì„ ê°€ì§‘ë‹ˆë‹¤:</p>
                        <ul>
                            <li><strong>ëì  ë³´ê°„:</strong> ê³¡ì„ ì´ ì²«/ë§ˆì§€ë§‰ ì œì–´ì ì„ í†µê³¼</li>
                            <li><strong>ë³¼ë¡ ê»ì§ˆ ì†ì„±:</strong> ê³¡ì„ ì´ ì œì–´ì ë“¤ì˜ ë³¼ë¡ ê»ì§ˆ ë‚´ë¶€ì— ì¡´ì¬</li>
                            <li><strong>ì ‘ì„  ì†ì„±:</strong> ì–‘ ëì—ì„œì˜ ì ‘ì„ ì´ ì œì–´ ë‹¤ê°í˜•ì˜ ë³€ê³¼ ì¼ì¹˜</li>
                        </ul>
                    </div>
                </section>

                <section class="panel-section">
                    <h3>ğŸ“ ìˆ˜í•™ì  ë°°ê²½</h3>
                    <div class="concept-box" id="math-explanation">
                        <p><strong>2D ë² ì§€ì— ê³¡ì„ :</strong></p>
                        <p style="font-family: monospace; font-size: 0.8rem;">
                            P(t) = Î£ Báµ¢,â‚™(t) Â· Páµ¢
                        </p>
                        <p><small>Báµ¢,â‚™(t) = C(n,i) Â· tâ± Â· (1-t)â¿â»â±</small></p>
                        
                        <p style="margin-top: 10px;"><strong>3D ë² ì§€ì— ê³¡ë©´:</strong></p>
                        <p style="font-family: monospace; font-size: 0.8rem;">
                            P(u,v) = Î£áµ¢ Î£â±¼ Báµ¢,â‚˜(u) Â· Bâ±¼,â‚™(v) Â· Páµ¢â±¼
                        </p>
                    </div>
                </section>
            </aside>
        </div>

        <!-- Footer -->
        <footer>
            <p>Based on "Bezier Polynomials in Computer-Aided Geometric Design" 
            by Cliff Long and Vic Norton | 
            Made with â¤ï¸ for learning | Using Three.js for 3D</p>
        </footer>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
        // ========================================
        // Interactive Bezier Lab - 2D/3D Complete
        // ========================================

        class BezierLab {
            constructor() {
                this.mode = '2d'; // '2d' or '3d'
                
                // 2D Canvas
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // 3D Scene (will be initialized when switching to 3D)
                this.scene3d = null;
                this.camera3d = null;
                this.renderer3d = null;
                this.controls3d = null;
                this.transformControl = null;
                
                // Canvas setup
                this.setupCanvas();
                
                // 2D State
                this.curves = [];
                this.currentCurveIndex = 0;
                this.degree = 3;
                this.selectedPoint = null;
                this.isDragging = false;
                this.t = 0.5;
                this.continuityMode = 'c0';
                
                // 3D State
                this.gridSize = 4;
                this.controlPoints3D = [];
                this.surfaceMesh = null;
                this.wireframeMesh = null;
                this.controlPointMeshes = [];
                this.controlGridLines = null;
                this.resolution = 20;
                this.surfaceColor = 0x667eea;
                
                // View options
                this.options = {
                    showPolygon: true,
                    showHull: true,
                    showTangents: true,
                    showCasteljau: false,
                    showLabels: true,
                    // 3D options
                    showWireframe: true,
                    showSurface: true,
                    showGrid: true,
                    showControlPoints: true,
                    showAxes: false
                };
                
                // Colors
                this.colors = {
                    curve: '#667eea',
                    controlPoly: '#fc8181',
                    hull: 'rgba(102, 126, 234, 0.1)',
                    hullStroke: 'rgba(102, 126, 234, 0.3)',
                    point: '#f093fb',
                    selectedPoint: '#48bb78',
                    tangent: '#f6ad55',
                    casteljau: ['#fc8181', '#f6ad55', '#68d391', '#4299e1']
                };
                
                // Initialize
                this.initEventListeners();
                this.addCurve();
                this.loadPreset('basic');
                this.render();
            }
            
            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
            }
            
            // ========================================
            // Mode Switching
            // ========================================
            
            switchTo2D() {
                this.mode = '2d';
                document.getElementById('canvas').style.display = 'block';
                document.getElementById('canvas-3d').style.display = 'none';
                document.getElementById('controls-2d').classList.remove('hidden');
                document.getElementById('controls-3d').classList.add('hidden');
                document.getElementById('instructions-2d').classList.remove('hidden');
                document.getElementById('instructions-3d').classList.add('hidden');
                
                if (this.renderer3d) {
                    cancelAnimationFrame(this.animationId);
                }
                
                this.render();
                this.updateInfo();
            }
            
            switchTo3D() {
                this.mode = '3d';
                document.getElementById('canvas').style.display = 'none';
                document.getElementById('canvas-3d').style.display = 'block';
                document.getElementById('controls-2d').classList.add('hidden');
                document.getElementById('controls-3d').classList.remove('hidden');
                document.getElementById('instructions-2d').classList.add('hidden');
                document.getElementById('instructions-3d').classList.remove('hidden');
                
                if (!this.scene3d) {
                    this.init3D();
                }
                
                this.loadPreset3D('dome');
                this.animate3D();
                this.updateInfo();
            }
            
            // ========================================
            // 3D Initialization
            // ========================================
            
            init3D() {
                const container = document.getElementById('canvas-3d');
                const width = container.clientWidth;
                const height = 700;
                
                // Scene
                this.scene3d = new THREE.Scene();
                this.scene3d.background = new THREE.Color(0x1a1a2e);
                
                // Camera
                this.camera3d = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                this.camera3d.position.set(8, 8, 8);
                this.camera3d.lookAt(0, 0, 0);
                
                // Renderer
                this.renderer3d = new THREE.WebGLRenderer({ antialias: true });
                this.renderer3d.setSize(width, height);
                this.renderer3d.setPixelRatio(window.devicePixelRatio);
                container.appendChild(this.renderer3d.domElement);
                
                // Orbit Controls
                this.controls3d = new THREE.OrbitControls(this.camera3d, this.renderer3d.domElement);
                this.controls3d.enableDamping = true;
                this.controls3d.dampingFactor = 0.05;
                
                // Transform Controls
                this.transformControl = new THREE.TransformControls(this.camera3d, this.renderer3d.domElement);
                this.transformControl.setMode('translate');
                this.transformControl.setSize(0.5);
                this.scene3d.add(this.transformControl);
                
                // When using transform controls, disable orbit controls
                this.transformControl.addEventListener('dragging-changed', (event) => {
                    this.controls3d.enabled = !event.value;
                    if (!event.value) {
                        this.updateSurface();
                    }
                });
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene3d.add(ambientLight);
                
                const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight1.position.set(10, 10, 10);
                this.scene3d.add(directionalLight1);
                
                const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
                directionalLight2.position.set(-10, -10, -10);
                this.scene3d.add(directionalLight2);
                
                // Grid Helper
                const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
                this.scene3d.add(gridHelper);
                
                // Axes Helper
                this.axesHelper = new THREE.AxesHelper(5);
                this.axesHelper.visible = this.options.showAxes;
                this.scene3d.add(this.axesHelper);
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    if (this.mode === '3d' && this.camera3d && this.renderer3d) {
                        const width = container.clientWidth;
                        this.camera3d.aspect = width / height;
                        this.camera3d.updateProjectionMatrix();
                        this.renderer3d.setSize(width, height);
                    }
                });
            }
            
            // ========================================
            // 3D Control Points Management
            // ========================================
            
            createControlGrid(size) {
                this.gridSize = size;
                this.controlPoints3D = [];
                
                // Create grid of control points
                const spacing = 4 / (size - 1);
                const offset = -2;
                
                for (let i = 0; i < size; i++) {
                    this.controlPoints3D[i] = [];
                    for (let j = 0; j < size; j++) {
                        const x = offset + i * spacing;
                        const z = offset + j * spacing;
                        const y = 0; // Will be modified by presets
                        
                        this.controlPoints3D[i][j] = new THREE.Vector3(x, y, z);
                    }
                }
                
                this.updateControlPointMeshes();
                this.updateControlGridLines();
                this.updateSurface();
            }
            
            updateControlPointMeshes() {
                // Remove old meshes
                this.controlPointMeshes.forEach(mesh => {
                    this.scene3d.remove(mesh);
                });
                this.controlPointMeshes = [];
                
                if (!this.options.showControlPoints) return;
                
                // Create sphere for each control point
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                const material = new THREE.MeshPhongMaterial({ color: 0xf093fb });
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.copy(this.controlPoints3D[i][j]);
                        mesh.userData = { i, j };
                        this.scene3d.add(mesh);
                        this.controlPointMeshes.push(mesh);
                        
                        // Make clickable
                        mesh.callback = () => {
                            this.transformControl.attach(mesh);
                        };
                    }
                }
                
                // Add click handler
                this.renderer3d.domElement.addEventListener('click', (event) => {
                    const raycaster = new THREE.Raycaster();
                    const mouse = new THREE.Vector2();
                    
                    const rect = this.renderer3d.domElement.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, this.camera3d);
                    const intersects = raycaster.intersectObjects(this.controlPointMeshes);
                    
                    if (intersects.length > 0) {
                        const mesh = intersects[0].object;
                        this.transformControl.attach(mesh);
                    } else {
                        this.transformControl.detach();
                    }
                });
            }
            
            updateControlGridLines() {
                // Remove old lines
                if (this.controlGridLines) {
                    this.scene3d.remove(this.controlGridLines);
                }
                
                if (!this.options.showGrid) return;
                
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                
                // Horizontal lines
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize - 1; j++) {
                        positions.push(
                            this.controlPoints3D[i][j].x,
                            this.controlPoints3D[i][j].y,
                            this.controlPoints3D[i][j].z,
                            this.controlPoints3D[i][j + 1].x,
                            this.controlPoints3D[i][j + 1].y,
                            this.controlPoints3D[i][j + 1].z
                        );
                    }
                }
                
                // Vertical lines
                for (let j = 0; j < this.gridSize; j++) {
                    for (let i = 0; i < this.gridSize - 1; i++) {
                        positions.push(
                            this.controlPoints3D[i][j].x,
                            this.controlPoints3D[i][j].y,
                            this.controlPoints3D[i][j].z,
                            this.controlPoints3D[i + 1][j].x,
                            this.controlPoints3D[i + 1][j].y,
                            this.controlPoints3D[i + 1][j].z
                        );
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const material = new THREE.LineBasicMaterial({ color: 0xfc8181, linewidth: 2 });
                this.controlGridLines = new THREE.LineSegments(geometry, material);
                this.scene3d.add(this.controlGridLines);
            }
            
            // ========================================
            // Bezier Surface Mathematics
            // ========================================
            
            bernstein(n, i, t) {
                const binomial = (n, k) => {
                    if (k < 0 || k > n) return 0;
                    if (k === 0 || k === n) return 1;
                    let result = 1;
                    for (let i = 1; i <= k; i++) {
                        result *= (n - i + 1) / i;
                    }
                    return result;
                };
                
                return binomial(n, i) * Math.pow(t, i) * Math.pow(1 - t, n - i);
            }
            
            bezierSurfacePoint(u, v) {
                const n = this.gridSize - 1;
                const m = this.gridSize - 1;
                
                let point = new THREE.Vector3(0, 0, 0);
                
                for (let i = 0; i <= n; i++) {
                    for (let j = 0; j <= m; j++) {
                        const bu = this.bernstein(n, i, u);
                        const bv = this.bernstein(m, j, v);
                        const weight = bu * bv;
                        
                        const cp = this.controlPoints3D[i][j];
                        point.x += weight * cp.x;
                        point.y += weight * cp.y;
                        point.z += weight * cp.z;
                    }
                }
                
                return point;
            }
            
            updateSurface() {
                // Update control point positions from meshes
                this.controlPointMeshes.forEach(mesh => {
                    const { i, j } = mesh.userData;
                    this.controlPoints3D[i][j].copy(mesh.position);
                });
                
                // Remove old surface
                if (this.surfaceMesh) {
                    this.scene3d.remove(this.surfaceMesh);
                }
                if (this.wireframeMesh) {
                    this.scene3d.remove(this.wireframeMesh);
                }
                
                // Generate surface geometry
                const positions = [];
                const indices = [];
                const normals = [];
                
                const res = this.resolution;
                
                for (let i = 0; i <= res; i++) {
                    for (let j = 0; j <= res; j++) {
                        const u = i / res;
                        const v = j / res;
                        
                        const point = this.bezierSurfacePoint(u, v);
                        positions.push(point.x, point.y, point.z);
                        
                        // Calculate normal (simplified)
                        const epsilon = 0.01;
                        const pu = this.bezierSurfacePoint(Math.min(u + epsilon, 1), v);
                        const pv = this.bezierSurfacePoint(u, Math.min(v + epsilon, 1));
                        
                        const du = new THREE.Vector3().subVectors(pu, point);
                        const dv = new THREE.Vector3().subVectors(pv, point);
                        const normal = new THREE.Vector3().crossVectors(du, dv).normalize();
                        
                        normals.push(normal.x, normal.y, normal.z);
                    }
                }
                
                // Generate indices
                for (let i = 0; i < res; i++) {
                    for (let j = 0; j < res; j++) {
                        const a = i * (res + 1) + j;
                        const b = a + 1;
                        const c = a + (res + 1);
                        const d = c + 1;
                        
                        indices.push(a, b, c);
                        indices.push(b, d, c);
                    }
                }
                
                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
                geometry.setIndex(indices);
                
                // Surface mesh
                if (this.options.showSurface) {
                    const material = new THREE.MeshPhongMaterial({
                        color: this.surfaceColor,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.8
                    });
                    this.surfaceMesh = new THREE.Mesh(geometry, material);
                    this.scene3d.add(this.surfaceMesh);
                }
                
                // Wireframe mesh
                if (this.options.showWireframe) {
                    const wireframeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x667eea,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.3
                    });
                    this.wireframeMesh = new THREE.Mesh(geometry, wireframeMaterial);
                    this.scene3d.add(this.wireframeMesh);
                }
                
                this.updateControlGridLines();
            }
            
            // ========================================
            // 3D Animation Loop
            // ========================================
            
            animate3D() {
                this.animationId = requestAnimationFrame(() => this.animate3D());
                
                this.controls3d.update();
                this.renderer3d.render(this.scene3d, this.camera3d);
            }
            
            // ========================================
            // 3D Presets
            // ========================================
            
            loadPreset3D(name) {
                this.createControlGrid(this.gridSize);
                
                const size = this.gridSize;
                
                switch (name) {
                    case 'flat':
                        // Already flat (y = 0)
                        break;
                        
                    case 'dome':
                        for (let i = 0; i < size; i++) {
                            for (let j = 0; j < size; j++) {
                                const x = (i / (size - 1)) * 2 - 1;
                                const z = (j / (size - 1)) * 2 - 1;
                                const dist = Math.sqrt(x * x + z * z);
                                this.controlPoints3D[i][j].y = Math.max(0, 2 * (1 - dist));
                            }
                        }
                        break;
                        
                    case 'wave':
                        for (let i = 0; i < size; i++) {
                            for (let j = 0; j < size; j++) {
                                const x = (i / (size - 1)) * Math.PI * 2;
                                const z = (j / (size - 1)) * Math.PI * 2;
                                this.controlPoints3D[i][j].y = Math.sin(x) * Math.cos(z) * 1.5;
                            }
                        }
                        break;
                        
                    case 'saddle':
                        for (let i = 0; i < size; i++) {
                            for (let j = 0; j < size; j++) {
                                const x = (i / (size - 1)) * 2 - 1;
                                const z = (j / (size - 1)) * 2 - 1;
                                this.controlPoints3D[i][j].y = (x * x - z * z) * 1.5;
                            }
                        }
                        break;
                        
                    case 'twist':
                        for (let i = 0; i < size; i++) {
                            for (let j = 0; j < size; j++) {
                                const u = i / (size - 1);
                                const v = j / (size - 1);
                                const angle = u * Math.PI / 2;
                                const x = this.controlPoints3D[i][j].x;
                                const z = this.controlPoints3D[i][j].z;
                                this.controlPoints3D[i][j].y = Math.sin(angle) * (v - 0.5) * 2;
                            }
                        }
                        break;
                }
                
                this.updateControlPointMeshes();
                this.updateSurface();
            }
            
            // ========================================
            // 2D Methods (from previous implementation)
            // ========================================
            
            addCurve() {
                const curve = {
                    points: [],
                    color: this.colors.curve
                };
                this.curves.push(curve);
                this.currentCurveIndex = this.curves.length - 1;
                this.updateInfo();
            }
            
            initEventListeners() {
                // Mode switching
                document.getElementById('mode-2d').addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('mode-2d').classList.add('active');
                    this.switchTo2D();
                });
                
                document.getElementById('mode-3d').addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    document.getElementById('mode-3d').classList.add('active');
                    this.switchTo3D();
                });
                
                // 2D Canvas events
                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('contextmenu', (e) => this.onRightClick(e));
                
                // 2D Degree buttons
                document.querySelectorAll('.degree-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.degree-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.degree = parseInt(e.target.dataset.degree);
                        this.updateInfo();
                    });
                });
                
                // 2D T slider
                const tSlider = document.getElementById('t-slider');
                tSlider.addEventListener('input', (e) => {
                    this.t = e.target.value / 100;
                    document.getElementById('t-value').textContent = this.t.toFixed(2);
                    this.render();
                });
                
                // 2D Checkboxes
                document.getElementById('show-polygon').addEventListener('change', (e) => {
                    this.options.showPolygon = e.target.checked;
                    this.render();
                });
                
                document.getElementById('show-hull').addEventListener('change', (e) => {
                    this.options.showHull = e.target.checked;
                    this.render();
                });
                
                document.getElementById('show-tangents').addEventListener('change', (e) => {
                    this.options.showTangents = e.target.checked;
                    this.render();
                });
                
                document.getElementById('show-casteljau').addEventListener('change', (e) => {
                    this.options.showCasteljau = e.target.checked;
                    this.render();
                });
                
                document.getElementById('show-labels').addEventListener('change', (e) => {
                    this.options.showLabels = e.target.checked;
                    this.render();
                });
                
                // 2D Continuity buttons
                document.querySelectorAll('.continuity-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.continuity-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.continuityMode = e.target.dataset.mode;
                        this.updateInfo();
                    });
                });
                
                // 2D Add curve button
                document.getElementById('add-curve').addEventListener('click', () => {
                    this.addCurve();
                    this.render();
                });
                
                // 2D Preset buttons
                document.getElementById('preset-basic').addEventListener('click', () => this.loadPreset('basic'));
                document.getElementById('preset-s-curve').addEventListener('click', () => this.loadPreset('s-curve'));
                document.getElementById('preset-loop').addEventListener('click', () => this.loadPreset('loop'));
                document.getElementById('preset-caricature').addEventListener('click', () => this.loadPreset('caricature'));
                document.getElementById('clear-all').addEventListener('click', () => this.clearAll());
                
                // 3D Grid size buttons
                document.querySelectorAll('.grid-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.grid-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.gridSize = parseInt(e.target.dataset.grid);
                        this.createControlGrid(this.gridSize);
                    });
                });
                
                // 3D Resolution slider
                document.getElementById('resolution-slider').addEventListener('input', (e) => {
                    this.resolution = parseInt(e.target.value);
                    document.getElementById('resolution-value').textContent = this.resolution;
                    this.updateSurface();
                });
                
                // 3D Checkboxes
                document.getElementById('show-wireframe').addEventListener('change', (e) => {
                    this.options.showWireframe = e.target.checked;
                    this.updateSurface();
                });
                
                document.getElementById('show-surface').addEventListener('change', (e) => {
                    this.options.showSurface = e.target.checked;
                    this.updateSurface();
                });
                
                document.getElementById('show-grid').addEventListener('change', (e) => {
                    this.options.showGrid = e.target.checked;
                    this.updateControlGridLines();
                });
                
                document.getElementById('show-control-points').addEventListener('change', (e) => {
                    this.options.showControlPoints = e.target.checked;
                    this.updateControlPointMeshes();
                });
                
                document.getElementById('show-axes').addEventListener('change', (e) => {
                    this.options.showAxes = e.target.checked;
                    if (this.axesHelper) {
                        this.axesHelper.visible = e.target.checked;
                    }
                });
                
                // 3D Surface color
                document.getElementById('surface-color').addEventListener('input', (e) => {
                    this.surfaceColor = parseInt(e.target.value.replace('#', '0x'));
                    this.updateSurface();
                });
                
                // 3D Preset buttons
                document.getElementById('preset-flat').addEventListener('click', () => this.loadPreset3D('flat'));
                document.getElementById('preset-dome').addEventListener('click', () => this.loadPreset3D('dome'));
                document.getElementById('preset-wave').addEventListener('click', () => this.loadPreset3D('wave'));
                document.getElementById('preset-saddle').addEventListener('click', () => this.loadPreset3D('saddle'));
                document.getElementById('preset-twist').addEventListener('click', () => this.loadPreset3D('twist'));
                document.getElementById('clear-all-3d').addEventListener('click', () => this.loadPreset3D('flat'));
                
                // Window resize
                window.addEventListener('resize', () => {
                    if (this.mode === '2d') {
                        this.setupCanvas();
                        this.render();
                    }
                });
            }
            
            // 2D Mouse Events
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            findPointAt(pos) {
                const threshold = 10;
                for (let curveIdx = 0; curveIdx < this.curves.length; curveIdx++) {
                    const curve = this.curves[curveIdx];
                    for (let i = 0; i < curve.points.length; i++) {
                        const p = curve.points[i];
                        const dist = Math.sqrt((p.x - pos.x) ** 2 + (p.y - pos.y) ** 2);
                        if (dist < threshold) {
                            return { curveIdx, pointIdx: i };
                        }
                    }
                }
                return null;
            }
            
            onMouseDown(e) {
                if (this.mode !== '2d') return;
                
                const pos = this.getMousePos(e);
                const found = this.findPointAt(pos);
                
                if (found) {
                    this.selectedPoint = found;
                    this.isDragging = true;
                } else {
                    const curve = this.curves[this.currentCurveIndex];
                    if (curve.points.length < this.degree + 1) {
                        curve.points.push({ x: pos.x, y: pos.y });
                        this.applyContinuity();
                    }
                }
                
                this.updateInfo();
                this.render();
            }
            
            onMouseMove(e) {
                if (this.mode !== '2d') return;
                
                const pos = this.getMousePos(e);
                
                if (this.isDragging && this.selectedPoint) {
                    const curve = this.curves[this.selectedPoint.curveIdx];
                    curve.points[this.selectedPoint.pointIdx] = { x: pos.x, y: pos.y };
                    this.applyContinuity();
                    this.updateInfo();
                    this.render();
                }
            }
            
            onMouseUp(e) {
                this.isDragging = false;
            }
            
            onRightClick(e) {
                if (this.mode !== '2d') return;
                
                e.preventDefault();
                const pos = this.getMousePos(e);
                const found = this.findPointAt(pos);
                
                if (found) {
                    this.curves[found.curveIdx].points.splice(found.pointIdx, 1);
                    this.selectedPoint = null;
                    this.updateInfo();
                    this.render();
                }
            }
            
            // 2D Continuity
            applyContinuity() {
                if (this.curves.length < 2) return;
                if (this.continuityMode === 'none') return;
                
                for (let i = 0; i < this.curves.length - 1; i++) {
                    const curveA = this.curves[i];
                    const curveB = this.curves[i + 1];
                    
                    if (curveA.points.length === 0 || curveB.points.length === 0) continue;
                    
                    if (this.continuityMode === 'c0' || this.continuityMode === 'c1') {
                        const lastA = curveA.points[curveA.points.length - 1];
                        curveB.points[0] = { ...lastA };
                    }
                    
                    if (this.continuityMode === 'c1' && curveA.points.length >= 2 && curveB.points.length >= 2) {
                        const lastA = curveA.points[curveA.points.length - 1];
                        const secondLastA = curveA.points[curveA.points.length - 2];
                        
                        const dx = lastA.x - secondLastA.x;
                        const dy = lastA.y - secondLastA.y;
                        
                        curveB.points[1] = {
                            x: lastA.x + dx,
                            y: lastA.y + dy
                        };
                    }
                }
            }
            
            // 2D Bezier Math
            binomial(n, k) {
                if (k < 0 || k > n) return 0;
                if (k === 0 || k === n) return 1;
                
                let result = 1;
                for (let i = 1; i <= k; i++) {
                    result *= (n - i + 1) / i;
                }
                return result;
            }
            
            bernstein2D(n, i, t) {
                return this.binomial(n, i) * Math.pow(t, i) * Math.pow(1 - t, n - i);
            }
            
            bezierPoint(points, t) {
                const n = points.length - 1;
                let x = 0, y = 0;
                
                for (let i = 0; i <= n; i++) {
                    const b = this.bernstein2D(n, i, t);
                    x += b * points[i].x;
                    y += b * points[i].y;
                }
                
                return { x, y };
            }
            
            deCasteljau(points, t) {
                if (points.length === 0) return [];
                
                const levels = [points.map(p => ({ ...p }))];
                
                for (let k = 1; k < points.length; k++) {
                    const prevLevel = levels[k - 1];
                    const newLevel = [];
                    
                    for (let i = 0; i < prevLevel.length - 1; i++) {
                        const p0 = prevLevel[i];
                        const p1 = prevLevel[i + 1];
                        newLevel.push({
                            x: (1 - t) * p0.x + t * p1.x,
                            y: (1 - t) * p0.y + t * p1.y
                        });
                    }
                    
                    levels.push(newLevel);
                }
                
                return levels;
            }
            
            convexHull(points) {
                if (points.length < 3) return points;
                
                const sorted = points.slice().sort((a, b) => {
                    return a.x === b.x ? a.y - b.y : a.x - b.x;
                });
                
                const cross = (o, a, b) => {
                    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
                };
                
                const lower = [];
                for (let i = 0; i < sorted.length; i++) {
                    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], sorted[i]) <= 0) {
                        lower.pop();
                    }
                    lower.push(sorted[i]);
                }
                
                const upper = [];
                for (let i = sorted.length - 1; i >= 0; i--) {
                    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], sorted[i]) <= 0) {
                        upper.pop();
                    }
                    upper.push(sorted[i]);
                }
                
                lower.pop();
                upper.pop();
                
                return lower.concat(upper);
            }
            
            // 2D Rendering
            render() {
                if (this.mode !== '2d') return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.curves.forEach((curve, idx) => {
                    if (curve.points.length === 0) return;
                    
                    if (this.options.showHull && curve.points.length >= 3) {
                        this.drawConvexHull(curve.points);
                    }
                    
                    if (this.options.showPolygon) {
                        this.drawControlPolygon(curve.points);
                    }
                    
                    if (curve.points.length >= 2) {
                        this.drawBezierCurve(curve.points);
                    }
                    
                    if (this.options.showTangents && curve.points.length >= 2) {
                        this.drawTangents(curve.points);
                    }
                    
                    if (this.options.showCasteljau && curve.points.length >= 2) {
                        this.drawDeCasteljau(curve.points, this.t);
                    }
                    
                    this.drawControlPoints(curve.points, idx);
                });
            }
            
            drawControlPolygon(points) {
                if (points.length < 2) return;
                
                this.ctx.strokeStyle = this.colors.controlPoly;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                this.ctx.beginPath();
                this.ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i].x, points[i].y);
                }
                this.ctx.stroke();
                
                this.ctx.setLineDash([]);
            }
            
            drawBezierCurve(points) {
                if (points.length < 2) return;
                
                this.ctx.strokeStyle = this.colors.curve;
                this.ctx.lineWidth = 3;
                
                this.ctx.beginPath();
                const startPoint = this.bezierPoint(points, 0);
                this.ctx.moveTo(startPoint.x, startPoint.y);
                
                const steps = 100;
                for (let i = 1; i <= steps; i++) {
                    const t = i / steps;
                    const point = this.bezierPoint(points, t);
                    this.ctx.lineTo(point.x, point.y);
                }
                
                this.ctx.stroke();
            }
            
            drawControlPoints(points, curveIdx) {
                points.forEach((point, idx) => {
                    const isSelected = this.selectedPoint && 
                                      this.selectedPoint.curveIdx === curveIdx && 
                                      this.selectedPoint.pointIdx === idx;
                    
                    this.ctx.fillStyle = isSelected ? this.colors.selectedPoint : this.colors.point;
                    this.ctx.beginPath();
                    this.ctx.arc(point.x, point.y, isSelected ? 8 : 6, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                    
                    if (this.options.showLabels) {
                        this.ctx.fillStyle = '#2d3748';
                        this.ctx.font = 'bold 12px sans-serif';
                        this.ctx.fillText(`P${idx}`, point.x + 12, point.y - 8);
                    }
                });
            }
            
            drawConvexHull(points) {
                const hull = this.convexHull(points);
                if (hull.length < 3) return;
                
                this.ctx.fillStyle = this.colors.hull;
                this.ctx.beginPath();
                this.ctx.moveTo(hull[0].x, hull[0].y);
                for (let i = 1; i < hull.length; i++) {
                    this.ctx.lineTo(hull[i].x, hull[i].y);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.strokeStyle = this.colors.hullStroke;
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([3, 3]);
                this.ctx.stroke();
                this.ctx.setLineDash([]);
            }
            
            drawTangents(points) {
                if (points.length < 2) return;
                
                const tangentLength = 100;
                
                const startDir = {
                    x: points[1].x - points[0].x,
                    y: points[1].y - points[0].y
                };
                const startLen = Math.sqrt(startDir.x ** 2 + startDir.y ** 2);
                if (startLen > 0) {
                    startDir.x /= startLen;
                    startDir.y /= startLen;
                    
                    this.ctx.strokeStyle = this.colors.tangent;
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([10, 5]);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0].x, points[0].y);
                    this.ctx.lineTo(
                        points[0].x + startDir.x * tangentLength,
                        points[0].y + startDir.y * tangentLength
                    );
                    this.ctx.stroke();
                }
                
                const n = points.length - 1;
                const endDir = {
                    x: points[n].x - points[n - 1].x,
                    y: points[n].y - points[n - 1].y
                };
                const endLen = Math.sqrt(endDir.x ** 2 + endDir.y ** 2);
                if (endLen > 0) {
                    endDir.x /= endLen;
                    endDir.y /= endLen;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[n].x, points[n].y);
                    this.ctx.lineTo(
                        points[n].x + endDir.x * tangentLength,
                        points[n].y + endDir.y * tangentLength
                    );
                    this.ctx.stroke();
                }
                
                this.ctx.setLineDash([]);
            }
            
            drawDeCasteljau(points, t) {
                const levels = this.deCasteljau(points, t);
                
                levels.forEach((level, levelIdx) => {
                    if (levelIdx === 0) return;
                    
                    const color = this.colors.casteljau[levelIdx % this.colors.casteljau.length];
                    
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 1;
                    this.ctx.setLineDash([2, 2]);
                    
                    for (let i = 0; i < level.length - 1; i++) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(level[i].x, level[i].y);
                        this.ctx.lineTo(level[i + 1].x, level[i + 1].y);
                        this.ctx.stroke();
                    }
                    
                    level.forEach(point => {
                        this.ctx.fillStyle = color;
                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                        this.ctx.fill();
                    });
                });
                
                if (levels.length > 0) {
                    const finalLevel = levels[levels.length - 1];
                    if (finalLevel.length > 0) {
                        const finalPoint = finalLevel[0];
                        this.ctx.fillStyle = '#48bb78';
                        this.ctx.beginPath();
                        this.ctx.arc(finalPoint.x, finalPoint.y, 8, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        this.ctx.strokeStyle = 'white';
                        this.ctx.lineWidth = 2;
                        this.ctx.stroke();
                    }
                }
                
                this.ctx.setLineDash([]);
            }
            
            // 2D Presets
            loadPreset(name) {
                this.curves = [];
                
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                switch (name) {
                    case 'basic':
                        this.curves = [{
                            points: [
                                { x: w * 0.2, y: h * 0.7 },
                                { x: w * 0.3, y: h * 0.2 },
                                { x: w * 0.7, y: h * 0.3 },
                                { x: w * 0.8, y: h * 0.7 }
                            ],
                            color: this.colors.curve
                        }];
                        break;
                        
                    case 's-curve':
                        this.curves = [{
                            points: [
                                { x: w * 0.2, y: h * 0.5 },
                                { x: w * 0.3, y: h * 0.2 },
                                { x: w * 0.5, y: h * 0.2 },
                                { x: w * 0.5, y: h * 0.5 },
                                { x: w * 0.5, y: h * 0.8 },
                                { x: w * 0.7, y: h * 0.8 },
                                { x: w * 0.8, y: h * 0.5 }
                            ],
                            color: this.colors.curve
                        }];
                        this.degree = 6;
                        document.querySelector('[data-degree="5"]').click();
                        break;
                        
                    case 'loop':
                        this.curves = [{
                            points: [
                                { x: w * 0.3, y: h * 0.5 },
                                { x: w * 0.3, y: h * 0.2 },
                                { x: w * 0.7, y: h * 0.2 },
                                { x: w * 0.7, y: h * 0.8 },
                                { x: w * 0.3, y: h * 0.8 },
                                { x: w * 0.3, y: h * 0.5 }
                            ],
                            color: this.colors.curve
                        }];
                        this.degree = 5;
                        document.querySelector('[data-degree="5"]').click();
                        break;
                        
                    case 'caricature':
                        this.curves = [{
                            points: [
                                { x: w * 0.15, y: h * 0.3 },
                                { x: w * 0.2, y: h * 0.5 },
                                { x: w * 0.3, y: h * 0.75 },
                                { x: w * 0.5, y: h * 0.85 },
                                { x: w * 0.7, y: h * 0.75 },
                                { x: w * 0.8, y: h * 0.5 },
                                { x: w * 0.85, y: h * 0.3 }
                            ],
                            color: this.colors.curve
                        }];
                        this.degree = 6;
                        document.querySelector('[data-degree="5"]').click();
                        break;
                }
                
                this.currentCurveIndex = 0;
                this.selectedPoint = null;
                this.updateInfo();
                this.render();
            }
            
            clearAll() {
                this.curves = [];
                this.addCurve();
                this.selectedPoint = null;
                this.updateInfo();
                this.render();
            }
            
            // UI Updates
            updateInfo() {
                if (this.mode === '2d') {
                    // Selected point
                    if (this.selectedPoint) {
                        const point = this.curves[this.selectedPoint.curveIdx].points[this.selectedPoint.pointIdx];
                        document.getElementById('selected-point').innerHTML = 
                            `<strong>ê³¡ì„  ${this.selectedPoint.curveIdx}, ì  P${this.selectedPoint.pointIdx}</strong><br>
                             x: ${point.x.toFixed(1)}, y: ${point.y.toFixed(1)}`;
                    } else {
                        document.getElementById('selected-point').textContent = 'ì—†ìŒ';
                    }
                    
                    const totalPoints = this.curves.reduce((sum, curve) => sum + curve.points.length, 0);
                    document.getElementById('curve-info').innerHTML = 
                        `í˜„ì¬ ì°¨ìˆ˜: <strong>${this.degree}</strong><br>
                         í•„ìš”í•œ ì œì–´ì : <strong>${this.degree + 1}ê°œ</strong>`;
                    
                    document.getElementById('current-properties').innerHTML = `
                        <li>ì œì–´ì : <strong>${totalPoints}ê°œ</strong></li>
                        <li>ê³¡ì„ : <strong>${this.curves.length}ê°œ</strong></li>
                        <li>ì—°ì†ì„±: <strong>${this.continuityMode.toUpperCase()}</strong></li>
                    `;
                } else {
                    // 3D mode
                    const totalPoints = this.gridSize * this.gridSize;
                    
                    document.getElementById('selected-point').textContent = 
                        this.transformControl.object ? 
                        `ì œì–´ì  ì„ íƒë¨ (í™”ì‚´í‘œë¡œ ì´ë™)` : 
                        'ì—†ìŒ';
                    
                    document.getElementById('curve-info').innerHTML = 
                        `ê²©ì í¬ê¸°: <strong>${this.gridSize}Ã—${this.gridSize}</strong><br>
                         í•´ìƒë„: <strong>${this.resolution}Ã—${this.resolution}</strong>`;
                    
                    document.getElementById('current-properties').innerHTML = `
                        <li>ì œì–´ì : <strong>${totalPoints}ê°œ</strong></li>
                        <li>ê³¡ë©´ ì •ì : <strong>${(this.resolution + 1) * (this.resolution + 1)}ê°œ</strong></li>
                    `;
                }
                
                this.updateConceptExplanation();
            }
            
            updateConceptExplanation() {
                const conceptBox = document.getElementById('concept-explanation');
                
                if (this.mode === '3d') {
                    conceptBox.innerHTML = `
                        <h4>ğŸ“ ë² ì§€ì— ê³¡ë©´</h4>
                        <p>ë² ì§€ì— ê³¡ë©´ì€ 2D ë² ì§€ì— ê³¡ì„ ì„ 3Dë¡œ í™•ì¥í•œ ê²ƒì…ë‹ˆë‹¤.</p>
                        <ul>
                            <li><strong>ì œì–´ì  ê²©ì:</strong> ${this.gridSize}Ã—${this.gridSize} ì œì–´ì ìœ¼ë¡œ ê³¡ë©´ í˜•ìƒ ê²°ì •</li>
                            <li><strong>ì´ì¤‘ ë¸”ë Œë”©:</strong> u, v ë‘ ë°©í–¥ìœ¼ë¡œ ë²ˆìŠ¤íƒ€ì¸ ë‹¤í•­ì‹ ì ìš©</li>
                            <li><strong>ëª¨ì„œë¦¬ ë³´ê°„:</strong> ê³¡ë©´ì´ ê²½ê³„ì˜ ì œì–´ì ë“¤ì„ í†µê³¼</li>
                            <li><strong>CAD/CAM:</strong> ìë™ì°¨ ì°¨ì²´, í•­ê³µê¸° ë‚ ê°œ ë“± ì„¤ê³„ì— í™œìš©</li>
                        </ul>
                    `;
                } else if (this.options.showCasteljau) {
                    conceptBox.innerHTML = `
                        <h4>ğŸ¯ de Casteljau ì•Œê³ ë¦¬ì¦˜</h4>
                        <p>í˜„ì¬ t = ${this.t.toFixed(2)}ì—ì„œì˜ ê³„ì‚° ê³¼ì •ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.</p>
                        <ul>
                            <li>ê° ìƒ‰ìƒì€ ê³„ì‚° ë‹¨ê³„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤</li>
                            <li>ì¸ì ‘í•œ ì ë“¤ì„ ${this.t.toFixed(2)}:${(1-this.t).toFixed(2)} ë¹„ìœ¨ë¡œ ë‚´ë¶„</li>
                            <li>ë…¹ìƒ‰ ì ì´ ìµœì¢… ê³¡ì„  ìœ„ì˜ ì ì…ë‹ˆë‹¤</li>
                        </ul>
                    `;
                } else if (this.options.showHull) {
                    conceptBox.innerHTML = `
                        <h4>ğŸ“¦ ë³¼ë¡ ê»ì§ˆ ì†ì„±</h4>
                        <p>ë² ì§€ì— ê³¡ì„ ì˜ ì¤‘ìš”í•œ íŠ¹ì„± ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.</p>
                        <ul>
                            <li>ê³¡ì„ ì€ ì ˆëŒ€ë¡œ ì œì–´ì ë“¤ì˜ ë³¼ë¡ ê»ì§ˆì„ ë²—ì–´ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤</li>
                            <li>ì´ëŠ” ê³¡ì„ ì˜ ì˜ˆì¸¡ ê°€ëŠ¥ì„±ì„ ë³´ì¥í•©ë‹ˆë‹¤</li>
                            <li>CAD ì‹œìŠ¤í…œì—ì„œ ì¶©ëŒ ê°ì§€ ë“±ì— í™œìš©ë©ë‹ˆë‹¤</li>
                        </ul>
                    `;
                } else {
                    conceptBox.innerHTML = `
                        <h4>ë² ì§€ì— ê³¡ì„ ì´ë€?</h4>
                        <p>ë² ì§€ì— ê³¡ì„ ì€ ì œì–´ì ë“¤ì„ ì´ìš©í•´ ë¶€ë“œëŸ¬ìš´ ê³¡ì„ ì„ ìƒì„±í•˜ëŠ” ë°©ë²•ì…ë‹ˆë‹¤. 
                        ë²ˆìŠ¤íƒ€ì¸ ê¸°ì € ë‹¤í•­ì‹ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë©°, ë‹¤ìŒê³¼ ê°™ì€ íŠ¹ì„±ì„ ê°€ì§‘ë‹ˆë‹¤:</p>
                        <ul>
                            <li><strong>ëì  ë³´ê°„:</strong> ê³¡ì„ ì´ ì²«/ë§ˆì§€ë§‰ ì œì–´ì ì„ í†µê³¼</li>
                            <li><strong>ë³¼ë¡ ê»ì§ˆ ì†ì„±:</strong> ê³¡ì„ ì´ ì œì–´ì ë“¤ì˜ ë³¼ë¡ ê»ì§ˆ ë‚´ë¶€ì— ì¡´ì¬</li>
                            <li><strong>ì ‘ì„  ì†ì„±:</strong> ì–‘ ëì—ì„œì˜ ì ‘ì„ ì´ ì œì–´ ë‹¤ê°í˜•ì˜ ë³€ê³¼ ì¼ì¹˜</li>
                        </ul>
                    `;
                }
            }
        }

        // Initialize the application
        let lab;
        window.addEventListener('DOMContentLoaded', () => {
            lab = new BezierLab();
        });
    </script>
</body>
</html>
