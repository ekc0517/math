<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í¬ë¬¼ì„  ê±°ìš¸ì˜ ë°˜ì‚¬ ì„±ì§ˆ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
        }

        .control-panel {
            width: 340px;
            min-width: 340px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #00d9ff;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 1px solid #0f3460;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .control-group {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #0f3460;
        }

        .control-group h3 {
            font-size: 0.95em;
            color: #ffd93d;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #ffd93d;
            border-radius: 50%;
        }

        .slider-container {
            margin-bottom: 12px;
        }

        .slider-container label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85em;
            color: #ccc;
        }

        .slider-container label span {
            color: #00d9ff;
            font-weight: bold;
            font-family: 'Consolas', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #0f3460, #00d9ff);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ffd93d;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 217, 61, 0.5);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.85em;
            cursor: pointer;
        }

        .checkbox-container input {
            width: 18px;
            height: 18px;
            accent-color: #00d9ff;
            cursor: pointer;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .action-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-start {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-start:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-reset {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            color: white;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8em;
            line-height: 1.6;
        }

        .info-box .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
            color: #ffd93d;
            text-align: center;
            margin: 10px 0;
            font-style: italic;
        }

        .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 80px;
            padding: 10px 8px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #ccc;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: #1a4a7a;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00d9ff, #0f3460);
            color: white;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
        }

        .theory-text {
            font-size: 0.78em;
            line-height: 1.7;
            color: #aaa;
            text-align: justify;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: #0d1421;
        }

        #mainCanvas {
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.2);
            cursor: crosshair;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.75em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4em;
            color: #00d9ff;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
        }

        @media (max-width: 900px) {
            body {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                min-width: auto;
                max-height: 40vh;
                border-right: none;
                border-bottom: 2px solid #0f3460;
            }
            .canvas-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <h1 class="panel-title">ğŸ”­ ê´‘í•™ ë°˜ì‚¬ ì‹œë®¬ë ˆì´í„°</h1>

        <!-- ì‹œë®¬ë ˆì´ì…˜ ì»¨íŠ¸ë¡¤ -->
        <div class="control-group">
            <h3>ì‹œë®¬ë ˆì´ì…˜ ì œì–´</h3>
            <div class="btn-group">
                <button class="action-btn btn-start" id="btnStart">â–¶ ë°œì‚¬</button>
                <button class="action-btn btn-stop" id="btnStop">â¸ ì •ì§€</button>
                <button class="action-btn btn-reset" id="btnReset">â†º ë¦¬ì…‹</button>
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="activeRays">0</div>
                    <div class="stat-label">í™œì„± ê´‘ì„ </div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="reflectedCount">0</div>
                    <div class="stat-label">ì´ ë°˜ì‚¬ íšŸìˆ˜</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="focusPassCount">0</div>
                    <div class="stat-label">ì´ˆì  í†µê³¼</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="completedCount">0</div>
                    <div class="stat-label">ì™„ë£Œ</div>
                </div>
            </div>
        </div>

        <!-- ê³¡ì„  ì„ íƒ -->
        <div class="control-group">
            <h3>ê³¡ì„  ìœ í˜• ì„ íƒ</h3>
            <div class="mode-buttons">
                <button class="mode-btn active" data-mode="parabola">í¬ë¬¼ì„ </button>
                <button class="mode-btn" data-mode="ellipse">íƒ€ì›</button>
                <button class="mode-btn" data-mode="hyperbola">ìŒê³¡ì„ </button>
            </div>
        </div>

        <!-- ê¸°ë³¸ ì»¨íŠ¸ë¡¤ -->
        <div class="control-group">
            <h3>ë§¤ê°œë³€ìˆ˜ ì¡°ì ˆ</h3>
            <div class="slider-container">
                <label>ì´ˆì  ê±°ë¦¬ / ì´ì‹¬ë¥ : <span id="fValue">2.0</span></label>
                <input type="range" id="focalLength" min="0.5" max="5" step="0.1" value="2">
            </div>
            <div class="slider-container">
                <label>ê´‘ì„  ê°œìˆ˜: <span id="rayCountValue">12</span></label>
                <input type="range" id="rayCount" min="4" max="36" step="2" value="12">
            </div>
            <div class="slider-container">
                <label>ê´‘ì„  ì†ë„: <span id="speedValue">2.0</span></label>
                <input type="range" id="raySpeed" min="0.5" max="5" step="0.25" value="2">
            </div>
            <div class="slider-container">
                <label>ìµœëŒ€ ë°˜ì‚¬ íšŸìˆ˜: <span id="maxBounceValue">15</span></label>
                <input type="range" id="maxBounce" min="1" max="30" step="1" value="15">
            </div>
            <div class="slider-container">
                <label>í™•ëŒ€/ì¶•ì†Œ: <span id="scaleValue">40</span></label>
                <input type="range" id="scale" min="20" max="80" step="5" value="40">
            </div>
        </div>

        <!-- ì‹œê°í™” ì˜µì…˜ -->
        <div class="control-group">
            <h3>ì‹œê°í™” ì˜µì…˜</h3>
            <label class="checkbox-container">
                <input type="checkbox" id="showGrid" checked>
                ì¢Œí‘œê³„ ë° ê·¸ë¦¬ë“œ í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showTrail" checked>
                ê´‘ì„  ê¶¤ì  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showReflectPoints" checked>
                ë°˜ì‚¬ ì§€ì  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showGlow" checked>
                ê¸€ë¡œìš° íš¨ê³¼
            </label>
        </div>

        <!-- ìˆ˜í•™ì  ì •ë³´ -->
        <div class="control-group">
            <h3>ìˆ˜í•™ì  ê³µì‹</h3>
            <div class="info-box">
                <div class="formula" id="formulaDisplay">y = xÂ² / 4f</div>
                <div id="curveDescription">
                    <strong>í¬ë¬¼ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                    í‰í–‰ ì…ì‚¬ê´‘ì€ ì´ˆì  Fë¥¼ í†µê³¼í•˜ë©°, í¬ë¬¼ì„ ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë¬´ì¡°ê±´ ë°˜ì‚¬ë©ë‹ˆë‹¤.
                </div>
            </div>
        </div>

        <!-- ë²”ë¡€ -->
        <div class="control-group">
            <h3>ë²”ë¡€</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>ê³¡ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>ì´ˆì  í†µê³¼ ì „</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff88;"></div>
                    <span>ì´ˆì  í†µê³¼ í›„</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d9ff;"></div>
                    <span>ë°˜ì‚¬ ì§€ì </span>
                </div>
            </div>
        </div>

        <!-- ì´ë¡  ì„¤ëª… -->
        <div class="control-group">
            <h3>ì´ë¡ ì  ë°°ê²½</h3>
            <p class="theory-text" id="theoryText">
                <strong>ë‹¤ì¤‘ ë°˜ì‚¬ ì‹œë®¬ë ˆì´ì…˜:</strong><br><br>
                í¬ë¬¼ì„  ê±°ìš¸ì—ì„œ ê´‘ì„ ì€ ë‹¿ì„ ë•Œë§ˆë‹¤ ë°˜ì‚¬ë©ë‹ˆë‹¤. 
                í‰í–‰ ì…ì‚¬ê´‘ì€ ì²« ë°˜ì‚¬ í›„ ì´ˆì ì„ í†µê³¼í•˜ê³ , 
                ì´í›„ì—ë„ í¬ë¬¼ì„ ì— ë‹¿ìœ¼ë©´ ê³„ì† ë°˜ì‚¬ë˜ì–´ 
                ì´ˆì ì„ ë°˜ë³µì ìœ¼ë¡œ í†µê³¼í•©ë‹ˆë‹¤.
            </p>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <script>
        // ============================================
        // ê´‘í•™ ë°˜ì‚¬ ì‹œë®¬ë ˆì´í„° - ë¬´í•œ ë°˜ì‚¬ ë²„ì „
        // ============================================

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // ìƒíƒœ ê´€ë¦¬
        const state = {
            f: 2.0,
            scale: 40,
            mode: 'parabola',
            raySpeed: 2.0,
            rayCount: 12,
            maxBounce: 15,
            
            showGrid: true,
            showTrail: true,
            showReflectPoints: true,
            showGlow: true,
            
            isRunning: false,
            
            // íƒ€ì› íŒŒë¼ë¯¸í„°
            a: 5,
            b: 3,
            
            centerX: 0,
            centerY: 0
        };

        let rays = [];
        let totalReflections = 0;
        let focusPassCount = 0;
        let completedCount = 0;
        let animationId = null;

        // ============================================
        // ê´‘ì„  í´ë˜ìŠ¤ - ë¬´í•œ ë°˜ì‚¬ ì§€ì›
        // ============================================
        class Ray {
            constructor(x, y, dx, dy, index, total) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.speed = 0.06;
                this.bounces = 0;
                this.active = true;
                this.completed = false;
                
                // ì„¸ê·¸ë¨¼íŠ¸ ê¸°ë°˜ ê²½ë¡œ ì €ì¥
                this.segments = [];
                this.currentSegment = [{ x, y }];
                
                // ìƒ‰ìƒ ìƒíƒœ
                this.colorIndex = 0; // ì´ˆì  í†µê³¼ íšŸìˆ˜
                this.currentColor = 'yellow';
                
                // ìƒ‰ìƒ ì„¤ì • (ê·¸ë¼ë°ì´ì…˜)
                const hue = (index / total) * 40 + 35;
                this.colors = {
                    yellow: `hsla(${hue}, 100%, 55%, 0.9)`,
                    green: `hsla(${140 + (index / total) * 20}, 100%, 50%, 0.9)`,
                    cyan: `hsla(${180 + (index / total) * 20}, 100%, 55%, 0.9)`,
                    magenta: `hsla(${300 + (index / total) * 20}, 100%, 60%, 0.9)`
                };
                
                // íƒ€ì›ìš© ìƒíƒœ
                this.ellipseState = 'toF2';
                
                // ë§ˆì§€ë§‰ ë°˜ì‚¬ ìœ„ì¹˜ (ì¤‘ë³µ ë°©ì§€)
                this.lastReflectX = null;
                this.lastReflectY = null;
            }

            update() {
                if (!this.active) return;

                const step = this.speed * state.raySpeed;
                
                // ì´ì „ ìœ„ì¹˜ ì €ì¥
                const prevX = this.x;
                const prevY = this.y;
                
                // ê³¡ì„ ê³¼ì˜ êµì°¨ì  ì°¾ê¸°
                const intersection = this.findIntersection();
                
                if (intersection) {
                    const distToIntersect = Math.hypot(
                        intersection.x - this.x,
                        intersection.y - this.y
                    );

                    if (distToIntersect <= step + 0.01) {
                        // êµì°¨ì ì— ë„ë‹¬ - ë°˜ì‚¬ ìˆ˜í–‰
                        this.currentSegment.push({ x: intersection.x, y: intersection.y });
                        
                        // í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ ì €ì¥
                        this.segments.push({
                            points: [...this.currentSegment],
                            color: this.currentColor
                        });
                        
                        // ë°˜ì‚¬ ìˆ˜í–‰
                        this.performReflection(intersection);
                        
                        // ìƒˆ ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘
                        this.currentSegment = [{ x: this.x, y: this.y }];
                        
                        return;
                    }
                }

                // ì¼ë°˜ ì´ë™
                this.x += this.dx * step;
                this.y += this.dy * step;

                // ì´ˆì  í†µê³¼ ì²´í¬
                this.checkFocusPass(prevX, prevY);

                // í™”ë©´ ë°– ì²´í¬
                this.checkBounds();
            }

            performReflection(intersection) {
                const { x: px, y: py, nx, ny } = intersection;
                
                // ë²•ì„  ë°©í–¥ ì¡°ì • (ì…ì‚¬ ë°©í–¥ê³¼ ë°˜ëŒ€ìª½ì„ í–¥í•˜ë„ë¡)
                let normalX = nx;
                let normalY = ny;
                const dotIn = this.dx * normalX + this.dy * normalY;
                if (dotIn > 0) {
                    normalX = -normalX;
                    normalY = -normalY;
                }
                
                // ë°˜ì‚¬ ê³µì‹: r = d - 2(dÂ·n)n
                const dot = this.dx * normalX + this.dy * normalY;
                this.dx = this.dx - 2 * dot * normalX;
                this.dy = this.dy - 2 * dot * normalY;
                
                // ë°©í–¥ ë²¡í„° ì •ê·œí™”
                const len = Math.hypot(this.dx, this.dy);
                this.dx /= len;
                this.dy /= len;
                
                // ë°˜ì‚¬ì ì—ì„œ ì•½ê°„ ë–¨ì–´ì§„ ìœ„ì¹˜ë¡œ ì´ë™ (ë‹¤ìŒ ì¶©ëŒ ê°ì§€ë¥¼ ìœ„í•´)
                this.x = px + this.dx * 0.15;
                this.y = py + this.dy * 0.15;
                
                // ë§ˆì§€ë§‰ ë°˜ì‚¬ ìœ„ì¹˜ ê¸°ë¡
                this.lastReflectX = px;
                this.lastReflectY = py;
                
                this.bounces++;
                totalReflections++;
                
                // ìµœëŒ€ ë°˜ì‚¬ íšŸìˆ˜ ì²´í¬
                if (this.bounces >= state.maxBounce) {
                    this.currentSegment.push({ x: this.x, y: this.y });
                    this.segments.push({
                        points: [...this.currentSegment],
                        color: this.currentColor
                    });
                    this.active = false;
                    this.completed = true;
                    completedCount++;
                }
            }

            checkFocusPass(prevX, prevY) {
                if (state.mode === 'parabola') {
                    // í¬ë¬¼ì„ : ì´ˆì  (0, f)
                    const fx = 0, fy = state.f;
                    const dist = Math.hypot(this.x - fx, this.y - fy);
                    
                    if (dist < 0.4) {
                        // ìƒ‰ìƒ ì „í™˜
                        this.saveSegmentAndSwitch(fx, fy);
                        focusPassCount++;
                    }
                } else if (state.mode === 'ellipse') {
                    const c = Math.sqrt(state.a * state.a - state.b * state.b);
                    const f1 = { x: -c, y: 0 };
                    const f2 = { x: c, y: 0 };
                    
                    if (this.ellipseState === 'toF2') {
                        const dist = Math.hypot(this.x - f2.x, this.y - f2.y);
                        if (dist < 0.5) {
                            this.saveSegmentAndSwitch(f2.x, f2.y);
                            this.ellipseState = 'toF1';
                            focusPassCount++;
                        }
                    } else if (this.ellipseState === 'toF1') {
                        const dist = Math.hypot(this.x - f1.x, this.y - f1.y);
                        if (dist < 0.5) {
                            this.saveSegmentAndSwitch(f1.x, f1.y);
                            this.ellipseState = 'toF2';
                            focusPassCount++;
                        }
                    }
                } else if (state.mode === 'hyperbola') {
                    const a = state.a / 2;
                    const c = Math.sqrt(a * a + state.b * state.b);
                    const f2 = { x: c, y: 0 };
                    
                    const dist = Math.hypot(this.x - f2.x, this.y - f2.y);
                    if (dist < 0.5 && this.currentColor === 'yellow') {
                        this.saveSegmentAndSwitch(f2.x, f2.y);
                        focusPassCount++;
                    }
                }
            }

            saveSegmentAndSwitch(fx, fy) {
                // í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ì— ì´ˆì  ìœ„ì¹˜ ì¶”ê°€í•˜ê³  ì €ì¥
                this.currentSegment.push({ x: fx, y: fy });
                this.segments.push({
                    points: [...this.currentSegment],
                    color: this.currentColor
                });
                
                // ìƒ‰ìƒ ì „í™˜
                this.colorIndex++;
                const colorKeys = ['yellow', 'green', 'cyan', 'magenta'];
                this.currentColor = colorKeys[this.colorIndex % colorKeys.length];
                
                // ìƒˆ ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘
                this.currentSegment = [{ x: fx, y: fy }];
            }

            checkBounds() {
                const margin = 15;
                if (Math.abs(this.x) > margin || Math.abs(this.y) > margin) {
                    this.currentSegment.push({ x: this.x, y: this.y });
                    this.segments.push({
                        points: [...this.currentSegment],
                        color: this.currentColor
                    });
                    this.active = false;
                    this.completed = true;
                    completedCount++;
                }
            }

            findIntersection() {
                if (state.mode === 'parabola') {
                    return this.findParabolaIntersection();
                } else if (state.mode === 'ellipse') {
                    return this.findEllipseIntersection();
                } else {
                    return this.findHyperbolaIntersection();
                }
            }

            findParabolaIntersection() {
                // í¬ë¬¼ì„ : y = xÂ² / 4f
                // ê´‘ì„ : (x + dx*t, y + dy*t)
                // ëŒ€ì…í•˜ì—¬ tì— ëŒ€í•œ 2ì°¨ ë°©ì •ì‹ ìœ ë„
                
                const f4 = 4 * state.f;
                
                // (x + dx*t)Â² / 4f = y + dy*t
                // dxÂ²*tÂ² + 2*x*dx*t + xÂ² = 4f*y + 4f*dy*t
                // dxÂ²*tÂ² + (2*x*dx - 4f*dy)*t + (xÂ² - 4f*y) = 0
                
                const A = this.dx * this.dx;
                const B = 2 * this.x * this.dx - f4 * this.dy;
                const C = this.x * this.x - f4 * this.y;
                
                let t = null;
                const minT = 0.1; // ìµœì†Œ ê±°ë¦¬ (ë„ˆë¬´ ê°€ê¹Œìš´ êµì°¨ì  ë¬´ì‹œ)
                
                if (Math.abs(A) < 1e-10) {
                    // ì„ í˜•: B*t + C = 0
                    if (Math.abs(B) > 1e-10) {
                        const t0 = -C / B;
                        if (t0 > minT) t = t0;
                    }
                } else {
                    const disc = B * B - 4 * A * C;
                    if (disc >= 0) {
                        const sqrtDisc = Math.sqrt(disc);
                        const t1 = (-B + sqrtDisc) / (2 * A);
                        const t2 = (-B - sqrtDisc) / (2 * A);
                        
                        // ì–‘ìˆ˜ì´ë©´ì„œ ìµœì†Œ ê±°ë¦¬ ì´ìƒì¸ t ì¤‘ ê°€ì¥ ì‘ì€ ê²ƒ ì„ íƒ
                        const validTs = [t1, t2].filter(tt => tt > minT);
                        if (validTs.length > 0) {
                            t = Math.min(...validTs);
                        }
                    }
                }
                
                if (t === null) return null;
                
                const ix = this.x + this.dx * t;
                const iy = this.y + this.dy * t;
                
                // ë²”ìœ„ ì²´í¬ (í¬ë¬¼ì„ ì´ í™”ë©´ ì•ˆì— ìˆëŠ” ë¶€ë¶„ë§Œ)
                if (Math.abs(ix) > 12 || iy < -0.5 || iy > 20) return null;
                
                // ë§ˆì§€ë§‰ ë°˜ì‚¬ì ê³¼ ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë¬´ì‹œ
                if (this.lastReflectX !== null) {
                    const distFromLast = Math.hypot(ix - this.lastReflectX, iy - this.lastReflectY);
                    if (distFromLast < 0.3) return null;
                }
                
                // ë²•ì„  ê³„ì‚°: y = xÂ²/4f, dy/dx = x/2f
                // ë²•ì„  ë°©í–¥: (-dy/dx, 1) = (-x/2f, 1)
                const slope = ix / (2 * state.f);
                const nLen = Math.hypot(slope, 1);
                
                return {
                    x: ix,
                    y: iy,
                    nx: -slope / nLen,  // ìœ„ìª½ì„ í–¥í•˜ëŠ” ë²•ì„ 
                    ny: 1 / nLen
                };
            }

            findEllipseIntersection() {
                const { a, b } = state;
                
                // íƒ€ì›: xÂ²/aÂ² + yÂ²/bÂ² = 1
                const A = (this.dx * this.dx) / (a * a) + (this.dy * this.dy) / (b * b);
                const B = 2 * ((this.x * this.dx) / (a * a) + (this.y * this.dy) / (b * b));
                const C = (this.x * this.x) / (a * a) + (this.y * this.y) / (b * b) - 1;
                
                const disc = B * B - 4 * A * C;
                if (disc < 0) return null;
                
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-B + sqrtDisc) / (2 * A);
                const t2 = (-B - sqrtDisc) / (2 * A);
                
                const minT = 0.1;
                const validTs = [t1, t2].filter(tt => tt > minT);
                if (validTs.length === 0) return null;
                
                const t = Math.min(...validTs);
                const ix = this.x + this.dx * t;
                const iy = this.y + this.dy * t;
                
                // ë§ˆì§€ë§‰ ë°˜ì‚¬ì ê³¼ ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë¬´ì‹œ
                if (this.lastReflectX !== null) {
                    const distFromLast = Math.hypot(ix - this.lastReflectX, iy - this.lastReflectY);
                    if (distFromLast < 0.3) return null;
                }
                
                // ë²•ì„ : íƒ€ì› ìœ„ì˜ ì  (x,y)ì—ì„œ ë°”ê¹¥ìª½ ë°©í–¥
                let nx = ix / (a * a);
                let ny = iy / (b * b);
                const nLen = Math.hypot(nx, ny);
                
                return {
                    x: ix,
                    y: iy,
                    nx: nx / nLen,
                    ny: ny / nLen
                };
            }

            findHyperbolaIntersection() {
                const a = state.a / 2;
                const b = state.b;
                
                // ìŒê³¡ì„ : xÂ²/aÂ² - yÂ²/bÂ² = 1
                const A = (this.dx * this.dx) / (a * a) - (this.dy * this.dy) / (b * b);
                const B = 2 * ((this.x * this.dx) / (a * a) - (this.y * this.dy) / (b * b));
                const C = (this.x * this.x) / (a * a) - (this.y * this.y) / (b * b) - 1;
                
                if (Math.abs(A) < 1e-10) return null;
                
                const disc = B * B - 4 * A * C;
                if (disc < 0) return null;
                
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-B + sqrtDisc) / (2 * A);
                const t2 = (-B - sqrtDisc) / (2 * A);
                
                const minT = 0.1;
                
                for (const t of [t1, t2].filter(tt => tt > minT).sort((x, y) => x - y)) {
                    const ix = this.x + this.dx * t;
                    const iy = this.y + this.dy * t;
                    
                    // ì˜¤ë¥¸ìª½ ê°€ì§€ë§Œ (x >= a)
                    if (ix >= a - 0.1) {
                        if (this.lastReflectX !== null) {
                            const distFromLast = Math.hypot(ix - this.lastReflectX, iy - this.lastReflectY);
                            if (distFromLast < 0.3) continue;
                        }
                        
                        let nx = ix / (a * a);
                        let ny = -iy / (b * b);
                        const nLen = Math.hypot(nx, ny);
                        
                        return {
                            x: ix,
                            y: iy,
                            nx: nx / nLen,
                            ny: ny / nLen
                        };
                    }
                }
                
                return null;
            }

            draw() {
                const getColor = (colorName) => {
                    return this.colors[colorName] || this.colors.yellow;
                };

                // ì €ì¥ëœ ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ ê·¸ë¦¬ê¸°
                for (const segment of this.segments) {
                    if (segment.points.length < 2) continue;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = getColor(segment.color);
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    const p0 = toCanvas(segment.points[0].x, segment.points[0].y);
                    ctx.moveTo(p0.x, p0.y);
                    
                    for (let i = 1; i < segment.points.length; i++) {
                        const p = toCanvas(segment.points[i].x, segment.points[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                }

                // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì„¸ê·¸ë¨¼íŠ¸
                if (this.currentSegment.length > 0 && state.showTrail) {
                    ctx.beginPath();
                    ctx.strokeStyle = getColor(this.currentColor);
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    
                    const p0 = toCanvas(this.currentSegment[0].x, this.currentSegment[0].y);
                    ctx.moveTo(p0.x, p0.y);
                    
                    for (let i = 1; i < this.currentSegment.length; i++) {
                        const p = toCanvas(this.currentSegment[i].x, this.currentSegment[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                    
                    if (this.active) {
                        const pCur = toCanvas(this.x, this.y);
                        ctx.lineTo(pCur.x, pCur.y);
                    }
                    ctx.stroke();
                }

                // ë°˜ì‚¬ ì§€ì  í‘œì‹œ
                if (state.showReflectPoints) {
                    for (const segment of this.segments) {
                        const lastPoint = segment.points[segment.points.length - 1];
                        const pos = toCanvas(lastPoint.x, lastPoint.y);
                        
                        ctx.beginPath();
                        ctx.fillStyle = 'rgba(0, 212, 255, 0.8)';
                        ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // ê´‘ì„  ë¨¸ë¦¬
                if (this.active) {
                    const pos = toCanvas(this.x, this.y);
                    const colorMap = {
                        yellow: '#ffcc00',
                        green: '#00ff88',
                        cyan: '#00d9ff',
                        magenta: '#ff00ff'
                    };
                    const headColor = colorMap[this.currentColor] || '#ffcc00';
                    
                    if (state.showGlow) {
                        const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 18);
                        gradient.addColorStop(0, headColor);
                        gradient.addColorStop(0.5, headColor + '88');
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.beginPath();
                        ctx.fillStyle = gradient;
                        ctx.arc(pos.x, pos.y, 18, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.beginPath();
                    ctx.fillStyle = '#fff';
                    ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ============================================
        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        // ============================================
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth - 40, container.clientHeight - 40, 800);
            canvas.width = size;
            canvas.height = size;
            state.centerX = canvas.width / 2;
            state.centerY = canvas.height / 2;
        }

        function toCanvas(x, y) {
            return {
                x: state.centerX + x * state.scale,
                y: state.centerY - y * state.scale
            };
        }

        function toMath(px, py) {
            return {
                x: (px - state.centerX) / state.scale,
                y: (state.centerY - py) / state.scale
            };
        }

        // ============================================
        // ê·¸ë¦¬ê¸° í•¨ìˆ˜ë“¤
        // ============================================
        function drawGrid() {
            if (!state.showGrid) return;

            const w = canvas.width;
            const h = canvas.height;

            ctx.strokeStyle = 'rgba(100, 100, 150, 0.15)';
            ctx.lineWidth = 0.5;
            const gridStep = state.scale / 2;
            for (let x = state.centerX % gridStep; x < w; x += gridStep) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % gridStep; y < h; y += gridStep) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.lineWidth = 1;
            for (let x = state.centerX % state.scale; x < w; x += state.scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % state.scale; y < h; y += state.scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, state.centerY);
            ctx.lineTo(w, state.centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(state.centerX, 0);
            ctx.lineTo(state.centerX, h);
            ctx.stroke();
        }

        function drawParabola() {
            // í¬ë¬¼ì„  ê·¸ë¦¼ì/ê¸€ë¡œìš°
            if (state.showGlow) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
                ctx.lineWidth = 12;
                ctx.beginPath();
                const range = canvas.width / state.scale;
                let first = true;
                for (let x = -range; x <= range; x += 0.1) {
                    const y = (x * x) / (4 * state.f);
                    const pos = toCanvas(x, y);
                    if (pos.y < -100 || pos.y > canvas.height + 100) continue;
                    if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                    else ctx.lineTo(pos.x, pos.y);
                }
                ctx.stroke();
            }

            // ë©”ì¸ í¬ë¬¼ì„ 
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const range = canvas.width / state.scale;
            let first = true;
            for (let x = -range; x <= range; x += 0.05) {
                const y = (x * x) / (4 * state.f);
                const pos = toCanvas(x, y);
                if (pos.y < -100 || pos.y > canvas.height + 100) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            // ì´ˆì 
            drawFocus(0, state.f, 'F', '#ffd93d');

            // ì¤€ì„ 
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const directrix = toCanvas(0, -state.f);
            ctx.beginPath();
            ctx.moveTo(0, directrix.y);
            ctx.lineTo(canvas.width, directrix.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        function drawEllipse() {
            const { a, b } = state;
            const c = Math.sqrt(a * a - b * b);

            // ê¸€ë¡œìš°
            if (state.showGlow) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.2)';
                ctx.lineWidth = 15;
                ctx.beginPath();
                ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
                ctx.stroke();
            }

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
            ctx.stroke();

            drawFocus(-c, 0, 'Fâ‚', '#ff006e');
            drawFocus(c, 0, 'Fâ‚‚', '#00ff88');
        }

        function drawHyperbola() {
            const a = state.a / 2;
            const b = state.b;
            const c = Math.sqrt(a * a + b * b);

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;

            // ì˜¤ë¥¸ìª½ ê°€ì§€
            ctx.beginPath();
            let first = true;
            for (let y = -10; y <= 10; y += 0.1) {
                const x = a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (pos.x > canvas.width + 50) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            // ì™¼ìª½ ê°€ì§€ (ë°˜íˆ¬ëª…)
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
            ctx.beginPath();
            first = true;
            for (let y = -10; y <= 10; y += 0.1) {
                const x = -a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (pos.x < -50) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            drawFocus(-c, 0, 'Fâ‚', '#ff006e');
            drawFocus(c, 0, 'Fâ‚‚', '#00ff88');
        }

        function drawFocus(x, y, label, color) {
            const pos = toCanvas(x, y);
            
            // ê¸€ë¡œìš°
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 30);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.3, color + 'aa');
            gradient.addColorStop(0.6, color + '44');
            gradient.addColorStop(1, 'transparent');
            
            ctx.beginPath();
            ctx.fillStyle = gradient;
            ctx.arc(pos.x, pos.y, 30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(pos.x, pos.y, 10, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, pos.x, pos.y - 40);
        }

        // ============================================
        // ê´‘ì„  ìƒì„±
        // ============================================
        function emitRays() {
            rays = [];
            totalReflections = 0;
            focusPassCount = 0;
            completedCount = 0;
            
            const count = state.rayCount;

            if (state.mode === 'parabola') {
                const spread = 7;
                for (let i = 0; i < count; i++) {
                    const x = count === 1 ? 0 : -spread / 2 + (spread * i) / (count - 1);
                    const y = 10;
                    rays.push(new Ray(x, y, 0, -1, i, count));
                }
            } else if (state.mode === 'ellipse') {
                const c = Math.sqrt(state.a * state.a - state.b * state.b);
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    rays.push(new Ray(-c, 0, Math.cos(angle), Math.sin(angle), i, count));
                }
            } else if (state.mode === 'hyperbola') {
                const a = state.a / 2;
                const c = Math.sqrt(a * a + state.b * state.b);
                const f2 = { x: c, y: 0 };
                
                for (let i = 0; i < count; i++) {
                    const startY = count === 1 ? 0 : -5 + (10 * i) / (count - 1);
                    const startX = -10;
                    const dx = f2.x - startX;
                    const dy = f2.y - startY;
                    const len = Math.hypot(dx, dy);
                    rays.push(new Ray(startX, startY, dx / len, dy / len, i, count));
                }
            }
        }

        function updateStats() {
            document.getElementById('activeRays').textContent = rays.filter(r => r.active).length;
            document.getElementById('reflectedCount').textContent = totalReflections;
            document.getElementById('focusPassCount').textContent = focusPassCount;
            document.getElementById('completedCount').textContent = completedCount;
        }

        // ============================================
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        // ============================================
        function animate() {
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();

            switch (state.mode) {
                case 'parabola': drawParabola(); break;
                case 'ellipse': drawEllipse(); break;
                case 'hyperbola': drawHyperbola(); break;
            }

            for (const ray of rays) {
                if (state.isRunning) {
                    ray.update();
                }
                ray.draw();
            }

            updateStats();

            if (!rays.some(r => r.active) && state.isRunning) {
                state.isRunning = false;
                document.getElementById('btnStart').textContent = 'â–¶ ë°œì‚¬';
            }

            animationId = requestAnimationFrame(animate);
        }

        // ============================================
        // ì»¨íŠ¸ë¡¤
        // ============================================
        function toggleSimulation() {
            if (state.isRunning) {
                state.isRunning = false;
                document.getElementById('btnStart').textContent = 'â–¶ ê³„ì†';
            } else {
                if (rays.length === 0 || rays.every(r => !r.active)) {
                    emitRays();
                }
                state.isRunning = true;
                document.getElementById('btnStart').textContent = 'â¸ ì¼ì‹œì •ì§€';
            }
        }

        function stopSimulation() {
            state.isRunning = false;
            document.getElementById('btnStart').textContent = 'â–¶ ë°œì‚¬';
        }

        function resetSimulation() {
            stopSimulation();
            rays = [];
            totalReflections = 0;
            focusPassCount = 0;
            completedCount = 0;
            updateStats();
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        document.getElementById('btnStart').addEventListener('click', toggleSimulation);
        document.getElementById('btnStop').addEventListener('click', stopSimulation);
        document.getElementById('btnReset').addEventListener('click', resetSimulation);

        document.getElementById('focalLength').addEventListener('input', (e) => {
            state.f = parseFloat(e.target.value);
            if (state.mode === 'ellipse') {
                state.a = 5;
                state.b = state.a * Math.sqrt(1 - Math.pow(state.f / 5, 2));
                document.getElementById('fValue').textContent = (state.f / 5).toFixed(2);
            } else {
                document.getElementById('fValue').textContent = state.f.toFixed(1);
            }
            resetSimulation();
        });

        document.getElementById('rayCount').addEventListener('input', (e) => {
            state.rayCount = parseInt(e.target.value);
            document.getElementById('rayCountValue').textContent = state.rayCount;
        });

        document.getElementById('raySpeed').addEventListener('input', (e) => {
            state.raySpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = state.raySpeed.toFixed(1);
        });

        document.getElementById('maxBounce').addEventListener('input', (e) => {
            state.maxBounce = parseInt(e.target.value);
            document.getElementById('maxBounceValue').textContent = state.maxBounce;
        });

        document.getElementById('scale').addEventListener('input', (e) => {
            state.scale = parseInt(e.target.value);
            document.getElementById('scaleValue').textContent = state.scale;
        });

        document.getElementById('showGrid').addEventListener('change', (e) => state.showGrid = e.target.checked);
        document.getElementById('showTrail').addEventListener('change', (e) => state.showTrail = e.target.checked);
        document.getElementById('showReflectPoints').addEventListener('change', (e) => state.showReflectPoints = e.target.checked);
        document.getElementById('showGlow').addEventListener('change', (e) => state.showGlow = e.target.checked);

        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.mode = e.target.dataset.mode;
                resetSimulation();
                updateCurveInfo();
                updateSliderForMode();
            });
        });

        function updateSliderForMode() {
            const slider = document.getElementById('focalLength');
            const label = slider.parentElement.querySelector('label');
            
            if (state.mode === 'ellipse') {
                slider.min = 0.5; slider.max = 4.5; slider.step = 0.1; slider.value = 3;
                state.a = 5;
                state.b = state.a * Math.sqrt(1 - 0.36);
                label.innerHTML = 'ì´ì‹¬ë¥  (c): <span id="fValue">0.60</span>';
                document.getElementById('fValue').textContent = '0.60';
            } else if (state.mode === 'hyperbola') {
                slider.min = 1; slider.max = 4; slider.step = 0.25; slider.value = 2;
                state.a = 4; state.b = 2;
                label.innerHTML = 'í¬ê¸° (a): <span id="fValue">2.0</span>';
                document.getElementById('fValue').textContent = '2.0';
            } else {
                slider.min = 0.5; slider.max = 5; slider.step = 0.1; slider.value = 2;
                state.f = 2;
                label.innerHTML = 'ì´ˆì  ê±°ë¦¬ (f): <span id="fValue">2.0</span>';
                document.getElementById('fValue').textContent = '2.0';
            }
        }

        function updateCurveInfo() {
            const formula = document.getElementById('formulaDisplay');
            const desc = document.getElementById('curveDescription');
            const theory = document.getElementById('theoryText');

            switch (state.mode) {
                case 'parabola':
                    formula.textContent = 'y = xÂ² / 4f';
                    desc.innerHTML = '<strong>í¬ë¬¼ì„  ë‹¤ì¤‘ ë°˜ì‚¬:</strong><br>ê´‘ì„ ì´ í¬ë¬¼ì„ ì— ë‹¿ì„ ë•Œë§ˆë‹¤ ë°˜ì‚¬ë˜ë©°, ë§¤ë²ˆ ì´ˆì ì„ í†µê³¼í•©ë‹ˆë‹¤.';
                    theory.innerHTML = 'í‰í–‰ ì…ì‚¬ê´‘ â†’ ì´ˆì  í†µê³¼ â†’ ì¬ë°˜ì‚¬ â†’ ì´ˆì  í†µê³¼... ì´ ê³¼ì •ì´ ë°˜ë³µë©ë‹ˆë‹¤. ìƒ‰ìƒì´ ë°”ë€” ë•Œë§ˆë‹¤ ì´ˆì ì„ í†µê³¼í•œ ê²ƒì…ë‹ˆë‹¤.';
                    break;
                case 'ellipse':
                    formula.textContent = 'xÂ²/aÂ² + yÂ²/bÂ² = 1';
                    desc.innerHTML = '<strong>íƒ€ì› (Whispering Gallery):</strong><br>Fâ‚ì—ì„œ ì¶œë°œí•œ ê´‘ì„ ì´ Fâ‚‚ë¥¼ ê±°ì³ ë‹¤ì‹œ Fâ‚ìœ¼ë¡œ ëŒì•„ì˜µë‹ˆë‹¤.';
                    theory.innerHTML = 'Fâ‚ â†’ Fâ‚‚ (ë…¸ë€ìƒ‰) â†’ Fâ‚ (ì´ˆë¡ìƒ‰) â†’ Fâ‚‚ â†’ ... ë°˜ë³µ. íƒ€ì› ë‚´ë¶€ì—ì„œ ë‘ ì´ˆì ì„ êµëŒ€ë¡œ í†µê³¼í•©ë‹ˆë‹¤.';
                    break;
                case 'hyperbola':
                    formula.textContent = 'xÂ²/aÂ² - yÂ²/bÂ² = 1';
                    desc.innerHTML = '<strong>ìŒê³¡ì„  ë°˜ì‚¬:</strong><br>Fâ‚‚ë¥¼ í–¥í•˜ëŠ” ê´‘ì„ ì´ ë°˜ì‚¬ í›„ Fâ‚ì—ì„œ ë°œì‚°í•˜ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì…ë‹ˆë‹¤.';
                    theory.innerHTML = 'ì¹´ì„¸ê·¸ë ˆì¸ ë§ì›ê²½ì˜ ì›ë¦¬. ê´‘ì„ ì´ í•œ ì´ˆì ì„ í–¥í•´ ì…ì‚¬í•˜ë©´ ë‹¤ë¥¸ ì´ˆì  ë°©í–¥ìœ¼ë¡œ ë°˜ì‚¬ë©ë‹ˆë‹¤.';
                    break;
            }
        }

        // ì´ˆê¸°í™”
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();
    </script>
</body>
</html>
