<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í¬ë¬¼ì„  ê±°ìš¸ì˜ ë°˜ì‚¬ ì„±ì§ˆ ì‹œë®¬ë ˆì´í„°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Apple SD Gothic Neo', sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
        }

        .control-panel {
            width: 340px;
            min-width: 340px;
            background: linear-gradient(180deg, #16213e 0%, #1a1a2e 100%);
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #0f3460;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #00d9ff;
            text-align: center;
            padding-bottom: 15px;
            border-bottom: 1px solid #0f3460;
            text-shadow: 0 0 10px rgba(0, 217, 255, 0.5);
        }

        .control-group {
            background: rgba(15, 52, 96, 0.5);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #0f3460;
        }

        .control-group h3 {
            font-size: 0.95em;
            color: #ffd93d;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group h3::before {
            content: '';
            width: 8px;
            height: 8px;
            background: #ffd93d;
            border-radius: 50%;
        }

        .slider-container {
            margin-bottom: 12px;
        }

        .slider-container label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 0.85em;
            color: #ccc;
        }

        .slider-container label span {
            color: #00d9ff;
            font-weight: bold;
            font-family: 'Consolas', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, #0f3460, #00d9ff);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #ffd93d;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(255, 217, 61, 0.5);
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.85em;
            cursor: pointer;
        }

        .checkbox-container input {
            width: 18px;
            height: 18px;
            accent-color: #00d9ff;
            cursor: pointer;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .action-btn {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: 8px;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-start {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
        }

        .btn-start:hover {
            transform: scale(1.02);
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }

        .btn-reset {
            background: linear-gradient(135deg, #a855f7, #7c3aed);
            color: white;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border: 1px solid rgba(0, 217, 255, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8em;
            line-height: 1.6;
        }

        .info-box .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
            color: #ffd93d;
            text-align: center;
            margin: 10px 0;
            font-style: italic;
        }

        .live-data {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Consolas', monospace;
            font-size: 0.75em;
            line-height: 1.8;
        }

        .live-data .label {
            color: #888;
        }

        .live-data .value {
            color: #00d9ff;
        }

        .live-data .highlight {
            color: #ffd93d;
            font-weight: bold;
        }

        .mode-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .mode-btn {
            flex: 1;
            min-width: 80px;
            padding: 10px 8px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #ccc;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn:hover {
            background: #1a4a7a;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00d9ff, #0f3460);
            color: white;
            box-shadow: 0 0 15px rgba(0, 217, 255, 0.4);
        }

        .theory-text {
            font-size: 0.78em;
            line-height: 1.7;
            color: #aaa;
            text-align: justify;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            background: #0d1421;
        }

        #mainCanvas {
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 217, 255, 0.2);
            cursor: crosshair;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.75em;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4em;
            color: #00d9ff;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
        }

        @media (max-width: 900px) {
            body {
                flex-direction: column;
            }
            .control-panel {
                width: 100%;
                min-width: auto;
                max-height: 40vh;
                border-right: none;
                border-bottom: 2px solid #0f3460;
            }
            .canvas-container {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="control-panel">
        <h1 class="panel-title">ğŸ”­ ê´‘í•™ ë°˜ì‚¬ ì‹œë®¬ë ˆì´í„°</h1>

        <!-- ì‹œë®¬ë ˆì´ì…˜ ì»¨íŠ¸ë¡¤ -->
        <div class="control-group">
            <h3>ì‹œë®¬ë ˆì´ì…˜ ì œì–´</h3>
            <div class="btn-group">
                <button class="action-btn btn-start" id="btnStart">â–¶ ë°œì‚¬</button>
                <button class="action-btn btn-stop" id="btnStop">â¸ ì •ì§€</button>
                <button class="action-btn btn-reset" id="btnReset">â†º ë¦¬ì…‹</button>
            </div>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="activeRays">0</div>
                    <div class="stat-label">í™œì„± ê´‘ì„ </div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="reflectedCount">0</div>
                    <div class="stat-label">ì´ ë°˜ì‚¬ íšŸìˆ˜</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="focusPassCount">0</div>
                    <div class="stat-label">ì´ˆì  í†µê³¼</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="completedCount">0</div>
                    <div class="stat-label">ì™„ë£Œ</div>
                </div>
            </div>
        </div>

        <!-- ê³¡ì„  ì„ íƒ -->
        <div class="control-group">
            <h3>ê³¡ì„  ìœ í˜• ì„ íƒ</h3>
            <div class="mode-buttons">
                <button class="mode-btn active" data-mode="parabola">í¬ë¬¼ì„ </button>
                <button class="mode-btn" data-mode="ellipse">íƒ€ì›</button>
                <button class="mode-btn" data-mode="hyperbola">ìŒê³¡ì„ </button>
            </div>
        </div>

        <!-- ê¸°ë³¸ ì»¨íŠ¸ë¡¤ -->
        <div class="control-group">
            <h3>ë§¤ê°œë³€ìˆ˜ ì¡°ì ˆ</h3>
            <div class="slider-container">
                <label>ì´ˆì  ê±°ë¦¬ / ì´ì‹¬ë¥ : <span id="fValue">2.0</span></label>
                <input type="range" id="focalLength" min="0.5" max="5" step="0.1" value="2">
            </div>
            <div class="slider-container">
                <label>ê´‘ì„  ê°œìˆ˜: <span id="rayCountValue">12</span></label>
                <input type="range" id="rayCount" min="4" max="36" step="2" value="12">
            </div>
            <div class="slider-container">
                <label>ê´‘ì„  ì†ë„: <span id="speedValue">2.0</span></label>
                <input type="range" id="raySpeed" min="0.5" max="5" step="0.25" value="2">
            </div>
            <div class="slider-container">
                <label>ìµœëŒ€ ë°˜ì‚¬ íšŸìˆ˜: <span id="maxBounceValue">10</span></label>
                <input type="range" id="maxBounce" min="1" max="20" step="1" value="10">
            </div>
            <div class="slider-container">
                <label>í™•ëŒ€/ì¶•ì†Œ: <span id="scaleValue">45</span></label>
                <input type="range" id="scale" min="20" max="80" step="5" value="45">
            </div>
        </div>

        <!-- ì‹œê°í™” ì˜µì…˜ -->
        <div class="control-group">
            <h3>ì‹œê°í™” ì˜µì…˜</h3>
            <label class="checkbox-container">
                <input type="checkbox" id="showGrid" checked>
                ì¢Œí‘œê³„ ë° ê·¸ë¦¬ë“œ í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showTrail" checked>
                ê´‘ì„  ê¶¤ì  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showReflectPoints" checked>
                ë°˜ì‚¬ ì§€ì  í‘œì‹œ
            </label>
            <label class="checkbox-container">
                <input type="checkbox" id="showGlow" checked>
                ê¸€ë¡œìš° íš¨ê³¼
            </label>
        </div>

        <!-- ìˆ˜í•™ì  ì •ë³´ -->
        <div class="control-group">
            <h3>ìˆ˜í•™ì  ê³µì‹</h3>
            <div class="info-box">
                <div class="formula" id="formulaDisplay">y = xÂ² / 4f</div>
                <div id="curveDescription">
                    <strong>í¬ë¬¼ì„ ì˜ ë°˜ì‚¬ ì„±ì§ˆ:</strong><br>
                    ì¶•ì— í‰í–‰í•˜ê²Œ ì…ì‚¬í•˜ëŠ” ëª¨ë“  ê´‘ì„ ì€ ë°˜ì‚¬ í›„ ì´ˆì  Fë¥¼ ì§€ë‚˜ê°‘ë‹ˆë‹¤.
                    ì—¬ëŸ¬ ë²ˆ ë°˜ì‚¬ë˜ì–´ë„ ì´ˆì ì„ ë°˜ë³µ í†µê³¼í•©ë‹ˆë‹¤.
                </div>
            </div>
        </div>

        <!-- ë²”ë¡€ -->
        <div class="control-group">
            <h3>ë²”ë¡€</h3>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: #ff6b6b;"></div>
                    <span>ê³¡ì„ </span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #ffd93d;"></div>
                    <span>ì…ì‚¬ê´‘ / F1â†’F2</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00ff88;"></div>
                    <span>ë°˜ì‚¬ê´‘ / F2â†’F1</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #00d9ff;"></div>
                    <span>ë°˜ì‚¬ ì§€ì </span>
                </div>
            </div>
        </div>

        <!-- ì´ë¡  ì„¤ëª… -->
        <div class="control-group">
            <h3>ì´ë¡ ì  ë°°ê²½</h3>
            <p class="theory-text" id="theoryText">
                <strong>V. Ivchenkoì˜ í•´ì„ì  ì¦ëª…:</strong><br><br>
                í¬ë¬¼ì„  y = xÂ²/4fëŠ” í‰í–‰ê´‘ì„ ì´ í•œ ì (ì´ˆì )ìœ¼ë¡œ ëª¨ì´ëŠ” ìœ ì¼í•œ ê³¡ì„ ì…ë‹ˆë‹¤.
                ë°˜ì‚¬ëœ ê´‘ì„ ë„ ë‹¤ì‹œ í¬ë¬¼ì„ ì— ë‹¿ìœ¼ë©´ ë°˜ì‚¬ë˜ì–´ ì´ˆì ì„ í†µê³¼í•©ë‹ˆë‹¤.
            </p>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>

    <script>
        // ============================================
        // ê´‘í•™ ë°˜ì‚¬ ì‹œë®¬ë ˆì´í„°
        // ë‹¤ì¤‘ ë°˜ì‚¬ ì§€ì› ë²„ì „
        // ============================================

        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // ============================================
        // ìƒíƒœ ê´€ë¦¬
        // ============================================
        const state = {
            f: 2.0,
            scale: 45,
            mode: 'parabola',
            raySpeed: 2.0,
            rayCount: 12,
            maxBounce: 10,
            
            showGrid: true,
            showTrail: true,
            showReflectPoints: true,
            showGlow: true,
            
            isRunning: false,
            
            // íƒ€ì›/ìŒê³¡ì„  íŒŒë¼ë¯¸í„°
            a: 5,
            b: 3,
            eccentricity: 0.6,
            
            centerX: 0,
            centerY: 0
        };

        // ê´‘ì„  ë°°ì—´ ë° í†µê³„
        let rays = [];
        let totalReflections = 0;
        let focusPassCount = 0;
        let completedCount = 0;
        let animationId = null;

        // ============================================
        // ê´‘ì„  í´ë˜ìŠ¤ (ë‹¤ì¤‘ ë°˜ì‚¬ ì§€ì›)
        // ============================================
        class Ray {
            constructor(x, y, dx, dy, index, total) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.speed = 0.08;
                this.bounces = 0;
                this.active = true;
                this.completed = false;
                
                // ì„¸ê·¸ë¨¼íŠ¸ ê¸°ë°˜ ê²½ë¡œ ì €ì¥ (ìƒ‰ìƒ ì •ë³´ í¬í•¨)
                this.segments = [];
                this.currentSegment = [{ x, y }];
                
                // íƒ€ì› ëª¨ë“œìš© ìƒíƒœ
                this.state = 'initial'; // initial, toF2, toF1, done
                this.passedF2 = false;
                this.passedF1Return = false;
                
                // ìƒ‰ìƒ ì„¤ì •
                const hue = (index / total) * 40 + 40;
                this.colorYellow = `hsla(${hue}, 100%, 60%, 0.9)`;
                this.colorGreen = `hsla(${140 + (index / total) * 30}, 100%, 50%, 0.9)`;
                this.colorCyan = `hsla(${180 + (index / total) * 30}, 100%, 60%, 0.9)`;
                this.currentColor = 'yellow';
            }

            update() {
                if (!this.active) return;

                const step = this.speed * state.raySpeed;
                
                // ê³¡ì„ ê³¼ì˜ êµì°¨ì  ì°¾ê¸°
                const intersection = this.findIntersection();
                
                if (intersection) {
                    const distToIntersect = Math.hypot(
                        intersection.x - this.x,
                        intersection.y - this.y
                    );

                    if (distToIntersect <= step) {
                        // ë²½ì— ë„ë‹¬ - ë°˜ì‚¬
                        this.x = intersection.x;
                        this.y = intersection.y;
                        this.currentSegment.push({ x: this.x, y: this.y });
                        
                        // í˜„ì¬ ì„¸ê·¸ë¨¼íŠ¸ ì €ì¥
                        this.segments.push({
                            points: [...this.currentSegment],
                            color: this.currentColor
                        });
                        
                        // ë°˜ì‚¬ ìˆ˜í–‰
                        this.reflect(intersection.x, intersection.y, intersection.nx, intersection.ny);
                        this.bounces++;
                        totalReflections++;
                        
                        // ìƒˆ ì„¸ê·¸ë¨¼íŠ¸ ì‹œì‘
                        this.currentSegment = [{ x: this.x, y: this.y }];
                        
                        // ìµœëŒ€ ë°˜ì‚¬ íšŸìˆ˜ ì²´í¬
                        if (this.bounces >= state.maxBounce) {
                            this.active = false;
                            this.completed = true;
                            completedCount++;
                        }
                        
                        return;
                    }
                }

                // ì¼ë°˜ ì´ë™
                const prevX = this.x;
                const prevY = this.y;
                this.x += this.dx * step;
                this.y += this.dy * step;

                // ì´ˆì  í†µê³¼ ì²´í¬
                this.checkFocusPass(prevX, prevY);

                // í™”ë©´ ë°– ì²´í¬
                const margin = 12;
                if (Math.abs(this.x) > margin || Math.abs(this.y) > margin) {
                    this.currentSegment.push({ x: this.x, y: this.y });
                    this.segments.push({
                        points: [...this.currentSegment],
                        color: this.currentColor
                    });
                    this.active = false;
                    this.completed = true;
                    completedCount++;
                }
            }

            checkFocusPass(prevX, prevY) {
                if (state.mode === 'parabola') {
                    // í¬ë¬¼ì„ : ì´ˆì  (0, f) ê·¼ì²˜ í†µê³¼ ì²´í¬
                    const focusY = state.f;
                    const distToFocus = Math.hypot(this.x - 0, this.y - focusY);
                    
                    if (distToFocus < 0.3) {
                        if (this.currentColor === 'yellow') {
                            this.currentSegment.push({ x: 0, y: focusY });
                            this.segments.push({
                                points: [...this.currentSegment],
                                color: 'yellow'
                            });
                            this.currentSegment = [{ x: 0, y: focusY }];
                            this.currentColor = 'green';
                            focusPassCount++;
                        } else if (this.currentColor === 'green') {
                            this.currentSegment.push({ x: 0, y: focusY });
                            this.segments.push({
                                points: [...this.currentSegment],
                                color: 'green'
                            });
                            this.currentSegment = [{ x: 0, y: focusY }];
                            this.currentColor = 'yellow';
                            focusPassCount++;
                        }
                    }
                } else if (state.mode === 'ellipse') {
                    // íƒ€ì›: F1, F2 ì²´í¬
                    const c = Math.sqrt(state.a * state.a - state.b * state.b);
                    const f1 = { x: -c, y: 0 };
                    const f2 = { x: c, y: 0 };
                    
                    if (this.state === 'initial' || this.state === 'toF2') {
                        const distToF2 = Math.hypot(this.x - f2.x, this.y - f2.y);
                        if (distToF2 < 0.4) {
                            this.currentSegment.push({ x: f2.x, y: f2.y });
                            this.segments.push({
                                points: [...this.currentSegment],
                                color: 'yellow'
                            });
                            this.currentSegment = [{ x: f2.x, y: f2.y }];
                            this.currentColor = 'green';
                            this.state = 'toF1';
                            this.passedF2 = true;
                            focusPassCount++;
                        }
                    }
                    
                    if (this.state === 'toF1') {
                        const distToF1 = Math.hypot(this.x - f1.x, this.y - f1.y);
                        if (distToF1 < 0.4) {
                            this.currentSegment.push({ x: f1.x, y: f1.y });
                            this.segments.push({
                                points: [...this.currentSegment],
                                color: 'green'
                            });
                            this.currentSegment = [{ x: f1.x, y: f1.y }];
                            this.currentColor = 'yellow';
                            this.state = 'toF2';
                            focusPassCount++;
                            
                            // ì™„ë£Œ ì²´í¬
                            if (this.passedF2 && !this.passedF1Return) {
                                this.passedF1Return = true;
                            }
                        }
                    }
                } else if (state.mode === 'hyperbola') {
                    // ìŒê³¡ì„ : ì´ˆì  ì²´í¬
                    const a = state.a / 2;
                    const c = Math.sqrt(a * a + state.b * state.b);
                    const f2 = { x: c, y: 0 };
                    
                    const distToF2 = Math.hypot(this.x - f2.x, this.y - f2.y);
                    if (distToF2 < 0.4 && this.currentColor === 'yellow') {
                        this.currentSegment.push({ x: f2.x, y: f2.y });
                        this.segments.push({
                            points: [...this.currentSegment],
                            color: 'yellow'
                        });
                        this.currentSegment = [{ x: f2.x, y: f2.y }];
                        this.currentColor = 'green';
                        focusPassCount++;
                    }
                }
            }

            findIntersection() {
                if (state.mode === 'parabola') {
                    return this.findParabolaIntersection();
                } else if (state.mode === 'ellipse') {
                    return this.findEllipseIntersection();
                } else {
                    return this.findHyperbolaIntersection();
                }
            }

            findParabolaIntersection() {
                // í¬ë¬¼ì„ : y = xÂ² / 4f
                // ê´‘ì„ : P(t) = (x + dx*t, y + dy*t)
                // ëŒ€ì…: y + dy*t = (x + dx*t)Â² / 4f
                
                const f4 = 4 * state.f;
                const A = (this.dx * this.dx) / f4;
                const B = (2 * this.x * this.dx) / f4 - this.dy;
                const C = (this.x * this.x) / f4 - this.y;
                
                if (Math.abs(A) < 1e-10) {
                    // ì„ í˜• ë°©ì •ì‹
                    if (Math.abs(B) < 1e-10) return null;
                    const t = -C / B;
                    if (t < 0.01) return null;
                    
                    const ix = this.x + this.dx * t;
                    const iy = this.y + this.dy * t;
                    
                    // ë²•ì„  ê³„ì‚°
                    const slope = ix / (2 * state.f);
                    const nLen = Math.sqrt(slope * slope + 1);
                    
                    return {
                        x: ix, y: iy,
                        nx: -slope / nLen,
                        ny: 1 / nLen
                    };
                }
                
                const disc = B * B - 4 * A * C;
                if (disc < 0) return null;
                
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-B + sqrtDisc) / (2 * A);
                const t2 = (-B - sqrtDisc) / (2 * A);
                
                let t = null;
                const eps = 0.01;
                
                if (t1 > eps && t2 > eps) {
                    t = Math.min(t1, t2);
                } else if (t1 > eps) {
                    t = t1;
                } else if (t2 > eps) {
                    t = t2;
                }
                
                if (t === null) return null;
                
                const ix = this.x + this.dx * t;
                const iy = this.y + this.dy * t;
                
                // í™”ë©´ ë²”ìœ„ ì²´í¬
                if (Math.abs(ix) > 10 || iy > 15 || iy < -1) return null;
                
                // ë²•ì„  ê³„ì‚°: ê¸°ìš¸ê¸° = x/2f, ë²•ì„  = (-slope, 1) ì •ê·œí™”
                const slope = ix / (2 * state.f);
                const nLen = Math.sqrt(slope * slope + 1);
                
                return {
                    x: ix, y: iy,
                    nx: -slope / nLen,
                    ny: 1 / nLen
                };
            }

            findEllipseIntersection() {
                const { a, b } = state;
                
                // íƒ€ì›: xÂ²/aÂ² + yÂ²/bÂ² = 1
                const A = (this.dx * this.dx) / (a * a) + (this.dy * this.dy) / (b * b);
                const B = 2 * ((this.x * this.dx) / (a * a) + (this.y * this.dy) / (b * b));
                const C = (this.x * this.x) / (a * a) + (this.y * this.y) / (b * b) - 1;
                
                const disc = B * B - 4 * A * C;
                if (disc < 0) return null;
                
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-B + sqrtDisc) / (2 * A);
                const t2 = (-B - sqrtDisc) / (2 * A);
                
                let t = null;
                const eps = 0.01;
                
                if (t1 > eps && t2 > eps) {
                    t = Math.min(t1, t2);
                } else if (t1 > eps) {
                    t = t1;
                } else if (t2 > eps) {
                    t = t2;
                }
                
                if (t === null) return null;
                
                const ix = this.x + this.dx * t;
                const iy = this.y + this.dy * t;
                
                // ë²•ì„  ê³„ì‚°
                let nx = ix / (a * a);
                let ny = iy / (b * b);
                const nLen = Math.sqrt(nx * nx + ny * ny);
                nx /= nLen;
                ny /= nLen;
                
                return { x: ix, y: iy, nx, ny };
            }

            findHyperbolaIntersection() {
                const a = state.a / 2;
                const b = state.b;
                
                // ìŒê³¡ì„ : xÂ²/aÂ² - yÂ²/bÂ² = 1 (ì˜¤ë¥¸ìª½ ê°€ì§€ë§Œ)
                const A = (this.dx * this.dx) / (a * a) - (this.dy * this.dy) / (b * b);
                const B = 2 * ((this.x * this.dx) / (a * a) - (this.y * this.dy) / (b * b));
                const C = (this.x * this.x) / (a * a) - (this.y * this.y) / (b * b) - 1;
                
                if (Math.abs(A) < 1e-10) return null;
                
                const disc = B * B - 4 * A * C;
                if (disc < 0) return null;
                
                const sqrtDisc = Math.sqrt(disc);
                const t1 = (-B + sqrtDisc) / (2 * A);
                const t2 = (-B - sqrtDisc) / (2 * A);
                
                let t = null;
                const eps = 0.01;
                
                // ê°€ì¥ ê°€ê¹Œìš´ ì–‘ìˆ˜ t ì°¾ê¸°
                const candidates = [t1, t2].filter(tt => tt > eps);
                if (candidates.length === 0) return null;
                
                for (const tt of candidates.sort((x, y) => x - y)) {
                    const ix = this.x + this.dx * tt;
                    const iy = this.y + this.dy * tt;
                    
                    // ì˜¤ë¥¸ìª½ ê°€ì§€ì¸ì§€ í™•ì¸
                    if (ix >= a - 0.1) {
                        // ë²•ì„  ê³„ì‚°
                        let nx = ix / (a * a);
                        let ny = -iy / (b * b);
                        const nLen = Math.sqrt(nx * nx + ny * ny);
                        
                        return {
                            x: ix, y: iy,
                            nx: nx / nLen,
                            ny: ny / nLen
                        };
                    }
                }
                
                return null;
            }

            reflect(px, py, nx, ny) {
                // ë²•ì„ ì´ ì…ì‚¬ ë°©í–¥ê³¼ ê°™ì€ ìª½ì„ í–¥í•˜ë„ë¡ ì¡°ì •
                const dot1 = this.dx * nx + this.dy * ny;
                if (dot1 > 0) {
                    nx = -nx;
                    ny = -ny;
                }
                
                // ë°˜ì‚¬ ê³µì‹: r = d - 2(dÂ·n)n
                const dot = this.dx * nx + this.dy * ny;
                this.dx = this.dx - 2 * dot * nx;
                this.dy = this.dy - 2 * dot * ny;
                
                // ì •ê·œí™”
                const len = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
                this.dx /= len;
                this.dy /= len;
                
                // ë°˜ì‚¬ í›„ ì•½ê°„ ì´ë™ (ë²½ì—ì„œ ë–¨ì–´ì§€ê¸°)
                this.x = px + this.dx * 0.02;
                this.y = py + this.dy * 0.02;
            }

            draw() {
                // ì €ì¥ëœ ëª¨ë“  ì„¸ê·¸ë¨¼íŠ¸ ê·¸ë¦¬ê¸°
                for (const segment of this.segments) {
                    if (segment.points.length < 2) continue;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = segment.color === 'yellow' ? this.colorYellow : this.colorGreen;
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    const p0 = toCanvas(segment.points[0].x, segment.points[0].y);
                    ctx.moveTo(p0.x, p0.y);
                    
                    for (let i = 1; i < segment.points.length; i++) {
                        const p = toCanvas(segment.points[i].x, segment.points[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();
                }

                // í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì„¸ê·¸ë¨¼íŠ¸ ê·¸ë¦¬ê¸°
                if (this.currentSegment.length > 0 && state.showTrail) {
                    ctx.beginPath();
                    ctx.strokeStyle = this.currentColor === 'yellow' ? this.colorYellow : this.colorGreen;
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';
                    
                    const p0 = toCanvas(this.currentSegment[0].x, this.currentSegment[0].y);
                    ctx.moveTo(p0.x, p0.y);
                    
                    for (let i = 1; i < this.currentSegment.length; i++) {
                        const p = toCanvas(this.currentSegment[i].x, this.currentSegment[i].y);
                        ctx.lineTo(p.x, p.y);
                    }
                    
                    if (this.active) {
                        const pCur = toCanvas(this.x, this.y);
                        ctx.lineTo(pCur.x, pCur.y);
                    }
                    ctx.stroke();
                }

                // ë°˜ì‚¬ ì§€ì  í‘œì‹œ
                if (state.showReflectPoints) {
                    for (const segment of this.segments) {
                        if (segment.points.length > 1) {
                            const lastPoint = segment.points[segment.points.length - 1];
                            const pos = toCanvas(lastPoint.x, lastPoint.y);
                            
                            ctx.beginPath();
                            ctx.fillStyle = 'rgba(0, 212, 255, 0.8)';
                            ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                // ê´‘ì„  ë¨¸ë¦¬ ê·¸ë¦¬ê¸°
                if (this.active) {
                    const pos = toCanvas(this.x, this.y);
                    const color = this.currentColor === 'yellow' ? '#ffcc00' : '#00ff88';
                    
                    if (state.showGlow) {
                        const gradient = ctx.createRadialGradient(
                            pos.x, pos.y, 0,
                            pos.x, pos.y, 15
                        );
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(0.4, color);
                        gradient.addColorStop(1, 'transparent');
                        
                        ctx.beginPath();
                        ctx.fillStyle = gradient;
                        ctx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.beginPath();
                    ctx.fillStyle = '#fff';
                    ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // ============================================
        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì •
        // ============================================
        function resizeCanvas() {
            const container = canvas.parentElement;
            const size = Math.min(container.clientWidth - 40, container.clientHeight - 40, 800);
            canvas.width = size;
            canvas.height = size;
            state.centerX = canvas.width / 2;
            state.centerY = canvas.height / 2;
        }

        // ============================================
        // ì¢Œí‘œ ë³€í™˜
        // ============================================
        function toCanvas(x, y) {
            return {
                x: state.centerX + x * state.scale,
                y: state.centerY - y * state.scale
            };
        }

        function toMath(px, py) {
            return {
                x: (px - state.centerX) / state.scale,
                y: (state.centerY - py) / state.scale
            };
        }

        // ============================================
        // ê·¸ë¦¬ë“œ ê·¸ë¦¬ê¸°
        // ============================================
        function drawGrid() {
            if (!state.showGrid) return;

            const w = canvas.width;
            const h = canvas.height;

            // ë³´ì¡° ê·¸ë¦¬ë“œ
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.15)';
            ctx.lineWidth = 0.5;
            const gridStep = state.scale / 2;
            for (let x = state.centerX % gridStep; x < w; x += gridStep) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % gridStep; y < h; y += gridStep) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì£¼ ê·¸ë¦¬ë“œ
            ctx.strokeStyle = 'rgba(100, 100, 150, 0.3)';
            ctx.lineWidth = 1;
            for (let x = state.centerX % state.scale; x < w; x += state.scale) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, h);
                ctx.stroke();
            }
            for (let y = state.centerY % state.scale; y < h; y += state.scale) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }

            // ì¢Œí‘œì¶•
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, state.centerY);
            ctx.lineTo(w, state.centerY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(state.centerX, 0);
            ctx.lineTo(state.centerX, h);
            ctx.stroke();
        }

        // ============================================
        // í¬ë¬¼ì„  ê·¸ë¦¬ê¸°
        // ============================================
        function drawParabola() {
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 15;
            }
            
            ctx.beginPath();
            const range = canvas.width / state.scale;
            let first = true;

            for (let x = -range; x <= range; x += 0.05) {
                const y = (x * x) / (4 * state.f);
                const pos = toCanvas(x, y);
                if (pos.y < -50 || pos.y > canvas.height + 50) continue;
                
                if (first) {
                    ctx.moveTo(pos.x, pos.y);
                    first = false;
                } else {
                    ctx.lineTo(pos.x, pos.y);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ì´ˆì  F
            drawFocus(0, state.f, 'F', '#ffd93d');

            // ì¤€ì„ 
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.2)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const directrix = toCanvas(0, -state.f);
            ctx.beginPath();
            ctx.moveTo(0, directrix.y);
            ctx.lineTo(canvas.width, directrix.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ============================================
        // íƒ€ì› ê·¸ë¦¬ê¸°
        // ============================================
        function drawEllipse() {
            const { a, b } = state;
            const c = Math.sqrt(a * a - b * b);

            // íƒ€ì› í…Œë‘ë¦¬ (ë‹¤ì¸µ íš¨ê³¼)
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.2)';
            ctx.lineWidth = 12;
            ctx.beginPath();
            ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
            ctx.stroke();

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 10;
            }
            ctx.beginPath();
            ctx.ellipse(state.centerX, state.centerY, a * state.scale, b * state.scale, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ë‘ ì´ˆì 
            drawFocus(-c, 0, 'Fâ‚', '#ff006e');
            drawFocus(c, 0, 'Fâ‚‚', '#00ff88');

            // ì¥ì¶•/ë‹¨ì¶• í‘œì‹œ
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(state.centerX - a * state.scale - 20, state.centerY);
            ctx.lineTo(state.centerX + a * state.scale + 20, state.centerY);
            ctx.moveTo(state.centerX, state.centerY - b * state.scale - 20);
            ctx.lineTo(state.centerX, state.centerY + b * state.scale + 20);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ============================================
        // ìŒê³¡ì„  ê·¸ë¦¬ê¸°
        // ============================================
        function drawHyperbola() {
            const a = state.a / 2;
            const b = state.b;
            const c = Math.sqrt(a * a + b * b);

            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            if (state.showGlow) {
                ctx.shadowColor = '#ff6b6b';
                ctx.shadowBlur = 15;
            }

            // ì˜¤ë¥¸ìª½ ê°€ì§€
            ctx.beginPath();
            let first = true;
            for (let y = -8; y <= 8; y += 0.1) {
                const x = a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (pos.x > canvas.width + 50) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();

            // ì™¼ìª½ ê°€ì§€ (í‘œì‹œë§Œ)
            ctx.strokeStyle = 'rgba(255, 107, 107, 0.3)';
            ctx.beginPath();
            first = true;
            for (let y = -8; y <= 8; y += 0.1) {
                const x = -a * Math.sqrt(1 + (y * y) / (b * b));
                const pos = toCanvas(x, y);
                if (pos.x < -50) continue;
                if (first) { ctx.moveTo(pos.x, pos.y); first = false; }
                else ctx.lineTo(pos.x, pos.y);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // ë‘ ì´ˆì 
            drawFocus(-c, 0, 'Fâ‚', '#ff006e');
            drawFocus(c, 0, 'Fâ‚‚', '#00ff88');

            // ì ê·¼ì„ 
            ctx.strokeStyle = 'rgba(255, 217, 61, 0.15)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const slope = b / a;
            ctx.beginPath();
            ctx.moveTo(0, state.centerY + 400 * slope);
            ctx.lineTo(canvas.width, state.centerY - 400 * slope);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, state.centerY - 400 * slope);
            ctx.lineTo(canvas.width, state.centerY + 400 * slope);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // ============================================
        // ì´ˆì  ê·¸ë¦¬ê¸° í—¬í¼
        // ============================================
        function drawFocus(x, y, label, color) {
            const pos = toCanvas(x, y);
            
            // ê¸€ë¡œìš°
            const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 25);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.3, color + '99');
            gradient.addColorStop(0.6, color + '33');
            gradient.addColorStop(1, 'transparent');
            
            ctx.beginPath();
            ctx.fillStyle = gradient;
            ctx.arc(pos.x, pos.y, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // ì¤‘ì‹¬ì 
            ctx.beginPath();
            ctx.fillStyle = color;
            ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.arc(pos.x, pos.y, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¼ë²¨
            ctx.fillStyle = color;
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, pos.x, pos.y - 35);
        }

        // ============================================
        // ê´‘ì„  ìƒì„±
        // ============================================
        function emitRays() {
            rays = [];
            totalReflections = 0;
            focusPassCount = 0;
            completedCount = 0;
            
            const count = state.rayCount;

            if (state.mode === 'parabola') {
                // í¬ë¬¼ì„ : ìœ„ì—ì„œ í‰í–‰í•˜ê²Œ ë‚´ë ¤ì˜¤ëŠ” ê´‘ì„ 
                const spread = 6;
                for (let i = 0; i < count; i++) {
                    const x = -spread / 2 + (spread * i) / (count - 1 || 1);
                    const y = 8;
                    rays.push(new Ray(x, y, 0, -1, i, count));
                }
            } else if (state.mode === 'ellipse') {
                // íƒ€ì›: F1ì—ì„œ ë°©ì‚¬í˜•ìœ¼ë¡œ ë°œì‚¬
                const c = Math.sqrt(state.a * state.a - state.b * state.b);
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const dx = Math.cos(angle);
                    const dy = Math.sin(angle);
                    const ray = new Ray(-c, 0, dx, dy, i, count);
                    ray.state = 'toF2';
                    rays.push(ray);
                }
            } else if (state.mode === 'hyperbola') {
                // ìŒê³¡ì„ : ì™¼ìª½ì—ì„œ F2ë¥¼ í–¥í•´ ë°œì‚¬
                const a = state.a / 2;
                const c = Math.sqrt(a * a + state.b * state.b);
                const f2 = { x: c, y: 0 };
                
                for (let i = 0; i < count; i++) {
                    const startY = -4 + (8 * i) / (count - 1 || 1);
                    const startX = -8;
                    
                    // F2ë¥¼ í–¥í•˜ëŠ” ë°©í–¥
                    const dx = f2.x - startX;
                    const dy = f2.y - startY;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    
                    rays.push(new Ray(startX, startY, dx / len, dy / len, i, count));
                }
            }
        }

        // ============================================
        // í†µê³„ ì—…ë°ì´íŠ¸
        // ============================================
        function updateStats() {
            const activeRays = rays.filter(r => r.active).length;
            document.getElementById('activeRays').textContent = activeRays;
            document.getElementById('reflectedCount').textContent = totalReflections;
            document.getElementById('focusPassCount').textContent = focusPassCount;
            document.getElementById('completedCount').textContent = completedCount;
        }

        // ============================================
        // ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        // ============================================
        function animate() {
            // í´ë¦¬ì–´
            ctx.fillStyle = '#050510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê·¸ë¦¬ë“œ
            drawGrid();

            // ê³¡ì„ 
            switch (state.mode) {
                case 'parabola': drawParabola(); break;
                case 'ellipse': drawEllipse(); break;
                case 'hyperbola': drawHyperbola(); break;
            }

            // ê´‘ì„  ì—…ë°ì´íŠ¸ ë° ê·¸ë¦¬ê¸°
            for (const ray of rays) {
                if (state.isRunning) {
                    ray.update();
                }
                ray.draw();
            }

            // í†µê³„ ì—…ë°ì´íŠ¸
            updateStats();

            // ëª¨ë“  ê´‘ì„ ì´ ì™„ë£Œë˜ì—ˆëŠ”ì§€ ì²´í¬
            const hasActiveRays = rays.some(r => r.active);
            if (!hasActiveRays && state.isRunning) {
                state.isRunning = false;
                document.getElementById('btnStart').textContent = 'â–¶ ë°œì‚¬';
            }

            animationId = requestAnimationFrame(animate);
        }

        // ============================================
        // ì‹œë®¬ë ˆì´ì…˜ ì œì–´
        // ============================================
        function startSimulation() {
            if (rays.length === 0 || rays.every(r => !r.active)) {
                emitRays();
            }
            state.isRunning = true;
            document.getElementById('btnStart').textContent = 'â¸ ì¼ì‹œì •ì§€';
        }

        function toggleSimulation() {
            if (state.isRunning) {
                state.isRunning = false;
                document.getElementById('btnStart').textContent = 'â–¶ ê³„ì†';
            } else {
                startSimulation();
            }
        }

        function stopSimulation() {
            state.isRunning = false;
            document.getElementById('btnStart').textContent = 'â–¶ ë°œì‚¬';
        }

        function resetSimulation() {
            stopSimulation();
            rays = [];
            totalReflections = 0;
            focusPassCount = 0;
            completedCount = 0;
            updateStats();
        }

        // ============================================
        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        // ============================================
        document.getElementById('btnStart').addEventListener('click', toggleSimulation);
        document.getElementById('btnStop').addEventListener('click', stopSimulation);
        document.getElementById('btnReset').addEventListener('click', resetSimulation);

        document.getElementById('focalLength').addEventListener('input', (e) => {
            state.f = parseFloat(e.target.value);
            if (state.mode === 'ellipse') {
                state.eccentricity = state.f / 5;
                state.a = 5;
                state.b = state.a * Math.sqrt(1 - state.eccentricity * state.eccentricity);
                document.getElementById('fValue').textContent = state.eccentricity.toFixed(2);
            } else if (state.mode === 'hyperbola') {
                state.a = state.f * 2;
                state.b = state.f;
                document.getElementById('fValue').textContent = state.f.toFixed(1);
            } else {
                document.getElementById('fValue').textContent = state.f.toFixed(1);
            }
            resetSimulation();
        });

        document.getElementById('rayCount').addEventListener('input', (e) => {
            state.rayCount = parseInt(e.target.value);
            document.getElementById('rayCountValue').textContent = state.rayCount;
        });

        document.getElementById('raySpeed').addEventListener('input', (e) => {
            state.raySpeed = parseFloat(e.target.value);
            document.getElementById('speedValue').textContent = state.raySpeed.toFixed(1);
        });

        document.getElementById('maxBounce').addEventListener('input', (e) => {
            state.maxBounce = parseInt(e.target.value);
            document.getElementById('maxBounceValue').textContent = state.maxBounce;
        });

        document.getElementById('scale').addEventListener('input', (e) => {
            state.scale = parseInt(e.target.value);
            document.getElementById('scaleValue').textContent = state.scale;
        });

        // ì²´í¬ë°•ìŠ¤
        document.getElementById('showGrid').addEventListener('change', (e) => state.showGrid = e.target.checked);
        document.getElementById('showTrail').addEventListener('change', (e) => state.showTrail = e.target.checked);
        document.getElementById('showReflectPoints').addEventListener('change', (e) => state.showReflectPoints = e.target.checked);
        document.getElementById('showGlow').addEventListener('change', (e) => state.showGlow = e.target.checked);

        // ëª¨ë“œ ë²„íŠ¼
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.mode = e.target.dataset.mode;
                resetSimulation();
                updateCurveInfo();
                updateSliderForMode();
            });
        });

        function updateSliderForMode() {
            const slider = document.getElementById('focalLength');
            const label = slider.parentElement.querySelector('label');
            
            if (state.mode === 'ellipse') {
                slider.min = 0.1;
                slider.max = 0.95;
                slider.step = 0.05;
                slider.value = 0.6;
                state.eccentricity = 0.6;
                state.a = 5;
                state.b = state.a * Math.sqrt(1 - 0.36);
                label.innerHTML = 'ì´ì‹¬ë¥ : <span id="fValue">0.60</span>';
            } else if (state.mode === 'hyperbola') {
                slider.min = 1;
                slider.max = 4;
                slider.step = 0.25;
                slider.value = 2;
                state.a = 4;
                state.b = 2;
                label.innerHTML = 'í¬ê¸°: <span id="fValue">2.0</span>';
            } else {
                slider.min = 0.5;
                slider.max = 5;
                slider.step = 0.1;
                slider.value = 2;
                state.f = 2;
                label.innerHTML = 'ì´ˆì  ê±°ë¦¬ (f): <span id="fValue">2.0</span>';
            }
        }

        function updateCurveInfo() {
            const formula = document.getElementById('formulaDisplay');
            const desc = document.getElementById('curveDescription');
            const theory = document.getElementById('theoryText');

        }

        // ============================================
        // ì´ˆê¸°í™” ë° ì‹œì‘
        // ============================================
        window.addEventListener('resize', () => {
            resizeCanvas();
        });

        resizeCanvas();
        animate();
    </script>
</body>
</html>
